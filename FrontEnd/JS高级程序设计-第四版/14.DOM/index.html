<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>第 14 章　 DOM | Hertz&#39;s Blog</title>
    <meta name="generator" content="VuePress 1.7.1">
    
    <meta name="description" content="Hertz's Blog By VuePress">
    
    <link rel="preload" href="/VuePressBlogHtml/assets/css/0.styles.7994d51b.css" as="style"><link rel="preload" href="/VuePressBlogHtml/assets/js/app.a22e24ce.js" as="script"><link rel="preload" href="/VuePressBlogHtml/assets/js/2.273354d5.js" as="script"><link rel="preload" href="/VuePressBlogHtml/assets/js/15.622f6d38.js" as="script"><link rel="preload" href="/VuePressBlogHtml/assets/js/17.398b5375.js" as="script"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/10.2906bcb7.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/11.44da5627.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/12.603be071.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/13.bbb59baa.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/14.37104393.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/16.e98dda23.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/18.87fb9473.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/19.35af09b5.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/20.0860f27f.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/21.80170eb6.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/22.32e3b412.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/23.71a3bc07.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/24.92a37d9c.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/25.6c06b0ec.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/26.56de950a.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/27.389f6e4c.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/28.93cf295c.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/29.8299c662.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/3.82a8b2ed.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/30.030ded92.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/31.37328e23.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/32.33720530.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/33.dbf791bd.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/34.3f59d278.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/35.4db82d0c.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/36.993714ab.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/37.d14d1abc.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/38.5d2531bd.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/39.04716fa1.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/4.89240616.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/40.af165ce2.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/41.be41ee81.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/42.9d0cef92.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/43.d679c459.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/44.d12455da.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/45.50996042.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/46.4ae0dc93.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/47.297e0925.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/48.0b5098bb.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/49.2331b452.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/5.7f54006c.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/50.ed621c31.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/51.ffa15a18.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/52.f023092e.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/53.dcf36f26.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/54.d2f28937.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/55.8d4c4343.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/56.bf7841ef.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/57.0cf87538.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/58.a33d519a.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/59.100761af.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/6.583fbbc7.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/60.2547a25b.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/61.0a622c79.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/62.8bdae0f0.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/63.ae32cec9.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/64.3f841214.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/65.9967bc83.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/66.2b33b58e.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/67.5183b069.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/68.ac765712.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/69.278cdc53.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/7.d3e576f7.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/70.1f5428d0.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/71.44ee8fdb.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/72.4c087926.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/73.2c3e7645.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/74.e2a67ac9.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/8.d70fcbe5.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/9.59956eee.js">
    <link rel="stylesheet" href="/VuePressBlogHtml/assets/css/0.styles.7994d51b.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/VuePressBlogHtml/" class="home-link router-link-active"><!----> <span class="site-name">Hertz's Blog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/VuePressBlogHtml/FrontEnd/" class="nav-link router-link-active">
  前端
</a></div><div class="nav-item"><a href="/VuePressBlogHtml/BackEnd/" class="nav-link">
  后端
</a></div><div class="nav-item"><a href="/VuePressBlogHtml/GIS/" class="nav-link">
  GIS
</a></div><div class="nav-item"><a href="/VuePressBlogHtml/Others/" class="nav-link">
  其他
</a></div><div class="nav-item"><a href="https://github.com/Hertz9409" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/VuePressBlogHtml/FrontEnd/" class="nav-link router-link-active">
  前端
</a></div><div class="nav-item"><a href="/VuePressBlogHtml/BackEnd/" class="nav-link">
  后端
</a></div><div class="nav-item"><a href="/VuePressBlogHtml/GIS/" class="nav-link">
  GIS
</a></div><div class="nav-item"><a href="/VuePressBlogHtml/Others/" class="nav-link">
  其他
</a></div><div class="nav-item"><a href="https://github.com/Hertz9409" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>CSS</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/VuePressBlogHtml/FrontEnd/CSS/CSS1/" class="sidebar-link">CSS1</a></li><li><a href="/VuePressBlogHtml/FrontEnd/CSS/CSS2/" class="sidebar-link">CSS2</a></li><li><a href="/VuePressBlogHtml/FrontEnd/CSS/CSS%E5%8F%98%E6%8D%A2,%E8%BF%87%E6%B8%A1,%E5%8A%A8%E7%94%BB/" class="sidebar-link">CSS变换,过渡,动画</a></li><li><a href="/VuePressBlogHtml/FrontEnd/CSS/CSS%E5%B1%82%E5%8F%A0%E6%80%A7/" class="sidebar-link">CSS层叠性</a></li><li><a href="/VuePressBlogHtml/FrontEnd/CSS/CSS%E6%96%87%E6%9C%AC%E6%A0%B7%E5%BC%8F/" class="sidebar-link">CSS文本样式</a></li><li><a href="/VuePressBlogHtml/FrontEnd/CSS/CSS%E6%B5%81/" class="sidebar-link">CSS流</a></li><li><a href="/VuePressBlogHtml/FrontEnd/CSS/CSS%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/" class="sidebar-link">CSS经典面试题</a></li><li><a href="/VuePressBlogHtml/FrontEnd/CSS/Flex%E5%B8%83%E5%B1%80/" class="sidebar-link">Flex布局</a></li><li><a href="/VuePressBlogHtml/FrontEnd/CSS/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D/" class="sidebar-link">移动端适配</a></li><li><a href="/VuePressBlogHtml/FrontEnd/CSS/%E9%A2%9C%E8%89%B2%E4%B8%8E%E8%83%8C%E6%99%AF/" class="sidebar-link">颜色与背景</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>HTML</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/VuePressBlogHtml/FrontEnd/HTML/%E9%A1%B5%E9%9D%A2%E7%BB%93%E6%9E%84%E8%AF%AD%E4%B9%89%E5%8C%96/" class="sidebar-link">页面结构语义化</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>JS</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/VuePressBlogHtml/FrontEnd/JS/Canvas%E5%9F%BA%E7%A1%80%E4%B8%80/" class="sidebar-link">Canvas基础一</a></li><li><a href="/VuePressBlogHtml/FrontEnd/JS/Canvas%E5%9F%BA%E7%A1%80%E4%BA%8C/" class="sidebar-link">Canvas基础二</a></li><li><a href="/VuePressBlogHtml/FrontEnd/JS/Cookie,Session,Token,Oauth%E5%92%8CJWT/" class="sidebar-link">Cookie,Session,Token,Oauth和JWT</a></li><li><a href="/VuePressBlogHtml/FrontEnd/JS/Echarts%E7%AE%80%E4%BB%8B/" class="sidebar-link">Echarts简介</a></li><li><a href="/VuePressBlogHtml/FrontEnd/JS/Event%20Loop/" class="sidebar-link">Event Loop</a></li><li><a href="/VuePressBlogHtml/FrontEnd/JS/JavaScript%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E3%80%81%E9%97%AD%E5%8C%85/" class="sidebar-link">JavaScript执行上下文、作用域链、闭包</a></li><li><a href="/VuePressBlogHtml/FrontEnd/JS/Promise/" class="sidebar-link">Promise</a></li><li><a href="/VuePressBlogHtml/FrontEnd/JS/Web%20Workers/" class="sidebar-link">Web Workers</a></li><li><a href="/VuePressBlogHtml/FrontEnd/JS/this%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB/" class="sidebar-link">this知识汇总</a></li><li><a href="/VuePressBlogHtml/FrontEnd/JS/%E4%BA%8B%E4%BB%B6%E6%8D%95%E8%8E%B7%E5%92%8C%E5%86%92%E6%B3%A1/" class="sidebar-link">事件捕获和冒泡</a></li><li><a href="/VuePressBlogHtml/FrontEnd/JS/%E5%87%BD%E6%95%B0%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/" class="sidebar-link">函数防抖和节流</a></li><li><a href="/VuePressBlogHtml/FrontEnd/JS/%E5%89%8D%E7%AB%AF%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE/" class="sidebar-link">前端浏览器本地存储数据</a></li><li><a href="/VuePressBlogHtml/FrontEnd/JS/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E7%BB%A7%E6%89%BF/" class="sidebar-link">原型与继承</a></li><li><a href="/VuePressBlogHtml/FrontEnd/JS/%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0/" class="sidebar-link">断点续传</a></li><li><a href="/VuePressBlogHtml/FrontEnd/JS/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%9F%BA%E7%A1%80/" class="sidebar-link">正则表达式基础</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>JS高级程序设计-第四版</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/VuePressBlogHtml/FrontEnd/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E7%AC%AC%E5%9B%9B%E7%89%88/1.%E4%BB%80%E4%B9%88%E6%98%AFJavaScript/" class="sidebar-link">1.什么是JavaScript</a></li><li><a href="/VuePressBlogHtml/FrontEnd/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E7%AC%AC%E5%9B%9B%E7%89%88/10.%E5%87%BD%E6%95%B0/" class="sidebar-link">10.函数</a></li><li><a href="/VuePressBlogHtml/FrontEnd/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E7%AC%AC%E5%9B%9B%E7%89%88/11.%E6%9C%9F%E7%BA%A6%E4%B8%8E%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0/" class="sidebar-link">11.期约与异步函数</a></li><li><a href="/VuePressBlogHtml/FrontEnd/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E7%AC%AC%E5%9B%9B%E7%89%88/12.BOM/" class="sidebar-link">12.BOM</a></li><li><a href="/VuePressBlogHtml/FrontEnd/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E7%AC%AC%E5%9B%9B%E7%89%88/13.%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%A3%80%E6%B5%8B/" class="sidebar-link">13.客户端检测</a></li><li><a href="/VuePressBlogHtml/FrontEnd/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E7%AC%AC%E5%9B%9B%E7%89%88/14.DOM/" aria-current="page" class="active sidebar-link">14.DOM</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/VuePressBlogHtml/FrontEnd/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E7%AC%AC%E5%9B%9B%E7%89%88/14.DOM/#第-14-章-dom" class="sidebar-link">第 14 章　 DOM</a></li><li class="sidebar-sub-header"><a href="/VuePressBlogHtml/FrontEnd/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E7%AC%AC%E5%9B%9B%E7%89%88/14.DOM/#_14-1-节点层级" class="sidebar-link">14.1 　节点层级</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/VuePressBlogHtml/FrontEnd/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E7%AC%AC%E5%9B%9B%E7%89%88/14.DOM/#_14-1-1-node类型" class="sidebar-link">14.1.1 　Node类型</a></li><li class="sidebar-sub-header"><a href="/VuePressBlogHtml/FrontEnd/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E7%AC%AC%E5%9B%9B%E7%89%88/14.DOM/#_14-1-2-document类型" class="sidebar-link">14.1.2 　Document类型</a></li><li class="sidebar-sub-header"><a href="/VuePressBlogHtml/FrontEnd/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E7%AC%AC%E5%9B%9B%E7%89%88/14.DOM/#_14-1-3-element类型" class="sidebar-link">14.1.3 　Element类型</a></li><li class="sidebar-sub-header"><a href="/VuePressBlogHtml/FrontEnd/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E7%AC%AC%E5%9B%9B%E7%89%88/14.DOM/#_14-1-4-text类型" class="sidebar-link">14.1.4 　Text类型</a></li><li class="sidebar-sub-header"><a href="/VuePressBlogHtml/FrontEnd/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E7%AC%AC%E5%9B%9B%E7%89%88/14.DOM/#_14-1-5-comment类型" class="sidebar-link">14.1.5 　Comment类型</a></li><li class="sidebar-sub-header"><a href="/VuePressBlogHtml/FrontEnd/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E7%AC%AC%E5%9B%9B%E7%89%88/14.DOM/#_14-1-6-cdatasection类型" class="sidebar-link">14.1.6 　CDATASection类型</a></li><li class="sidebar-sub-header"><a href="/VuePressBlogHtml/FrontEnd/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E7%AC%AC%E5%9B%9B%E7%89%88/14.DOM/#_14-1-7-documenttype类型" class="sidebar-link">14.1.7 　DocumentType类型</a></li><li class="sidebar-sub-header"><a href="/VuePressBlogHtml/FrontEnd/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E7%AC%AC%E5%9B%9B%E7%89%88/14.DOM/#_14-1-8-documentfragment类型" class="sidebar-link">14.1.8 　DocumentFragment类型</a></li><li class="sidebar-sub-header"><a href="/VuePressBlogHtml/FrontEnd/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E7%AC%AC%E5%9B%9B%E7%89%88/14.DOM/#_14-1-9-attr类型" class="sidebar-link">14.1.9 　Attr类型</a></li></ul></li><li class="sidebar-sub-header"><a href="/VuePressBlogHtml/FrontEnd/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E7%AC%AC%E5%9B%9B%E7%89%88/14.DOM/#_14-2-dom-编程" class="sidebar-link">14.2 　 DOM 编程</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/VuePressBlogHtml/FrontEnd/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E7%AC%AC%E5%9B%9B%E7%89%88/14.DOM/#_14-2-1-动态脚本" class="sidebar-link">14.2.1 　动态脚本</a></li><li class="sidebar-sub-header"><a href="/VuePressBlogHtml/FrontEnd/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E7%AC%AC%E5%9B%9B%E7%89%88/14.DOM/#_14-2-3-操作表格" class="sidebar-link">14.2.3 　操作表格</a></li><li class="sidebar-sub-header"><a href="/VuePressBlogHtml/FrontEnd/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E7%AC%AC%E5%9B%9B%E7%89%88/14.DOM/#_14-2-4-使用nodelist" class="sidebar-link">14.2.4 　使用NodeList</a></li></ul></li><li class="sidebar-sub-header"><a href="/VuePressBlogHtml/FrontEnd/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E7%AC%AC%E5%9B%9B%E7%89%88/14.DOM/#_14-3-mutationobserver接口" class="sidebar-link">14.3 　MutationObserver接口</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/VuePressBlogHtml/FrontEnd/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E7%AC%AC%E5%9B%9B%E7%89%88/14.DOM/#_14-3-1-基本用法" class="sidebar-link">14.3.1 　基本用法</a></li><li class="sidebar-sub-header"><a href="/VuePressBlogHtml/FrontEnd/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E7%AC%AC%E5%9B%9B%E7%89%88/14.DOM/#_14-3-2-mutationobserverinit与观察范围" class="sidebar-link">14.3.2 　MutationObserverInit与观察范围</a></li><li class="sidebar-sub-header"><a href="/VuePressBlogHtml/FrontEnd/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E7%AC%AC%E5%9B%9B%E7%89%88/14.DOM/#_14-3-3-异步回调与记录队列" class="sidebar-link">14.3.3 　异步回调与记录队列</a></li><li class="sidebar-sub-header"><a href="/VuePressBlogHtml/FrontEnd/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E7%AC%AC%E5%9B%9B%E7%89%88/14.DOM/#_14-3-4-性能、内存与垃圾回收" class="sidebar-link">14.3.4 　性能、内存与垃圾回收</a></li></ul></li><li class="sidebar-sub-header"><a href="/VuePressBlogHtml/FrontEnd/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E7%AC%AC%E5%9B%9B%E7%89%88/14.DOM/#_14-4-小结" class="sidebar-link">14.4 　小结</a></li></ul></li><li><a href="/VuePressBlogHtml/FrontEnd/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E7%AC%AC%E5%9B%9B%E7%89%88/15.DOM%E6%89%A9%E5%B1%95/" class="sidebar-link">15.DOM扩展</a></li><li><a href="/VuePressBlogHtml/FrontEnd/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E7%AC%AC%E5%9B%9B%E7%89%88/2HTML%E4%B8%AD%E7%9A%84JavaScript/" class="sidebar-link">2HTML中的JavaScript</a></li><li><a href="/VuePressBlogHtml/FrontEnd/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E7%AC%AC%E5%9B%9B%E7%89%88/3.%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/" class="sidebar-link">3.语言基础</a></li><li><a href="/VuePressBlogHtml/FrontEnd/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E7%AC%AC%E5%9B%9B%E7%89%88/4.%E5%8F%98%E9%87%8F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98/" class="sidebar-link">4.变量、作用域与内存</a></li><li><a href="/VuePressBlogHtml/FrontEnd/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E7%AC%AC%E5%9B%9B%E7%89%88/5.%E5%9F%BA%E6%9C%AC%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/" class="sidebar-link">5.基本引用类型</a></li><li><a href="/VuePressBlogHtml/FrontEnd/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E7%AC%AC%E5%9B%9B%E7%89%88/6.%E9%9B%86%E5%90%88%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/" class="sidebar-link">6.集合引用类型</a></li><li><a href="/VuePressBlogHtml/FrontEnd/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E7%AC%AC%E5%9B%9B%E7%89%88/7.%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8/" class="sidebar-link">7.迭代器与生成器</a></li><li><a href="/VuePressBlogHtml/FrontEnd/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E7%AC%AC%E5%9B%9B%E7%89%88/8.%E5%AF%B9%E8%B1%A1%E3%80%81%E7%B1%BB%E4%B8%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/" class="sidebar-link">8.对象、类与面向对象编程</a></li><li><a href="/VuePressBlogHtml/FrontEnd/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E7%AC%AC%E5%9B%9B%E7%89%88/9.%E4%BB%A3%E7%90%86%E4%B8%8E%E5%8F%8D%E5%B0%84/" class="sidebar-link">9.代理与反射</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>VUE</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/VuePressBlogHtml/FrontEnd/VUE/My-Vue-Study-1/" class="sidebar-link">My-Vue-Study-1</a></li><li><a href="/VuePressBlogHtml/FrontEnd/VUE/My-Vue-Study-2/" class="sidebar-link">My-Vue-Study-2</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>其他</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/VuePressBlogHtml/FrontEnd/%E5%85%B6%E4%BB%96/Https%E4%BB%A5%E5%8F%8A%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/" class="sidebar-link">Https以及前端安全</a></li><li><a href="/VuePressBlogHtml/FrontEnd/%E5%85%B6%E4%BB%96/http%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/" class="sidebar-link">http缓存机制</a></li><li><a href="/VuePressBlogHtml/FrontEnd/%E5%85%B6%E4%BB%96/%E4%BB%8E%E8%BE%93%E5%85%A5url%E5%88%B0%E7%95%8C%E9%9D%A2%E5%B1%95%E7%A4%BA/" class="sidebar-link">从输入url到界面展示</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>前端工程化</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/VuePressBlogHtml/FrontEnd/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/WebPack%E5%9F%BA%E7%A1%80/" class="sidebar-link">WebPack基础</a></li><li><a href="/VuePressBlogHtml/FrontEnd/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/%E5%8E%86%E5%8F%B2%E8%BF%9B%E7%A8%8B/" class="sidebar-link">历史进程</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="第-14-章-dom"><a href="#第-14-章-dom" class="header-anchor">#</a> 第 14 章　 DOM</h2> <blockquote><p><strong>本章内容</strong></p> <ul><li>理解文档对象模型（DOM）的构成</li> <li>节点类型</li> <li>浏览器兼容性</li> <li><code>MutationObserver</code>接口</li></ul></blockquote> <p>文档对象模型（DOM，Document Object Model）是 HTML 和 XML 文档的编程接口。DOM 表示由多层节点构成的文档，通过它开发者可以添加、删除和修改页面的各个部分。脱胎于网景和微软早期的动态 HTML（DHTML，Dynamic HTML），DOM 现在是真正跨平台、语言无关的表示和操作网页的方式。</p> <p>DOM Level 1 在 1998 年成为 W3C 推荐标准，提供了基本文档结构和查询的接口。本章之所以介绍 DOM，主要因为它与浏览器中的 HTML 网页相关，并且在 JavaScript 中提供了 DOM API。</p> <blockquote><p><strong>注意</strong>　 IE8 及更低版本中的 DOM 是通过 COM 对象实现的。这意味着这些版本的 IE 中，DOM 对象跟原生 JavaScript 对象具有不同的行为和功能。</p></blockquote> <h2 id="_14-1-节点层级"><a href="#_14-1-节点层级" class="header-anchor">#</a> 14.1 　节点层级</h2> <p>任何 HTML 或 XML 文档都可以用 DOM 表示为一个由节点构成的层级结构。节点分很多类型，每种类型对应着文档中不同的信息和（或）标记，也都有自己不同的特性、数据和方法，而且与其他类型有某种关系。这些关系构成了层级，让标记可以表示为一个以特定节点为根的树形结构。以下面的 HTML 为例：</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Sample Page&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;p&gt;Hello World!&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre></div><p>如果表示为层级结构，则如图 14-1 所示。</p> <p><img src="http://www.ituring.com.cn/figures/2020/JavaScriptWebDeve4th/021.png" alt="img"></p> <p><strong>图　 14-1</strong></p> <p>其中，<code>document</code>节点表示每个文档的根节点。在这里，根节点的唯一子节点是<code>&lt;html&gt;</code>元素，我们称之为<strong>文档元素</strong>（<code>documentElement</code>）。文档元素是文档最外层的元素，所有其他元素都存在于这个元素之内。每个文档只能有一个文档元素。在 HTML 页面中，文档元素始终是<code>&lt;html&gt;</code>元素。在 XML 文档中，则没有这样预定义的元素，任何元素都可能成为文档元素。</p> <p>HTML 中的每段标记都可以表示为这个树形结构中的一个节点。元素节点表示 HTML 元素，属性节点表示属性，文档类型节点表示文档类型，注释节点表示注释。DOM 中总共有 12 种节点类型，这些类型都继承一种基本类型。</p> <h3 id="_14-1-1-node类型"><a href="#_14-1-1-node类型" class="header-anchor">#</a> 14.1.1 　<code>Node</code>类型</h3> <p>DOM Level 1 描述了名为<code>Node</code>的接口，这个接口是所有 DOM 节点类型都必须实现的。<code>Node</code>接口在 JavaScript 中被实现为<code>Node</code>类型，在除 IE 之外的所有浏览器中都可以直接访问这个类型。在 JavaScript 中，所有节点类型都继承<code>Node</code>类型，因此所有类型都共享相同的基本属性和方法。</p> <p>每个节点都有<code>nodeType</code>属性，表示该节点的类型。节点类型由定义在<code>Node</code>类型上的 12 个数值常量表示：</p> <ul><li><code>Node.ELEMENT_NODE</code>（1）</li> <li><code>Node.ATTRIBUTE_NODE</code>（2）</li> <li><code>Node.TEXT_NODE</code>（3）</li> <li><code>Node.CDATA_SECTION_NODE</code>（4）</li> <li><code>Node.ENTITY_REFERENCE_NODE</code>（5）</li> <li><code>Node.ENTITY_NODE</code>（6）</li> <li><code>Node.PROCESSING_INSTRUCTION_NODE</code>（7）</li> <li><code>Node.COMMENT_NODE</code>（8）</li> <li><code>Node.DOCUMENT_NODE</code>（9）</li> <li><code>Node.DOCUMENT_TYPE_NODE</code>（10）</li> <li><code>Node.DOCUMENT_FRAGMENT_NODE</code>（11）</li> <li><code>Node.NOTATION_NODE</code>（12）</li></ul> <p>节点类型可通过与这些常量比较来确定，比如：</p> <div class="language- extra-class"><pre class="language-text"><code>if (someNode.nodeType == Node.ELEMENT_NODE){
  alert(&quot;Node is an element.&quot;);
}
</code></pre></div><p>这个例子比较了<code>someNode.nodeType</code>与<code>Node.ELEMENT_NODE</code>常量。如果两者相等，则意味着 someNode 是一个元素节点。</p> <p>浏览器并不支持所有节点类型。开发者最常用到的是元素节点和文本节点。本章后面会讨论每种节点受支持的程度及其用法。</p> <ol><li><p><strong>nodeName 与 nodeValue</strong></p> <p><code>nodeName</code>与<code>nodeValue</code>保存着有关节点的信息。这两个属性的值完全取决于节点类型。在使用这两个属性前，最好先检测节点类型，如下所示：</p> <div class="language- extra-class"><pre class="language-text"><code>if (someNode.nodeType == 1){
  value = someNode.nodeName; // 会显示元素的标签名
}
</code></pre></div><p>在这个例子中，先检查了节点是不是元素。如果是，则将其<code>nodeName</code>的值赋给一个变量。对元素而言，<code>nodeName</code>始终等于元素的标签名，而<code>nodeValue</code>则始终为<code>null</code>。</p></li></ol> <ol start="2"><li><p><strong>节点关系</strong></p> <p>文档中的所有节点都与其他节点有关系。这些关系可以形容为家族关系，相当于把文档树比作家谱。在 HTML 中，<code>&lt;body&gt;</code>元素是<code>&lt;html&gt;</code>元素的子元素，而<code>&lt;html&gt;</code>元素则是<code>&lt;body&gt;</code>元素的父元素。<code>&lt;head&gt;</code>元素是<code>&lt;body&gt;</code>元素的同胞元素，因为它们有共同的父元素<code>&lt;html&gt;</code>。</p> <p>每个节点都有一个<code>childNodes</code>属性，其中包含一个<code>NodeList</code>的实例。<code>NodeList</code>是一个类数组对象，用于存储可以按位置存取的有序节点。注意，<code>NodeList</code>并不是<code>Array</code>的实例，但可以使用中括号访问它的值，而且它也有<code>length</code>属性。<code>NodeList</code>对象独特的地方在于，它其实是一个对 DOM 结构的查询，因此 DOM 结构的变化会自动地在<code>NodeList</code>中反映出来。我们通常说<code>NodeList</code>是实时的活动对象，而不是第一次访问时所获得内容的快照。</p> <p>下面的例子展示了如何使用中括号或使用<code>item()</code>方法访问<code>NodeList</code>中的元素：</p> <div class="language- extra-class"><pre class="language-text"><code>let firstChild = someNode.childNodes[0];
let secondChild = someNode.childNodes.item(1);
let count = someNode.childNodes.length;
</code></pre></div><p>无论是使用中括号还是<code>item()</code>方法都是可以的，但多数开发者倾向于使用中括号，因为它是一个类数组对象。注意，<code>length</code>属性表示那一时刻<code>NodeList</code>中节点的数量。使用<code>Array.prototype.slice()</code>可以像前面介绍<code>arguments</code>时一样把<code>NodeList</code>对象转换为数组。比如：</p> <div class="language- extra-class"><pre class="language-text"><code>let arrayOfNodes = Array.prototype.slice.call(someNode.childNodes,0);
</code></pre></div><p>当然，使用 ES6 的<code>Array.from()</code>静态方法，可以替换这种笨拙的方式：</p> <div class="language- extra-class"><pre class="language-text"><code>let arrayOfNodes = Array.from(someNode.childNodes);
</code></pre></div><p>每个节点都有一个<code>parentNode</code>属性，指向其 DOM 树中的父元素。<code>childNodes</code>中的所有节点都有同一个父元素，因此它们的<code>parentNode</code>属性都指向同一个节点。此外，<code>childNodes</code>列表中的每个节点都是同一列表中其他节点的同胞节点。而使用<code>previousSibling</code>和<code>nextSibling</code>可以在这个列表的节点间导航。这个列表中第一个节点的<code>previousSibling</code>属性是<code>null</code>，最后一个节点的<code>nextSibling</code>属性也是<code>null</code>，如下所示：</p> <div class="language- extra-class"><pre class="language-text"><code>if (someNode.nextSibling === null){
  alert(&quot;Last node in the parent's childNodes list.&quot;);
} else if (someNode.previousSibling === null){
  alert(&quot;First node in the parent's childNodes list.&quot;);
}
</code></pre></div><p>注意，如果<code>childNodes</code>中只有一个节点，则它的<code>previousSibling</code>和<code>nextSibling</code>属性都是<code>null</code>。</p> <p>父节点和它的第一个及最后一个子节点也有专门属性：<code>firstChild</code>和<code>lastChild</code>分别指向<code>childNodes</code>中的第一个和最后一个子节点。<code>someNode.firstChild</code>的值始终等于<code>someNode.childNodes[0]</code>，而<code>someNode.lastChild</code>的值始终等于<code>someNode.childNodes[someNode.childNodes.length-1]</code>。如果只有一个子节点，则<code>firstChild</code>和<code>lastChild</code>指向同一个节点。如果没有子节点，则<code>firstChild</code>和<code>lastChild</code>都是<code>null</code>。上述这些节点之间的关系为在文档树的节点之间导航提供了方便。图 14-2 形象地展示了这些关系。</p> <p><img src="http://www.ituring.com.cn/figures/2020/JavaScriptWebDeve4th/022.png" alt="img"></p> <p><strong>图　 14-2</strong></p> <p>有了这些关系，<code>childNodes</code>属性的作用远远不止是必备属性那么简单了。这是因为利用这些关系指针，几乎可以访问到文档树中的任何节点，而这种便利性是<code>childNodes</code>的最大亮点。还有一个便利的方法是<code>hasChildNodes()</code>，这个方法如果返回<code>true</code>则说明节点有一个或多个子节点。相比查询<code>childNodes</code>的<code>length</code>属性，这个方法无疑更方便。</p> <p>最后还有一个所有节点都共享的关系。<code>ownerDocument</code>属性是一个指向代表整个文档的文档节点的指针。所有节点都被创建它们（或自己所在）的文档所拥有，因为一个节点不可能同时存在于两个或者多个文档中。这个属性为迅速访问文档节点提供了便利，因为无需在文档结构中逐层上溯了。</p> <blockquote><p><strong>注意</strong>　虽然所有节点类型都继承了<code>Node</code>，但并非所有节点都有子节点。本章后面会讨论不同节点类型的差异。</p></blockquote></li></ol> <ol start="3"><li><p><strong>操纵节点</strong></p> <p>因为所有关系指针都是只读的，所以 DOM 又提供了一些操纵节点的方法。最常用的方法是<code>appendChild()</code>，用于在<code>childNodes</code>列表末尾添加节点。添加新节点会更新相关的关系指针，包括父节点和之前的最后一个子节点。<code>appendChild()</code>方法返回新添加的节点，如下所示：</p> <div class="language- extra-class"><pre class="language-text"><code>let returnedNode = someNode.appendChild(newNode);
alert(returnedNode == newNode);        // true
alert(someNode.lastChild == newNode);  // true
</code></pre></div><p>如果把文档中已经存在的节点传给<code>appendChild()</code>，则这个节点会从之前的位置被转移到新位置。即使 DOM 树通过各种关系指针维系，一个节点也不会在文档中同时出现在两个或更多个地方。因此，如果调用<code>appendChild()</code>传入父元素的第一个子节点，则这个节点会成为父元素的最后一个子节点，如下所示：</p> <div class="language- extra-class"><pre class="language-text"><code>// 假设someNode有多个子节点
let returnedNode = someNode.appendChild(someNode.firstChild);
alert(returnedNode == someNode.firstChild);  // false
alert(returnedNode == someNode.lastChild);   // true
</code></pre></div><p>如果想把节点放到<code>childNodes</code>中的特定位置而不是末尾，则可以使用<code>insertBefore()</code>方法。这个方法接收两个参数：要插入的节点和参照节点。调用这个方法后，要插入的节点会变成参照节点的前一个同胞节点，并被返回。如果参照节点是<code>null</code>，则<code>insertBefore()</code>与<code>appendChild()</code>效果相同，如下面的例子所示：</p> <div class="language- extra-class"><pre class="language-text"><code>// 作为最后一个子节点插入
returnedNode = someNode.insertBefore(newNode, null);
alert(newNode == someNode.lastChild);  // true

// 作为新的第一个子节点插入
returnedNode = someNode.insertBefore(newNode, someNode.firstChild);
alert(returnedNode == newNode);         // true
alert(newNode == someNode.firstChild);  // true

// 插入最后一个子节点前面
returnedNode = someNode.insertBefore(newNode, someNode.lastChild);
alert(newNode == someNode.childNodes[someNode.childNodes.length - 2]); // true
</code></pre></div><p><code>appendChild()</code>和<code>insertBefore()</code>在插入节点时不会删除任何已有节点。相对地，<code>replaceChild()</code>方法接收两个参数：要插入的节点和要替换的节点。要替换的节点会被返回并从文档树中完全移除，要插入的节点会取而代之。下面看一个例子：</p> <div class="language- extra-class"><pre class="language-text"><code>// 替换第一个子节点
let returnedNode = someNode.replaceChild(newNode, someNode.firstChild);

// 替换最后一个子节点
returnedNode = someNode.replaceChild(newNode, someNode.lastChild);
</code></pre></div><p>使用<code>replaceChild()</code>插入一个节点后，所有关系指针都会从被替换的节点复制过来。虽然被替换的节点从技术上说仍然被同一个文档所拥有，但文档中已经没有它的位置。</p> <p>要移除节点而不是替换节点，可以使用<code>removeChild()</code>方法。这个方法接收一个参数，即要移除的节点。被移除的节点会被返回，如下面的例子所示：</p> <div class="language- extra-class"><pre class="language-text"><code>// 删除第一个子节点
let formerFirstChild = someNode.removeChild(someNode.firstChild);

// 删除最后一个子节点
let formerLastChild = someNode.removeChild(someNode.lastChild);
</code></pre></div><p>与<code>replaceChild()</code>方法一样，通过<code>removeChild()</code>被移除的节点从技术上说仍然被同一个文档所拥有，但文档中已经没有它的位置。</p> <p>上面介绍的 4 个方法都用于操纵某个节点的子元素，也就是说使用它们之前必须先取得父节点（使用前面介绍的<code>parentNode</code>属性）。并非所有节点类型都有子节点，如果在不支持子节点的节点上调用这些方法，则会导致抛出错误。</p></li></ol> <ol start="4"><li><p><strong>其他方法</strong></p> <p>所有节点类型还共享了两个方法。第一个是<code>cloneNode()</code>，会返回与调用它的节点一模一样的节点。<code>cloneNode()</code>方法接收一个布尔值参数，表示是否深复制。在传入<code>true</code>参数时，会进行深复制，即复制节点及其整个子 DOM 树。如果传入<code>false</code>，则只会复制调用该方法的节点。复制返回的节点属于文档所有，但尚未指定父节点，所以可称为孤儿节点（orphan）。可以通过<code>appendChild()</code>、<code>insertBefore()</code>或<code>replaceChild()</code>方法把孤儿节点添加到文档中。以下面的 HTML 片段为例：</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;ul&gt;
  &lt;li&gt;item 1&lt;/li&gt;
  &lt;li&gt;item 2&lt;/li&gt;
  &lt;li&gt;item 3&lt;/li&gt;
&lt;/ul&gt;
</code></pre></div><p>如果<code>myList</code>保存着对这个<code>&lt;ul&gt;</code>元素的引用，则下列代码展示了使用<code>cloneNode()</code>方法的两种方式：</p> <div class="language- extra-class"><pre class="language-text"><code>let deepList = myList.cloneNode(true);
alert(deepList.childNodes.length);    // 3（IE9之前的版本）或7（其他浏览器）

let shallowList = myList.cloneNode(false);
alert(shallowList.childNodes.length); // 0
</code></pre></div><p>在这个例子中，<code>deepList</code>保存着<code>myList</code>的副本。这意味着<code>deepList</code>有 3 个列表项，每个列表项又各自包含文本。变量<code>shallowList</code>则保存着<code>myList</code>的浅副本，因此没有子节点。<code>deepList.childNodes.length</code>的值会因 IE8 及更低版本和其他浏览器对空格的处理方式而不同。IE9 之前的版本不会为空格创建节点。</p> <blockquote><p><strong>注意</strong> <code>cloneNode()</code>方法不会复制添加到 DOM 节点的 JavaScript 属性，比如事件处理程序。这个方法只复制 HTML 属性，以及可选地复制子节点。除此之外则一概不会复制。IE 在很长时间内会复制事件处理程序，这是一个 bug，所以推荐在复制前先删除事件处理程序。</p></blockquote> <p>本节要介绍的最后一个方法是<code>normalize()</code>。这个方法唯一的任务就是处理文档子树中的文本节点。由于解析器实现的差异或 DOM 操作等原因，可能会出现并不包含文本的文本节点，或者文本节点之间互为同胞关系。在节点上调用<code>normalize()</code>方法会检测这个节点的所有后代，从中搜索上述两种情形。如果发现空文本节点，则将其删除；如果两个同胞节点是相邻的，则将其合并为一个文本节点。这个方法将在本章后面进一步讨论。</p></li></ol> <h3 id="_14-1-2-document类型"><a href="#_14-1-2-document类型" class="header-anchor">#</a> 14.1.2 　<code>Document</code>类型</h3> <p><code>Document</code>类型是 JavaScript 中表示文档节点的类型。在浏览器中，文档对象<code>document</code>是<code>HTMLDocument</code>的实例（<code>HTMLDocument</code>继承<code>Document</code>），表示整个 HTML 页面。<code>document</code>是<code>window</code>对象的属性，因此是一个全局对象。<code>Document</code>类型的节点有以下特征：</p> <ul><li><code>nodeType</code>等于 9；</li> <li><code>nodeName</code>值为<code>&quot;#document&quot;</code>；</li> <li><code>nodeValue</code>值为<code>null</code>；</li> <li><code>parentNode</code>值为<code>null</code>；</li> <li><code>ownerDocument</code>值为<code>null</code>；</li> <li>子节点可以是<code>DocumentType</code>（最多一个）、<code>Element</code>（最多一个）、<code>ProcessingInstruction</code>或<code>Comment</code>类型。</li></ul> <p><code>Document</code>类型可以表示 HTML 页面或其他 XML 文档，但最常用的还是通过<code>HTMLDocument</code>的实例取得<code>document</code>对象。<code>document</code>对象可用于获取关于页面的信息以及操纵其外观和底层结构。</p> <ol><li><p><strong>文档子节点</strong></p> <p>虽然 DOM 规范规定<code>Document</code>节点的子节点可以是<code>DocumentType</code>、<code>Element</code>、<code>ProcessingInstruction</code>或<code>Comment</code>，但也提供了两个访问子节点的快捷方式。第一个是<code>documentElement</code>属性，始终指向 HTML 页面中的<code>&lt;html&gt;</code>元素。虽然<code>document.childNodes</code>中始终有<code>&lt;html&gt;</code>元素，但使用<code>documentElement</code>属性可以更快更直接地访问该元素。假如有以下简单的页面：</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;html&gt;
  &lt;body&gt;

  &lt;/body&gt;
&lt;/html&gt;
</code></pre></div><p>浏览器解析完这个页面之后，文档只有一个子节点，即<code>&lt;html&gt;</code>元素。这个元素既可以通过<code>documentElement</code>属性获取，也可以通过<code>childNodes</code>列表访问，如下所示：</p> <div class="language- extra-class"><pre class="language-text"><code>let html = document.documentElement;     // 取得对&lt;html&gt;的引用
alert(html === document.childNodes[0]);  // true
alert(html === document.firstChild);     // true
</code></pre></div><p>这个例子表明<code>documentElement</code>、 <code>firstChild</code>和<code>childNodes[0]</code>都指向同一个值，即<code>&lt;html&gt;</code>元素。</p> <p>作为<code>HTMLDocument</code>的实例，<code>document</code>对象还有一个<code>body</code>属性，直接指向<code>&lt;body&gt;</code>元素。因为这个元素是开发者使用最多的元素，所以 JavaScript 代码中经常可以看到<code>document.body</code>，比如：</p> <div class="language- extra-class"><pre class="language-text"><code>let body = document.body; // 取得对&lt;body&gt;的引用
</code></pre></div><p>所有主流浏览器都支持<code>document.documentElement</code>和<code>document.body</code>。</p> <p><code>Document</code>类型另一种可能的子节点是<code>DocumentType</code>。<code>&lt;!doctype&gt;</code>标签是文档中独立的部分，其信息可以通过<code>doctype</code>属性（在浏览器中是<code>document.doctype</code>）来访问，比如：</p> <div class="language- extra-class"><pre class="language-text"><code>let doctype = document.doctype; // 取得对&lt;!doctype&gt;的引用
</code></pre></div><p>另外，严格来讲出现在<code>&lt;html&gt;</code>元素外面的注释也是文档的子节点，它们的类型是<code>Comment</code>。不过，由于浏览器实现不同，这些注释不一定能被识别，或者表现可能不一致。比如以下 HTML 页面：</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;!-- 第一条注释 --&gt;
&lt;html&gt;
  &lt;body&gt;

  &lt;/body&gt;
&lt;/html&gt;
&lt;!-- 第二条注释 --&gt;
</code></pre></div><p>这个页面看起来有 3 个子节点：注释、<code>&lt;html&gt;</code>元素、注释。逻辑上讲，<code>document.childNodes</code>应该包含 3 项，对应代码中的每个节点。但实际上，浏览器有可能以不同方式对待<code>&lt;html&gt;</code>元素外部的注释，比如忽略一个或两个注释。</p> <p>一般来说，<code>appendChild()</code>、<code>removeChild()</code>和<code>replaceChild()</code>方法不会用在<code>document</code>对象上。这是因为文档类型（如果存在）是只读的，而且只能有一个<code>Element</code>类型的子节点（即<code>&lt;html&gt;</code>，已经存在了）。<strong>1</strong></p></li></ol> <ol start="2"><li><p><strong>文档信息</strong></p> <p><code>document</code>作为<code>HTMLDocument</code>的实例，还有一些标准<code>Document</code>对象上所没有的属性。这些属性提供浏览器所加载网页的信息。其中第一个属性是<code>title</code>，包含<code>&lt;title&gt;</code>元素中的文本，通常显示在浏览器窗口或标签页的标题栏。通过这个属性可以读写页面的标题，修改后的标题也会反映在浏览器标题栏上。不过，修改<code>title</code>属性并不会改变<code>&lt;title&gt;</code>元素。下面是一个例子：</p> <div class="language- extra-class"><pre class="language-text"><code>// 读取文档标题
let originalTitle = document.title;

// 修改文档标题
document.title = &quot;New page title&quot;;
</code></pre></div><p>接下来要介绍的 3 个属性是<code>URL</code>、<code>domain</code>和<code>referrer</code>。其中，<code>URL</code>包含当前页面的完整 URL（地址栏中的 URL），<code>domain</code>包含页面的域名，而<code>referrer</code>包含链接到当前页面的那个页面的 URL。如果当前页面没有来源，则<code>referrer</code>属性包含空字符串。所有这些信息都可以在请求的 HTTP 头部信息中获取，只是在 JavaScript 中通过这几个属性暴露出来而已，如下面的例子所示：</p> <div class="language- extra-class"><pre class="language-text"><code>// 取得完整的URL
let url = document.URL;

// 取得域名
let domain = document.domain;

// 取得来源
let referrer = document.referrer;
</code></pre></div><p>URL 跟域名是相关的。比如，如果<code>document.URL</code>是<code>http://www.wrox.com/WileyCDA/</code>，则<code>document.domain</code>就是<code>www.wrox.com</code>。</p> <p>在这些属性中，只有<code>domain</code>属性是可以设置的。出于安全考虑，给<code>domain</code>属性设置的值是有限制的。如果 URL 包含子域名如<code>p2p.wrox.com</code>，则可以将<code>domain</code>设置为<code>&quot;wrox.com&quot;</code>（URL 包含“www”时也一样，比如<code>www.wrox.com</code>）。不能给这个属性设置 URL 中不包含的值，比如：</p> <div class="language- extra-class"><pre class="language-text"><code>// 页面来自p2p.wrox.com

document.domain = &quot;wrox.com&quot;;      // 成功

document.domain = &quot;nczonline.net&quot;; // 出错！
</code></pre></div><p>当页面中包含来自某个不同子域的窗格（<code>&lt;frame&gt;</code>）或内嵌窗格（<code>&lt;iframe&gt;</code>）时，设置<code>document.domain</code>是有用的。因为跨源通信存在安全隐患，所以不同子域的页面间无法通过 JavaScript 通信。此时，在每个页面上把<code>document.domain</code>设置为相同的值，这些页面就可以访问对方的 JavaScript 对象了。比如，一个加载自<code>www.wrox.com</code>的页面中包含一个内嵌窗格，其中的页面加载自<code>p2p.wrox.com</code>。这两个页面的<code>document.domain</code>包含不同的字符串，内部和外部页面相互之间不能访问对方的 JavaScript 对象。如果每个页面都把<code>document.domain</code>设置为<code>wrox.com</code>，那这两个页面之间就可以通信了。</p> <p>浏览器对<code>domain</code>属性还有一个限制，即这个属性一旦放松就不能再收紧。比如，把<code>document.domain</code> 设置为<code>&quot;wrox.com&quot;</code>之后，就不能再将其设置回<code>&quot;p2p.wrox.com&quot;</code>，后者会导致错误，比如：</p> <div class="language- extra-class"><pre class="language-text"><code>// 页面来自p2p.wrox.com

document.domain = &quot;wrox.com&quot;;     // 放松，成功

document.domain = &quot;p2p.wrox.com&quot;; // 收紧，错误！
</code></pre></div></li></ol> <ol start="3"><li><p><strong>定位元素</strong></p> <p>使用 DOM 最常见的情形可能就是获取某个或某组元素的引用，然后对它们执行某些操作。<code>document</code>对象上暴露了一些方法，可以实现这些操作。<code>getElementById()</code>和<code>getElementsByTagName()</code>就是<code>Document</code>类型提供的两个方法。</p> <p><code>getElementById()</code>方法接收一个参数，即要获取元素的 ID，如果找到了则返回这个元素，如果没找到则返回<code>null</code>。参数 ID 必须跟元素在页面中的<code>id</code>属性值完全匹配，包括大小写。比如页面中有以下元素：</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;div id=&quot;myDiv&quot;&gt;Some text&lt;/div&gt;
</code></pre></div><p>可以使用如下代码取得这个元素：</p> <div class="language- extra-class"><pre class="language-text"><code>let div = document.getElementById(&quot;myDiv&quot;); // 取得对这个&lt;div&gt;元素的引用
</code></pre></div><p>但参数大小写不匹配会返回<code>null</code>：</p> <div class="language- extra-class"><pre class="language-text"><code>let div = document.getElementById(&quot;mydiv&quot;); // null
</code></pre></div><p>如果页面中存在多个具有相同 ID 的元素，则<code>getElementById()</code>返回在文档中出现的第一个元素。</p> <p><code>getElementsByTagName()</code>是另一个常用来获取元素引用的方法。这个方法接收一个参数，即要获取元素的标签名，返回包含零个或多个元素的<code>NodeList</code>。在 HTML 文档中，这个方法返回一个<code>HTMLCollection</code>对象。考虑到二者都是“实时”列表，<code>HTMLCollection</code>与<code>NodeList</code>是很相似的。例如，下面的代码会取得页面中所有的<code>&lt;img&gt;</code>元素并返回包含它们的<code>HTMLCollection</code>：</p> <div class="language- extra-class"><pre class="language-text"><code>let images = document.getElementsByTagName(&quot;img&quot;);
</code></pre></div><p>这里把返回的<code>HTMLCollection</code>对象保存在了变量<code>images</code>中。与<code>NodeList</code>对象一样，也可以使用中括号或<code>item()</code>方法从<code>HTMLCollection</code>取得特定的元素。而取得元素的数量同样可以通过<code>length</code>属性得知，如下所示：</p> <div class="language- extra-class"><pre class="language-text"><code>alert(images.length);       // 图片数量
alert(images[0].src);       // 第一张图片的src属性
alert(images.item(0).src);  // 同上
</code></pre></div><p><code>HTMLCollection</code>对象还有一个额外的方法<code>namedItem()</code>，可通过标签的<code>name</code>属性取得某一项的引用。例如，假设页面中包含如下的<code>&lt;img&gt;</code>元素：</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;img src=&quot;myimage.gif&quot; name=&quot;myImage&quot;&gt;
</code></pre></div><p>那么也可以像这样从<code>images</code>中取得对这个<code>&lt;img&gt;</code>元素的引用：</p> <div class="language- extra-class"><pre class="language-text"><code>let myImage = images.namedItem(&quot;myImage&quot;);
</code></pre></div><p>这样，<code>HTMLCollection</code>就提供了除索引之外的另一种获取列表项的方式，从而为取得元素提供了便利。对于<code>name</code>属性的元素，还可以直接使用中括号来获取，如下面的例子所示：</p> <div class="language- extra-class"><pre class="language-text"><code>let myImage = images[&quot;myImage&quot;];
</code></pre></div><p>对<code>HTMLCollection</code>对象而言，中括号既可以接收数值索引，也可以接收字符串索引。而在后台，数值索引会调用<code>item()</code>，字符串索引会调用<code>namedItem()</code>。</p> <p>要取得文档中的所有元素，可以给<code>getElementsByTagName()</code>传入<code>*</code>。在 JavaScript 和 CSS 中，<code>*</code>一般被认为是匹配一切的字符。来看下面的例子：</p> <div class="language- extra-class"><pre class="language-text"><code>let allElements = document.getElementsByTagName(&quot;*&quot;);
</code></pre></div><p>这行代码可以返回包含页面中所有元素的<code>HTMLCollection</code>对象，顺序就是它们在页面中出现的顺序。因此第一项是<code>&lt;html&gt;</code>元素，第二项是<code>&lt;head&gt;</code>元素，以此类推。</p> <blockquote><p><strong>注意</strong>　对于<code>document.getElementsByTagName()</code>方法，虽然规范要求区分标签的大小写，但为了最大限度兼容原有 HTML 页面，实际上是不区分大小写的。如果是在 XML 页面（如 XHTML）中使用，那么<code>document.getElementsByTagName()</code>就是区分大小写的。</p></blockquote> <p><code>HTMLDocument</code>类型上定义的获取元素的第三个方法是<code>getElementsByName()</code>。顾名思义，这个方法会返回具有给定<code>name</code>属性的所有元素。<code>getElementsByName()</code>方法最常用于单选按钮，因为同一字段的单选按钮必须具有相同的<code>name</code>属性才能确保把正确的值发送给服务器，比如下面的例子：</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;fieldset&gt;
  &lt;legend&gt;Which color do you prefer?&lt;/legend&gt;
  &lt;ul&gt;
    &lt;li&gt;
      &lt;input type=&quot;radio&quot; value=&quot;red&quot; name=&quot;color&quot; id=&quot;colorRed&quot;&gt;
      &lt;label for=&quot;colorRed&quot;&gt;Red&lt;/label&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;input type=&quot;radio&quot; value=&quot;green&quot; name=&quot;color&quot; id=&quot;colorGreen&quot;&gt;
      &lt;label for=&quot;colorGreen&quot;&gt;Green&lt;/label&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;input type=&quot;radio&quot; value=&quot;blue&quot; name=&quot;color&quot; id=&quot;colorBlue&quot;&gt;
      &lt;label for=&quot;colorBlue&quot;&gt;Blue&lt;/label&gt;
    &lt;/li&gt;
  &lt;/ul&gt;
&lt;/fieldset&gt;
</code></pre></div><p>这里所有的单选按钮都有名为<code>&quot;color&quot;</code>的<code>name</code>属性，但它们的 ID 都不一样。这是因为 ID 是为了匹配对应的<code>&lt;label&gt;</code>元素，而<code>name</code>相同是为了保证只将三个中的一个值发送给服务器。然后就可以像下面这样取得所有单选按钮：</p> <div class="language- extra-class"><pre class="language-text"><code>let radios = document.getElementsByName(&quot;color&quot;);
</code></pre></div><p>与<code>getElementsByTagName()</code>一样，<code>getElementsByName()</code>方法也返回<code>HTMLCollection</code>。不过在这种情况下，<code>namedItem()</code>方法只会取得第一项（因为所有项的<code>name</code>属性都一样）。</p></li></ol> <ol start="4"><li><p><strong>特殊集合</strong></p> <p><code>document</code>对象上还暴露了几个特殊集合，这些集合也都是<code>HTMLCollection</code>的实例。这些集合是访问文档中公共部分的快捷方式，列举如下。</p> <ul><li><code>document.anchors</code>包含文档中所有带<code>name</code>属性的<code>&lt;a&gt;</code>元素。</li> <li><code>document.applets</code>包含文档中所有<code>&lt;applet&gt;</code>元素（因为<code>&lt;applet&gt;</code>元素已经不建议使用，所以这个集合已经废弃）。</li> <li><code>document.forms</code>包含文档中所有<code>&lt;form&gt;</code>元素（与<code>document.getElementsByTagName (&quot;form&quot;)</code>返回的结果相同）。</li> <li><code>document.images</code>包含文档中所有<code>&lt;img&gt;</code>元素（与<code>document.getElementsByTagName (&quot;img&quot;)</code>返回的结果相同）。</li> <li><code>document.links</code>包含文档中所有带<code>href</code>属性的<code>&lt;a&gt;</code>元素。</li></ul> <p>这些特殊集合始终存在于<code>HTMLDocument</code>对象上，而且与所有<code>HTMLCollection</code>对象一样，其内容也会实时更新以符合当前文档的内容。</p></li></ol> <ol start="5"><li><p><strong>DOM 兼容性检测</strong></p> <p>由于 DOM 有多个 Level 和多个部分，因此确定浏览器实现了 DOM 的哪些部分是很必要的。<code>document.implementation</code>属性是一个对象，其中提供了与浏览器 DOM 实现相关的信息和能力。DOM Level 1 在<code>document.implementation</code>上只定义了一个方法，即<code>hasFeature()</code>。这个方法接收两个参数：特性名称和 DOM 版本。如果浏览器支持指定的特性和版本，则<code>hasFeature()</code>方法返回<code>true</code>，如下面的例子所示：</p> <div class="language- extra-class"><pre class="language-text"><code>let hasXmlDom = document.implementation.hasFeature(&quot;XML&quot;, &quot;1.0&quot;);
</code></pre></div><p>可以使用<code>hasFeature()</code>方法测试的特性及版本如下表所列。</p> <table><thead><tr><th style="text-align:left;">特性</th> <th style="text-align:left;">支持的版本</th> <th style="text-align:left;">说明</th></tr></thead> <tbody><tr><td style="text-align:left;"><code>Core</code></td> <td style="text-align:left;">1.0、2.0、3.0</td> <td style="text-align:left;">定义树形文档结构的基本 DOM</td></tr> <tr><td style="text-align:left;"><code>XML</code></td> <td style="text-align:left;">1.0、2.0、3.0</td> <td style="text-align:left;"><code>Core</code>的 XML 扩展，增加了对 CDATA 区块、处理指令和实体的支持</td></tr> <tr><td style="text-align:left;"><code>HTML</code></td> <td style="text-align:left;">1.0、2.0</td> <td style="text-align:left;"><code>XML</code>的 HTML 扩展，增加了 HTML 特定的元素和实体</td></tr> <tr><td style="text-align:left;"><code>Views</code></td> <td style="text-align:left;">2.0</td> <td style="text-align:left;">文档基于某些样式的实现格式</td></tr> <tr><td style="text-align:left;"><code>StyleSheets</code></td> <td style="text-align:left;">2.0</td> <td style="text-align:left;">文档的相关样式表</td></tr> <tr><td style="text-align:left;"><code>CSS</code></td> <td style="text-align:left;">2.0</td> <td style="text-align:left;">Cascading Style Sheets Level 1</td></tr> <tr><td style="text-align:left;"><code>CSS2</code></td> <td style="text-align:left;">2.0</td> <td style="text-align:left;">Cascading Style Sheets Level 2</td></tr> <tr><td style="text-align:left;"><code>Events</code></td> <td style="text-align:left;">2.0、3.0</td> <td style="text-align:left;">通用 DOM 事件</td></tr> <tr><td style="text-align:left;"><code>UIEvents</code></td> <td style="text-align:left;">2.0、3.0</td> <td style="text-align:left;">用户界面事件</td></tr> <tr><td style="text-align:left;"><code>TextEvents</code></td> <td style="text-align:left;">3.0</td> <td style="text-align:left;">文本输入设备触发的事件</td></tr> <tr><td style="text-align:left;"><code>MouseEvents</code></td> <td style="text-align:left;">2.0、3.0</td> <td style="text-align:left;">鼠标导致的事件（单击、悬停等）</td></tr> <tr><td style="text-align:left;"><code>MutationEvents</code></td> <td style="text-align:left;">2.0、3.0</td> <td style="text-align:left;">DOM 树变化时触发的事件</td></tr> <tr><td style="text-align:left;"><code>MutationNameEvents</code></td> <td style="text-align:left;">3.0</td> <td style="text-align:left;">DOM 元素或元素属性被重命名时触发的事件</td></tr> <tr><td style="text-align:left;"><code>HTMLEvents</code></td> <td style="text-align:left;">2.0</td> <td style="text-align:left;">HTML 4.01 事件</td></tr> <tr><td style="text-align:left;"><code>Range</code></td> <td style="text-align:left;">2.0</td> <td style="text-align:left;">在 DOM 树中操作一定范围的对象和方法</td></tr> <tr><td style="text-align:left;"><code>Traversal</code></td> <td style="text-align:left;">2.0</td> <td style="text-align:left;">遍历 DOM 树的方法</td></tr> <tr><td style="text-align:left;"><code>LS</code></td> <td style="text-align:left;">3.0</td> <td style="text-align:left;">文件与 DOM 树之间的同步加载与保存</td></tr> <tr><td style="text-align:left;"><code>LS-Async</code></td> <td style="text-align:left;">3.0</td> <td style="text-align:left;">文件与 DOM 树之间的异步加载与保存</td></tr> <tr><td style="text-align:left;"><code>Validation</code></td> <td style="text-align:left;">3.0</td> <td style="text-align:left;">修改 DOM 树并保证其继续有效的方法</td></tr> <tr><td style="text-align:left;"><code>XPath</code></td> <td style="text-align:left;">3.0</td> <td style="text-align:left;">访问 XML 文档不同部分的语言</td></tr></tbody></table> <p>由于实现不一致，因此<code>hasFeature()</code>的返回值并不可靠。目前这个方法已经被废弃，不再建议使用。为了向后兼容，目前主流浏览器仍然支持这个方法，但无论检测什么都一律返回<code>true</code>。</p></li></ol> <ol start="6"><li><p><strong>文档写入</strong></p> <p><code>document</code>对象有一个古老的能力，即向网页输出流中写入内容。这个能力对应 4 个方法：<code>write()</code>、<code>writeln()</code>、<code>open()</code>和<code>close()</code>。其中，<code>write()</code>和<code>writeln()</code>方法都接收一个字符串参数，可以将这个字符串写入网页中。<code>write()</code>简单地写入文本，而<code>writeln()</code>还会在字符串末尾追加一个换行符（<code>\n</code>）。这两个方法可以用来在页面加载期间向页面中动态添加内容，如下所示：</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;document.write() Example&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;p&gt;The current date and time is:
  &lt;script type=&quot;text/javascript&quot;&gt;
    document.write(&quot;&lt;strong&gt;&quot; + (new Date()).toString() + &quot;&lt;/strong&gt;&quot;);
  &lt;/script&gt;
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre></div><p>这个例子会在页面加载过程中输出当前日期和时间。日期放在了<code>&lt;strong&gt;</code>元素中，如同它们之前就包含在 HTML 页面中一样。这意味着会创建一个 DOM 元素，以后也可以访问。通过<code>write()</code>和<code>writeln()</code>输出的任何 HTML 都会以这种方式来处理。</p> <p><code>write()</code>和<code>writeln()</code>方法经常用于动态包含外部资源，如 JavaScript 文件。在包含 JavaScript 文件时，记住不能像下面的例子中这样直接包含字符串<code>&quot;&lt;/script&gt;&quot;</code>，因为这个字符串会被解释为脚本块的结尾，导致后面的代码不能执行：</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;document.write() Example&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;script type=&quot;text/javascript&quot;&gt;
    document.write(&quot;&lt;script type=\&quot;text/javascript\&quot; src=\&quot;file.js\&quot;&gt;&quot; +
      &quot;&lt;/script&gt;&quot;);
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre></div><p>虽然这样写看起来没错，但输出之后的<code>&quot;&lt;/script&gt;&quot;</code>会匹配最外层的<code>&lt;script&gt;</code>标签，导致页面中显示出<code>&quot;);</code>。为避免出现这个问题，需要对前面的例子稍加修改：</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;document.write() Example&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;script type=&quot;text/javascript&quot;&gt;
    document.write(&quot;&lt;script type=\&quot;text/javascript\&quot; src=\&quot;file.js\&quot;&gt;&quot; +
      &quot;&lt;\/script&gt;&quot;);
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre></div><p>这里的字符串<code>&quot;&lt;\/script&gt;&quot;</code>不会再匹配最外层的<code>&lt;script&gt;</code>标签，因此不会在页面中输出额外内容。</p> <p>前面的例子展示了在页面渲染期间通过<code>document.write()</code>向文档中输出内容。如果是在页面加载完之后再调用<code>document.write()</code>，则输出的内容会重写整个页面，如下面的例子所示：</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;document.write() Example&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;p&gt;This is some content that you won't get to see because it will be
  overwritten.&lt;/p&gt;
  &lt;script type=&quot;text/javascript&quot;&gt;
    window.onload = function(){
      document.write(&quot;Hello world!&quot;);
    };
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre></div><p>这个例子使用了<code>window.onload</code>事件处理程序，将调用<code>document.write()</code>的函数推迟到页面加载完毕后执行。执行之后，字符串<code>&quot;Hello world!&quot;</code>会重写整个页面内容。</p> <p><code>open()</code>和<code>close()</code>方法分别用于打开和关闭网页输出流。在调用<code>write()</code>和<code>writeln()</code>时，这两个方法都不是必需的。</p> <blockquote><p><strong>注意</strong>　严格的 XHTML 文档不支持文档写入。对于内容类型为<code>application</code>/<code>xml</code>+<code>xhtml</code>的页面，这些方法不起作用。</p></blockquote></li></ol> <p><strong>1</strong>元素是<code>HTMLHtmlElement</code>的实例，<code>HTMLHtmlElement</code>继承<code>HTMLElement</code>，<code>HTMLElement</code>继承<code>Element</code>，因此 HTML 文档可以包含子节点，但不能多于一个。——译者注</p> <h3 id="_14-1-3-element类型"><a href="#_14-1-3-element类型" class="header-anchor">#</a> 14.1.3 　<code>Element</code>类型</h3> <p>除了<code>Document</code>类型，<code>Element</code>类型就是 Web 开发中最常用的类型了。<code>Element</code>表示 XML 或 HTML 元素，对外暴露出访问元素标签名、子节点和属性的能力。<code>Element</code>类型的节点具有以下特征：</p> <ul><li><code>nodeType</code>等于 1；</li> <li><code>nodeName</code>值为元素的标签名；</li> <li><code>nodeValue</code>值为<code>null</code>；</li> <li><code>parentNode</code>值为<code>Document</code>或<code>Element</code>对象；</li> <li>子节点可以是<code>Element</code>、<code>Text</code>、<code>Comment</code>、<code>ProcessingInstruction</code>、<code>CDATASection</code>、<code>EntityReference</code>类型。</li></ul> <p>可以通过<code>nodeName</code>或<code>tagName</code>属性来获取元素的标签名。这两个属性返回同样的值（添加后一个属性明显是为了不让人误会）。比如有下面的元素：</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;div id=&quot;myDiv&quot;&gt;&lt;/div&gt;
</code></pre></div><p>可以像这样取得这个元素的标签名：</p> <div class="language- extra-class"><pre class="language-text"><code>let div = document.getElementById(&quot;myDiv&quot;);
alert(div.tagName); // &quot;DIV&quot;
alert(div.tagName == div.nodeName); // true
</code></pre></div><p>例子中的元素标签名为<code>div</code>，ID 为<code>&quot;myDiv&quot;</code>。注意，<code>div.tagName</code>实际上返回的是<code>&quot;DIV&quot;</code>而不是<code>&quot;div&quot;</code>。在 HTML 中，元素标签名始终以全大写表示；在 XML（包括 XHTML）中，标签名始终与源代码中的大小写一致。如果不确定脚本是在 HTML 文档还是 XML 文档中运行，最好将标签名转换为小写形式，以便于比较：</p> <div class="language- extra-class"><pre class="language-text"><code>if (element.tagName == &quot;div&quot;){ // 不要这样做，可能出错！
  // do something here
}

if (element.tagName.toLowerCase() == &quot;div&quot;){ // 推荐，适用于所有文档
  // 做点什么
}
</code></pre></div><p>这个例子演示了比较<code>tagName</code>属性的情形。第一个是容易出错的写法，因为 HTML 文档中<code>tagName</code>返回大写形式的标签名。第二个先把标签名转换为全部小写后再比较，这是推荐的做法，因为这对 HTML 和 XML 都适用。</p> <ol><li><p><strong>HTML 元素</strong></p> <p>所有 HTML 元素都通过<code>HTMLElement</code>类型表示，包括其直接实例和间接实例。另外，<code>HTMLElement</code>直接继承<code>Element</code>并增加了一些属性。每个属性都对应下列属性之一，它们是所有 HTML 元素上都有的标准属性：</p> <ul><li><code>id</code>，元素在文档中的唯一标识符；</li> <li><code>title</code>，包含元素的额外信息，通常以提示条形式展示；</li> <li><code>lang</code>，元素内容的语言代码（很少用）；</li> <li><code>dir</code>，语言的书写方向（<code>&quot;ltr&quot;</code>表示从左到右，<code>&quot;rtl&quot;</code>表示从右到左，同样很少用）；</li> <li><code>className</code>，相当于<code>class</code>属性，用于指定元素的 CSS 类（因为<code>class</code>是 ECMAScript 关键字，所以不能直接用这个名字）。</li></ul> <p>所有这些都可以用来获取对应的属性值，也可以用来修改相应的值。比如有下面的 HTML 元素：</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;div id=&quot;myDiv&quot; class=&quot;bd&quot; title=&quot;Body text&quot; lang=&quot;en&quot; dir=&quot;ltr&quot;&gt;&lt;/div&gt;
</code></pre></div><p>这个元素中的所有属性都可以使用下列 JavaScript 代码读取：</p> <div class="language- extra-class"><pre class="language-text"><code>let div = document.getElementById(&quot;myDiv&quot;);
alert(div.id);         // &quot;myDiv&quot;
alert(div.className);  // &quot;bd&quot;
alert(div.title);      // &quot;Body text&quot;
alert(div.lang);       // &quot;en&quot;
alert(div.dir);        // &quot;ltr&quot;
</code></pre></div><p>而且，可以使用下列代码修改元素的属性：</p> <div class="language- extra-class"><pre class="language-text"><code>div.id = &quot;someOtherId&quot;;
div.className = &quot;ft&quot;;
div.title = &quot;Some other text&quot;;
div.lang = &quot;fr&quot;;
div.dir =&quot;rtl&quot;;
</code></pre></div><p>并非所有这些属性的修改都会对页面产生影响。比如，把<code>id</code>或<code>lang</code>改成其他值对用户是不可见的（假设没有基于这两个属性应用 CSS 样式），而修改<code>title</code>属性则只会在鼠标移到这个元素上时才会反映出来。修改<code>dir</code>会导致页面文本立即向左或向右对齐。修改<code>className</code>会立即反映应用到新类名的 CSS 样式（如果定义了不同的样式）。</p> <p>如前所述，所有 HTML 元素都是<code>HTMLElement</code>或其子类型的实例。下表列出了所有 HTML 元素及其对应的类型（斜体表示已经废弃的元素）。</p> <table><thead><tr><th style="text-align:left;">元素</th> <th style="text-align:left;">类型</th> <th style="text-align:left;">元素</th> <th style="text-align:left;">类型</th></tr></thead> <tbody><tr><td style="text-align:left;">A</td> <td style="text-align:left;"><code>HTMLAnchorElement</code></td> <td style="text-align:left;">COL</td> <td style="text-align:left;"><code>HTMLTableColElement</code></td></tr> <tr><td style="text-align:left;">ABBR</td> <td style="text-align:left;"><code>HTMLElement</code></td> <td style="text-align:left;">COLGROUP</td> <td style="text-align:left;"><code>HTMLTableColElement</code></td></tr> <tr><td style="text-align:left;">ACRONYM</td> <td style="text-align:left;"><code>HTMLElement</code></td> <td style="text-align:left;">DD</td> <td style="text-align:left;"><code>HTMLElement</code></td></tr> <tr><td style="text-align:left;">ADDRESS</td> <td style="text-align:left;"><code>HTMLElement</code></td> <td style="text-align:left;">DEL</td> <td style="text-align:left;"><code>HTMLModElement</code></td></tr> <tr><td style="text-align:left;"><em>APPLET</em></td> <td style="text-align:left;"><code>*HTMLAppletElement*</code></td> <td style="text-align:left;">DFN</td> <td style="text-align:left;"><code>HTMLElement</code></td></tr> <tr><td style="text-align:left;">AREA</td> <td style="text-align:left;"><code>HTMLAreaElement</code></td> <td style="text-align:left;"><em>DIR</em></td> <td style="text-align:left;"><code>*HTMLDirectoryElement*</code></td></tr> <tr><td style="text-align:left;">B</td> <td style="text-align:left;"><code>HTMLElement</code></td> <td style="text-align:left;">DIV</td> <td style="text-align:left;"><code>HTMLDivElement</code></td></tr> <tr><td style="text-align:left;">BASE</td> <td style="text-align:left;"><code>HTMLBaseElement</code></td> <td style="text-align:left;">DL</td> <td style="text-align:left;"><code>HTMLDListElement</code></td></tr> <tr><td style="text-align:left;"><em>BASEFONT</em></td> <td style="text-align:left;"><code>*HTMLBaseFontElement*</code></td> <td style="text-align:left;">DT</td> <td style="text-align:left;"><code>HTMLElement</code></td></tr> <tr><td style="text-align:left;">BDO</td> <td style="text-align:left;"><code>HTMLElement</code></td> <td style="text-align:left;">EM</td> <td style="text-align:left;"><code>HTMLElement</code></td></tr> <tr><td style="text-align:left;">BIG</td> <td style="text-align:left;"><code>HTMLElement</code></td> <td style="text-align:left;">FIELDSET</td> <td style="text-align:left;"><code>HTMLFieldSetElement</code></td></tr> <tr><td style="text-align:left;">BLOCKQUOTE</td> <td style="text-align:left;"><code>HTMLQuoteElement</code></td> <td style="text-align:left;"><em>FONT</em></td> <td style="text-align:left;"><code>*HTMLFontElement*</code></td></tr> <tr><td style="text-align:left;">BODY</td> <td style="text-align:left;"><code>HTMLBodyElement</code></td> <td style="text-align:left;">FORM</td> <td style="text-align:left;"><code>HTMLFormElement</code></td></tr> <tr><td style="text-align:left;">BR</td> <td style="text-align:left;"><code>HTMLBRElement</code></td> <td style="text-align:left;">FRAME</td> <td style="text-align:left;"><code>HTMLFrameElement</code></td></tr> <tr><td style="text-align:left;">BUTTON</td> <td style="text-align:left;"><code>HTMLButtonElement</code></td> <td style="text-align:left;">FRAMESET</td> <td style="text-align:left;"><code>HTMLFrameSetElement</code></td></tr> <tr><td style="text-align:left;">CAPTION</td> <td style="text-align:left;"><code>HTMLTableCaption Element</code></td> <td style="text-align:left;">H1</td> <td style="text-align:left;"><code>HTMLHeadingElement</code></td></tr> <tr><td style="text-align:left;"><em>CENTER</em></td> <td style="text-align:left;"><code>*HTMLElement*</code></td> <td style="text-align:left;">H2</td> <td style="text-align:left;"><code>HTMLHeadingElement</code></td></tr> <tr><td style="text-align:left;">CITE</td> <td style="text-align:left;"><code>HTMLElement</code></td> <td style="text-align:left;">H3</td> <td style="text-align:left;"><code>HTMLHeadingElement</code></td></tr> <tr><td style="text-align:left;">CODE</td> <td style="text-align:left;"><code>HTMLElement</code></td> <td style="text-align:left;">H4</td> <td style="text-align:left;"><code>HTMLHeadingElement</code></td></tr> <tr><td style="text-align:left;">H5</td> <td style="text-align:left;"><code>HTMLHeadingElement</code></td> <td style="text-align:left;">PRE</td> <td style="text-align:left;"><code>HTMLPreElement</code></td></tr> <tr><td style="text-align:left;">H6</td> <td style="text-align:left;"><code>HTMLHeadingElement</code></td> <td style="text-align:left;">Q</td> <td style="text-align:left;"><code>HTMLQuoteElement</code></td></tr> <tr><td style="text-align:left;">HEAD</td> <td style="text-align:left;"><code>HTMLHeadElement</code></td> <td style="text-align:left;"><em>S</em></td> <td style="text-align:left;"><code>*HTMLElement*</code></td></tr> <tr><td style="text-align:left;">HR</td> <td style="text-align:left;"><code>HTMLHRElement</code></td> <td style="text-align:left;">SAMP</td> <td style="text-align:left;"><code>HTMLElement</code></td></tr> <tr><td style="text-align:left;">HTML</td> <td style="text-align:left;"><code>HTMLHtmlElement</code></td> <td style="text-align:left;">SCRIPT</td> <td style="text-align:left;"><code>HTMLScriptElement</code></td></tr> <tr><td style="text-align:left;">I</td> <td style="text-align:left;"><code>HTMLElement</code></td> <td style="text-align:left;">SELECT</td> <td style="text-align:left;"><code>HTMLSelectElement</code></td></tr> <tr><td style="text-align:left;">IFRAME</td> <td style="text-align:left;"><code>HTMLIFrameElement</code></td> <td style="text-align:left;">SMALL</td> <td style="text-align:left;"><code>HTMLElement</code></td></tr> <tr><td style="text-align:left;">IMG</td> <td style="text-align:left;"><code>HTMLImageElement</code></td> <td style="text-align:left;">SPAN</td> <td style="text-align:left;"><code>HTMLElement</code></td></tr> <tr><td style="text-align:left;">INPUT</td> <td style="text-align:left;"><code>HTMLInputElement</code></td> <td style="text-align:left;"><em>STRIKE</em></td> <td style="text-align:left;"><code>*HTMLElement*</code></td></tr> <tr><td style="text-align:left;">INS</td> <td style="text-align:left;"><code>HTMLModElement</code></td> <td style="text-align:left;">STRONG</td> <td style="text-align:left;"><code>HTMLElement</code></td></tr> <tr><td style="text-align:left;"><em>ISINDEX</em></td> <td style="text-align:left;"><code>*HTMLIsIndexElement*</code></td> <td style="text-align:left;">STYLE</td> <td style="text-align:left;"><code>HTMLStyleElement</code></td></tr> <tr><td style="text-align:left;">KBD</td> <td style="text-align:left;"><code>HTMLElement</code></td> <td style="text-align:left;">SUB</td> <td style="text-align:left;"><code>HTMLElement</code></td></tr> <tr><td style="text-align:left;">LABEL</td> <td style="text-align:left;"><code>HTMLLabelElement</code></td> <td style="text-align:left;">SUP</td> <td style="text-align:left;"><code>HTMLElement</code></td></tr> <tr><td style="text-align:left;">LEGEND</td> <td style="text-align:left;"><code>HTMLLegendElement</code></td> <td style="text-align:left;">TABLE</td> <td style="text-align:left;"><code>HTMLTableElement</code></td></tr> <tr><td style="text-align:left;">LI</td> <td style="text-align:left;"><code>HTMLLIElement</code></td> <td style="text-align:left;">TBODY</td> <td style="text-align:left;"><code>HTMLTableSectionElement</code></td></tr> <tr><td style="text-align:left;">LINK</td> <td style="text-align:left;"><code>HTMLLinkElement</code></td> <td style="text-align:left;">TD</td> <td style="text-align:left;"><code>HTMLTableCellElement</code></td></tr> <tr><td style="text-align:left;">MAP</td> <td style="text-align:left;"><code>HTMLMapElement</code></td> <td style="text-align:left;">TEXTAREA</td> <td style="text-align:left;"><code>HTMLTextAreaElement</code></td></tr> <tr><td style="text-align:left;"><em>MENU</em></td> <td style="text-align:left;"><code>*HTMLMenuElement*</code></td> <td style="text-align:left;">TFOOT</td> <td style="text-align:left;"><code>HTMLTableSectionElement</code></td></tr> <tr><td style="text-align:left;">META</td> <td style="text-align:left;"><code>HTMLMetaElement</code></td> <td style="text-align:left;">TH</td> <td style="text-align:left;"><code>HTMLTableCellElement</code></td></tr> <tr><td style="text-align:left;">NOFRAMES</td> <td style="text-align:left;"><code>HTMLElement</code></td> <td style="text-align:left;">THEAD</td> <td style="text-align:left;"><code>HTMLTableSectionElement</code></td></tr> <tr><td style="text-align:left;">NOSCRIPT</td> <td style="text-align:left;"><code>HTMLElement</code></td> <td style="text-align:left;">TITLE</td> <td style="text-align:left;"><code>HTMLTitleElement</code></td></tr> <tr><td style="text-align:left;">OBJECT</td> <td style="text-align:left;"><code>HTMLObjectElement</code></td> <td style="text-align:left;">TR</td> <td style="text-align:left;"><code>HTMLTableRowElement</code></td></tr> <tr><td style="text-align:left;">OL</td> <td style="text-align:left;"><code>HTMLOListElement</code></td> <td style="text-align:left;">TT</td> <td style="text-align:left;"><code>HTMLElement</code></td></tr> <tr><td style="text-align:left;">OPTGROUP</td> <td style="text-align:left;"><code>HTMLOptGroupElement</code></td> <td style="text-align:left;"><em>U</em></td> <td style="text-align:left;"><code>*HTMLElement*</code></td></tr> <tr><td style="text-align:left;">OPTION</td> <td style="text-align:left;"><code>HTMLOptionElement</code></td> <td style="text-align:left;">UL</td> <td style="text-align:left;"><code>HTMLUListElement</code></td></tr> <tr><td style="text-align:left;">P</td> <td style="text-align:left;"><code>HTMLParagraphElement</code></td> <td style="text-align:left;">VAR</td> <td style="text-align:left;"><code>HTMLElement</code></td></tr> <tr><td style="text-align:left;">PARAM</td> <td style="text-align:left;"><code>HTMLParamElement</code></td> <td style="text-align:left;"></td> <td style="text-align:left;"></td></tr></tbody></table> <p>这里列出的每种类型都有关联的属性和方法。本书会涉及其中的很多类型。</p></li></ol> <ol start="2"><li><p><strong>取得属性</strong></p> <p>每个元素都有零个或多个属性，通常用于为元素或其内容附加更多信息。与属性相关的 DOM 方法主要有 3 个：<code>getAttribute()</code>、<code>setAttribute()</code>和<code>removeAttribute()</code>。这些方法主要用于操纵属性，包括在<code>HTMLElement</code>类型上定义的属性。下面看一个例子：</p> <div class="language- extra-class"><pre class="language-text"><code>let div = document.getElementById(&quot;myDiv&quot;);
alert(div.getAttribute(&quot;id&quot;));     // &quot;myDiv&quot;
alert(div.getAttribute(&quot;class&quot;));  // &quot;bd&quot;
alert(div.getAttribute(&quot;title&quot;));  // &quot;Body text&quot;
alert(div.getAttribute(&quot;lang&quot;));   // &quot;en&quot;
alert(div.getAttribute(&quot;dir&quot;));    // &quot;ltr&quot;
</code></pre></div><p>注意传给<code>getAttribute()</code>的属性名与它们实际的属性名是一样的，因此这里要传<code>&quot;class&quot;</code>而非<code>&quot;className&quot;</code>（<code>className</code>是作为对象属性时才那么拼写的）。如果给定的属性不存在，则<code>getAttribute()</code>返回<code>null</code>。</p> <p><code>getAttribute()</code>方法也能取得不是 HTML 语言正式属性的自定义属性的值。比如下面的元素：</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;div id=&quot;myDiv&quot; my_special_attribute=&quot;hello!&quot;&gt;&lt;/div&gt;
</code></pre></div><p>这个元素有一个自定义属性<code>my_special_attribute</code>，值为<code>&quot;hello!&quot;</code>。可以像其他属性一样使用<code>getAttribute()</code>取得这个属性的值：</p> <div class="language- extra-class"><pre class="language-text"><code>let value = div.getAttribute(&quot;my_special_attribute&quot;);
</code></pre></div><p>注意，属性名不区分大小写，因此<code>&quot;ID&quot;</code>和<code>&quot;id&quot;</code>被认为是同一个属性。另外，根据 HTML5 规范的要求，自定义属性名应该前缀<code>data-</code>以方便验证。</p> <p>元素的所有属性也可以通过相应 DOM 元素对象的属性来取得。当然，这包括<code>HTMLElement</code>上定义的直接映射对应属性的 5 个属性，还有所有公认（非自定义）的属性也会被添加为 DOM 对象的属性。比如下面的例子：</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;div id=&quot;myDiv&quot; align=&quot;left&quot; my_special_attribute=&quot;hello&quot;&gt;&lt;/div&gt;
</code></pre></div><p>因为<code>id</code>和<code>align</code>在 HTML 中是<code>&lt;div&gt;</code>元素公认的属性，所以 DOM 对象上也会有这两个属性。但<code>my_special_attribute</code>是自定义属性，因此不会成为 DOM 对象的属性。</p> <p>通过 DOM 对象访问的属性中有两个返回的值跟使用<code>getAttribute</code>()取得的值不一样。首先是<code>style</code>属性，这个属性用于为元素设定 CSS 样式。在使用<code>getAttribute()</code>访问 style 属性时，返回的是 CSS 字符串。而在通过 DOM 对象的属性访问时，<code>style</code>属性返回的是一个（<code>CSSStyleDeclaration</code>）对象。DOM 对象的<code>style</code>属性用于以编程方式读写元素样式，因此不会直接映射为元素中<code>style</code>属性的字符串值。</p> <p>第二个属性其实是一类，即事件处理程序（或者事件属性），比如<code>onclick</code>。在元素上使用事件属性时（比如<code>onclick</code>），属性的值是一段 JavaScript 代码。如果使用<code>getAttribute()</code>访问事件属性，则返回的是字符串形式的源代码。而通过 DOM 对象的属性访问事件属性时返回的则是一个 JavaScript 函数（未指定该属性则返回<code>null</code>）。这是因为<code>onclick</code>及其他事件属性是可以接受函数作为值的。</p> <p>考虑到以上差异，开发者在进行 DOM 编程时通常会放弃使用<code>getAttribute()</code>而只使用对象属性。<code>getAttribute()</code>主要用于取得自定义属性的值。</p></li></ol> <ol start="3"><li><p><strong>设置属性</strong></p> <p>与<code>getAttribute()</code>配套的方法是<code>setAttribute()</code>，这个方法接收两个参数：要设置的属性名和属性的值。如果属性已经存在，则<code>setAttribute()</code>会以指定的值替换原来的值；如果属性不存在，则<code>setAttribute()</code>会以指定的值创建该属性。下面看一个例子：</p> <div class="language- extra-class"><pre class="language-text"><code>div.setAttribute(&quot;id&quot;, &quot;someOtherId&quot;);
div.setAttribute(&quot;class&quot;, &quot;ft&quot;);
div.setAttribute(&quot;title&quot;, &quot;Some other text&quot;);
div.setAttribute(&quot;lang&quot;,&quot;fr&quot;);
div.setAttribute(&quot;dir&quot;, &quot;rtl&quot;);
</code></pre></div><p><code>setAttribute()</code>适用于 HTML 属性，也适用于自定义属性。另外，使用<code>setAttribute()</code>方法设置的属性名会规范为小写形式，因此<code>&quot;ID&quot;</code>会变成<code>&quot;id&quot;</code>。</p> <p>因为元素属性也是 DOM 对象属性，所以直接给 DOM 对象的属性赋值也可以设置元素属性的值，如下所示：</p> <div class="language- extra-class"><pre class="language-text"><code>div.id = &quot;someOtherId&quot;;
div.align = &quot;left&quot;;
</code></pre></div><p>注意，在 DOM 对象上添加自定义属性，如下面的例子所示，不会自动让它变成元素的属性：</p> <div class="language- extra-class"><pre class="language-text"><code>div.mycolor = &quot;red&quot;;
alert(div.getAttribute(&quot;mycolor&quot;)); // null（IE除外）
</code></pre></div><p>这个例子添加了一个自定义属性<code>mycolor</code>并将其值设置为<code>&quot;red&quot;</code>。在多数浏览器中，这个属性不会自动变成元素属性。因此调用<code>getAttribute()</code>取得<code>mycolor</code>的值会返回<code>null</code>。</p> <p>最后一个方法<code>removeAttribute()</code>用于从元素中删除属性。这样不单单是清除属性的值，而是会把整个属性完全从元素中去掉，如下所示：</p> <div class="language- extra-class"><pre class="language-text"><code>div.removeAttribute(&quot;class&quot;);
</code></pre></div><p>这个方法用得并不多，但在序列化 DOM 元素时可以通过它控制要包含的属性。</p></li></ol> <ol start="4"><li><p><strong>attributes 属性</strong></p> <p><code>Element</code>类型是唯一使用<code>attributes</code>属性的 DOM 节点类型。<code>attributes</code>属性包含一个<code>NamedNodeMap</code>实例，是一个类似<code>NodeList</code>的“实时”集合。元素的每个属性都表示为一个<code>Attr</code>节点，并保存在这个<code>NamedNodeMap</code>对象中。<code>NamedNodeMap</code>对象包含下列方法：</p> <ul><li><code>getNamedItem(*name*)</code>，返回<code>nodeName</code>属性等于<code>*name*</code>的节点；</li> <li><code>removeNamedItem(*name*)</code>，删除<code>nodeName</code>属性等于<code>*name*</code>的节点；</li> <li><code>setNamedItem(*node*)</code>，向列表中添加<code>*node*</code>节点，以其<code>nodeName</code>为索引；</li> <li><code>item(*pos*)</code>，返回索引位置<code>*pos*</code>处的节点。</li></ul> <p><code>attributes</code>属性中的每个节点的<code>nodeName</code>是对应属性的名字，<code>nodeValue</code>是属性的值。比如，要取得元素<code>id</code>属性的值，可以使用以下代码：</p> <div class="language- extra-class"><pre class="language-text"><code>let id = element.attributes.getNamedItem(&quot;id&quot;).nodeValue;
</code></pre></div><p>下面是使用中括号访问属性的简写形式：</p> <div class="language- extra-class"><pre class="language-text"><code>let id = element.attributes[&quot;id&quot;].nodeValue;
</code></pre></div><p>同样，也可以用这种语法设置属性的值，即先取得属性节点，再将其<code>nodeValue</code>设置为新值，如下所示：</p> <div class="language- extra-class"><pre class="language-text"><code>element.attributes[&quot;id&quot;].nodeValue = &quot;someOtherId&quot;;
</code></pre></div><p><code>removeNamedItem()</code>方法与元素上的<code>removeAttribute()</code>方法类似，也是删除指定名字的属性。下面的例子展示了这两个方法唯一的不同之处，就是<code>removeNamedItem()</code>返回表示被删除属性的<code>Attr</code>节点：</p> <div class="language- extra-class"><pre class="language-text"><code>let oldAttr = element.attributes.removeNamedItem(&quot;id&quot;);
</code></pre></div><p><code>setNamedItem()</code>方法很少使用，它接收一个属性节点，然后给元素添加一个新属性，如下所示：</p> <div class="language- extra-class"><pre class="language-text"><code>element.attributes.setNamedItem(newAttr);
</code></pre></div><p>一般来说，因为使用起来更简便，通常开发者更喜欢使用<code>getAttribute()</code>、<code>removeAttribute()</code>和<code>setAttribute()</code>方法，而不是刚刚介绍的<code>NamedNodeMap</code>对象的方法。</p> <p><code>attributes</code>属性最有用的场景是需要迭代元素上所有属性的时候。这时候往往是要把 DOM 结构序列化为 XML 或 HTML 字符串。比如，以下代码能够迭代一个元素上的所有属性并以<code>attribute1= &quot;value1&quot; attribute2=&quot;value2&quot;</code>的形式生成格式化字符串：</p> <div class="language- extra-class"><pre class="language-text"><code>function outputAttributes(element) {
  let pairs = [];

  for (let i = 0, len = element.attributes.length; i &lt; len; ++i) {
    const attribute = element.attributes[i];
    pairs.push(`${attribute.nodeName}=&quot;${attribute.nodeValue}&quot;`);
  }

  return pairs.join(&quot; &quot;);
}
</code></pre></div><p>这个函数使用数组存储每个名/值对，迭代完所有属性后，再将这些名/值对用空格拼接在一起。（这个技术常用于序列化为长字符串。）这个函数中的<code>for</code>循环使用<code>attributes.length</code>属性迭代每个属性，将每个属性的名字和值输出为字符串。不同浏览器返回的<code>attributes</code>中的属性顺序也可能不一样。HTML 或 XML 代码中属性出现的顺序不一定与<code>attributes</code>中的顺序一致。</p></li></ol> <ol start="5"><li><p><strong>创建元素</strong></p> <p>可以使用<code>document.createElement()</code>方法创建新元素。这个方法接收一个参数，即要创建元素的标签名。在 HTML 文档中，标签名是不区分大小写的，而 XML 文档（包括 XHTML）是区分大小写的。要创建<code>&lt;div&gt;</code>元素，可以使用下面的代码：</p> <div class="language- extra-class"><pre class="language-text"><code>let div = document.createElement(&quot;div&quot;);
</code></pre></div><p>使用<code>createElement()</code>方法创建新元素的同时也会将其<code>ownerDocument</code>属性设置为<code>document</code>。此时，可以再为其添加属性、添加更多子元素。比如：</p> <div class="language- extra-class"><pre class="language-text"><code>div.id = &quot;myNewDiv&quot;;
div.className = &quot;box&quot;;
</code></pre></div><p>在新元素上设置这些属性只会附加信息。因为这个元素还没有添加到文档树，所以不会影响浏览器显示。要把元素添加到文档树，可以使用<code>appendChild()</code>、<code>insertBefore()</code>或<code>replaceChild()</code>。比如，以下代码会把刚才创建的元素添加到文档的<code>&lt;body&gt;</code>元素中：</p> <div class="language- extra-class"><pre class="language-text"><code>document.body.appendChild(div);
</code></pre></div><p>元素被添加到文档树之后，浏览器会立即将其渲染出来。之后再对这个元素所做的任何修改，都会立即在浏览器中反映出来。</p></li></ol> <ol start="6"><li><p><strong>元素后代</strong></p> <p>元素可以拥有任意多个子元素和后代元素，因为元素本身也可以是其他元素的子元素。<code>childNodes</code>属性包含元素所有的子节点，这些子节点可能是其他元素、文本节点、注释或处理指令。不同浏览器在识别这些节点时的表现有明显不同。比如下面的代码：</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;ul id=&quot;myList&quot;&gt;
  &lt;li&gt;Item 1&lt;/li&gt;
  &lt;li&gt;Item 2&lt;/li&gt;
  &lt;li&gt;Item 3&lt;/li&gt;
&lt;/ul&gt;
</code></pre></div><p>在解析以上代码时，<code>&lt;ul&gt;</code>元素会包含 7 个子元素，其中 3 个是<code>&lt;li&gt;</code>元素，还有 4 个<code>Text</code>节点（表示<code>&lt;li&gt;</code>元素周围的空格）。如果把元素之间的空格删掉，变成下面这样，则所有浏览器都会返回同样数量的子节点：</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;ul id=&quot;myList&quot;&gt;&lt;li&gt;Item 1&lt;/li&gt;&lt;li&gt;Item 2&lt;/li&gt;&lt;li&gt;Item 3&lt;/li&gt;&lt;/ul&gt;
</code></pre></div><p>所有浏览器解析上面的代码后，<code>&lt;ul&gt;</code>元素都会包含 3 个子节点。考虑到这种情况，通常在执行某个操作之后需要先检测一下节点的<code>nodeType</code>，如下所示：</p> <div class="language- extra-class"><pre class="language-text"><code>for (let i = 0, len = element.childNodes.length; i &lt; len; ++i) {
  if (element.childNodes[i].nodeType == 1) {
    // 执行某个操作
  }
}
</code></pre></div><p>以上代码会遍历某个元素的子节点，并且只在<code>nodeType</code>等于 1（即<code>Element</code>节点）时执行某个操作。</p> <p>要取得某个元素的子节点和其他后代节点，可以使用元素的<code>getElementsByTagName()</code>方法。在元素上调用这个方法与在文档上调用是一样的，只不过搜索范围限制在当前元素之内，即只会返回当前元素的后代。对于本节前面<code>&lt;ul&gt;</code>的例子，可以像下面这样取得其所有的<code>&lt;li&gt;</code>元素：</p> <div class="language- extra-class"><pre class="language-text"><code>let ul = document.getElementById(&quot;myList&quot;);
let items = ul.getElementsByTagName(&quot;li&quot;);
</code></pre></div><p>这里例子中的<code>&lt;ul&gt;</code>元素只有一级子节点，如果它包含更多层级，则所有层级中的<code>&lt;li&gt;</code>元素都会返回。</p></li></ol> <h3 id="_14-1-4-text类型"><a href="#_14-1-4-text类型" class="header-anchor">#</a> 14.1.4 　<code>Text</code>类型</h3> <p><code>Text</code>节点由<code>Text</code>类型表示，包含按字面解释的纯文本，也可能包含转义后的 HTML 字符，但不含 HTML 代码。<code>Text</code>类型的节点具有以下特征：</p> <ul><li><code>nodeType</code>等于 3；</li> <li><code>nodeName</code>值为<code>&quot;#text&quot;</code>；</li> <li><code>nodeValue</code>值为节点中包含的文本；</li> <li><code>parentNode</code>值为<code>Element</code>对象；</li> <li>不支持子节点。</li></ul> <p><code>Text</code>节点中包含的文本可以通过<code>nodeValue</code>属性访问，也可以通过<code>data</code>属性访问，这两个属性包含相同的值。修改<code>nodeValue</code>或<code>data</code>的值，也会在另一个属性反映出来。文本节点暴露了以下操作文本的方法：</p> <ul><li><code>appendData(*text*)</code>，向节点末尾添加文本<code>*text*</code>；</li> <li><code>deleteData(*offset, count*)</code>，从位置<code>*offset*</code>开始删除<code>*count*</code>个字符；</li> <li><code>insertData(*offset, text*)</code>，在位置<code>*offset*</code>插入<code>*text*</code>；</li> <li><code>replaceData(*offset, count, text*)</code>，用<code>*text*</code>替换从位置<code>*offset*</code>到<code>*offset* + *count*</code>的文本；</li> <li><code>splitText(*offset*)</code>，在位置<code>*offset*</code>将当前文本节点拆分为两个文本节点；</li> <li><code>substringData(*offset, count*)</code>，提取从位置<code>*offset*</code>到<code>*offset* + *count*</code>的文本。</li></ul> <p>除了这些方法，还可以通过<code>length</code>属性获取文本节点中包含的字符数量。这个值等于<code>nodeValue.length</code>和<code>data.length</code>。</p> <p>默认情况下，包含文本内容的每个元素最多只能有一个文本节点。例如：</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;!-- 没有内容，因此没有文本节点 --&gt;
&lt;div&gt;&lt;/div&gt;

&lt;!-- 有空格，因此有一个文本节点 --&gt;
&lt;div&gt;&lt;/div&gt;

&lt;!-- 有内容，因此有一个文本节点 --&gt;
&lt;div&gt;Hello World!&lt;/div&gt;
</code></pre></div><p>示例中的第一个<code>&lt;div&gt;</code>元素中不包含内容，因此不会产生文本节点。只要开始标签和结束标签之间有内容，就会创建一个文本节点，因此第二个<code>&lt;div&gt;</code>元素会有一个文本节点的子节点，虽然它只包含空格。这个文本节点的<code>nodeValue</code>就是一个空格。第三个<code>&lt;div&gt;</code>元素也有一个文本节点的子节点，其<code>nodeValue</code>的值为<code>&quot;Hello World!&quot;</code>。下列代码可以用来访问这个文本节点：</p> <div class="language- extra-class"><pre class="language-text"><code>let textNode = div.firstChild; // 或div.childNodes[0]
</code></pre></div><p>取得文本节点的引用后，可以像这样来修改它：</p> <div class="language- extra-class"><pre class="language-text"><code>div.firstChild.nodeValue = &quot;Some other message&quot;;
</code></pre></div><p>只要节点在当前的文档树中，这样的修改就会马上反映出来。修改文本节点还有一点要注意，就是 HTML 或 XML 代码（取决于文档类型）会被转换成实体编码，即小于号、大于号或引号会被转义，如下所示：</p> <div class="language- extra-class"><pre class="language-text"><code>// 输出为&quot;Some &amp;lt;strong&amp;gt;other&amp;lt;/strong&amp;gt; message&quot;
div.firstChild.nodeValue = &quot;Some &lt;strong&gt;other&lt;/strong&gt; message&quot;;
</code></pre></div><p>这实际上是在将 HTML 字符串插入 DOM 文档前进行编码的有效方式。</p> <ol><li><p><strong>创建文本节点</strong></p> <p><code>document.createTextNode()</code>可以用来创建新文本节点，它接收一个参数，即要插入节点的文本。跟设置已有文本节点的值一样，这些要插入的文本也会应用 HTML 或 XML 编码，如下面的例子所示：</p> <div class="language- extra-class"><pre class="language-text"><code>let textNode = document.createTextNode(&quot;&lt;strong&gt;Hello&lt;/strong&gt; world!&quot;);
</code></pre></div><p>创建新文本节点后，其<code>ownerDocument</code>属性会被设置为<code>document</code>。但在把这个节点添加到文档树之前，我们不会在浏览器中看到它。以下代码创建了一个<code>&lt;div&gt;</code>元素并给它添加了一段文本消息：</p> <div class="language- extra-class"><pre class="language-text"><code>let element = document.createElement(&quot;div&quot;);
element.className = &quot;message&quot;;

let textNode = document.createTextNode(&quot;Hello world!&quot;);
element.appendChild(textNode);

document.body.appendChild(element);
</code></pre></div><p>这个例子首先创建了一个<code>&lt;div&gt;</code>元素并给它添加了值为<code>&quot;message&quot;</code>的<code>class</code>属性，然后又创建了一个文本节点并添加到该元素。最后一步是把这个元素添加到文档的主体上，这样元素及其包含的文本会出现在浏览器中。</p> <p>一般来说一个元素只包含一个文本子节点。不过，也可以让元素包含多个文本子节点，如下面的例子所示：</p> <div class="language- extra-class"><pre class="language-text"><code>let element = document.createElement(&quot;div&quot;);
element.className = &quot;message&quot;;

let textNode = document.createTextNode(&quot;Hello world!&quot;);
element.appendChild(textNode);

let anotherTextNode = document.createTextNode(&quot;Yippee!&quot;);
element.appendChild(anotherTextNode);

document.body.appendChild(element);
</code></pre></div><p>在将一个文本节点作为另一个文本节点的同胞插入后，两个文本节点的文本之间不会包含空格。</p></li></ol> <ol start="2"><li><p><strong>规范化文本节点</strong></p> <p>DOM 文档中的同胞文本节点可能导致困惑，因为一个文本节点足以表示一个文本字符串。同样，DOM 文档中也经常会出现两个相邻文本节点。为此，有一个方法可以合并相邻的文本节点。这个方法叫<code>normalize()</code>，是在<code>Node</code>类型中定义的（因此所有类型的节点上都有这个方法）。在包含两个或多个相邻文本节点的父节点上调用<code>normalize()</code>时，所有同胞文本节点会被合并为一个文本节点，这个文本节点的<code>nodeValue</code>就等于之前所有同胞节点<code>nodeValue</code>拼接在一起得到的字符串。来看下面的例子：</p> <div class="language- extra-class"><pre class="language-text"><code>let element = document.createElement(&quot;div&quot;);
element.className = &quot;message&quot;;

let textNode = document.createTextNode(&quot;Hello world!&quot;);
element.appendChild(textNode);

let anotherTextNode = document.createTextNode(&quot;Yippee!&quot;);
element.appendChild(anotherTextNode);

document.body.appendChild(element);

alert(element.childNodes.length);    // 2

element.normalize();
alert(element.childNodes.length);    // 1
alert(element.firstChild.nodeValue); // &quot;Hello world!Yippee!&quot;
</code></pre></div><p>浏览器在解析文档时，永远不会创建同胞文本节点。同胞文本节点只会出现在 DOM 脚本生成的文档树中。</p></li></ol> <ol start="3"><li><p><strong>拆分文本节点</strong></p> <p><code>Text</code>类型定义了一个与<code>normalize()</code>相反的方法——<code>splitText()</code>。这个方法可以在指定的偏移位置拆分<code>nodeValue</code>，将一个文本节点拆分成两个文本节点。拆分之后，原来的文本节点包含开头到偏移位置前的文本，新文本节点包含剩下的文本。这个方法返回新的文本节点，具有与原来的文本节点相同的<code>parentNode</code>。来看下面的例子：</p> <div class="language- extra-class"><pre class="language-text"><code>let element = document.createElement(&quot;div&quot;);
element.className = &quot;message&quot;;

let textNode = document.createTextNode(&quot;Hello world!&quot;);
element.appendChild(textNode);

document.body.appendChild(element);

let newNode = element.firstChild.splitText(5);
alert(element.firstChild.nodeValue);  // &quot;Hello&quot;
alert(newNode.nodeValue);             // &quot; world!&quot;
alert(element.childNodes.length);     // 2
</code></pre></div><p>在这个例子中，包含<code>&quot;Hello world!&quot;</code>的文本节点被从位置<code>5</code>拆分成两个文本节点。位置<code>5</code>对应<code>&quot;Hello&quot;</code>和<code>&quot;world!&quot;</code>之间的空格，因此原始文本节点包含字符串<code>&quot;Hello&quot;</code>，而新文本节点包含文本<code>&quot; world!&quot;</code>（包含空格）。</p> <p>拆分文本节点最常用于从文本节点中提取数据的 DOM 解析技术。</p></li></ol> <h3 id="_14-1-5-comment类型"><a href="#_14-1-5-comment类型" class="header-anchor">#</a> 14.1.5 　<code>Comment</code>类型</h3> <p>DOM 中的注释通过<code>Comment</code>类型表示。<code>Comment</code>类型的节点具有以下特征：</p> <ul><li><code>nodeType</code>等于 8；</li> <li><code>nodeName</code>值为<code>&quot;#comment&quot;</code>；</li> <li><code>nodeValue</code>值为注释的内容；</li> <li><code>parentNode</code>值为<code>Document</code>或<code>Element</code>对象；</li> <li>不支持子节点。</li></ul> <p><code>Comment</code>类型与<code>Text</code>类型继承同一个基类（<code>CharacterData</code>），因此拥有除<code>splitText()</code>之外<code>Text</code>节点所有的字符串操作方法。与<code>Text</code>类型相似，注释的实际内容可以通过<code>nodeValue</code>或<code>data</code>属性获得。</p> <p>注释节点可以作为父节点的子节点来访问。比如下面的 HTML 代码：</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;div id=&quot;myDiv&quot;&gt;&lt;!-- A comment --&gt;&lt;/div&gt;
</code></pre></div><p>这里的注释是<code>&lt;div&gt;</code>元素的子节点，这意味着可以像下面这样访问它：</p> <div class="language- extra-class"><pre class="language-text"><code>let div = document.getElementById(&quot;myDiv&quot;);
let comment = div.firstChild;
alert(comment.data); // &quot;A comment&quot;
</code></pre></div><p>可以使用<code>document.createComment()</code>方法创建注释节点，参数为注释文本，如下所示：</p> <div class="language- extra-class"><pre class="language-text"><code>let comment = document.createComment(&quot;A comment&quot;);
</code></pre></div><p>显然，注释节点很少通过 JavaScrpit 创建和访问，因为注释几乎不涉及算法逻辑。此外，浏览器不承认结束的<code>&lt;/html&gt;</code>标签之后的注释。如果要访问注释节点，则必须确定它们是<code>&lt;html&gt;</code>元素的后代。</p> <h3 id="_14-1-6-cdatasection类型"><a href="#_14-1-6-cdatasection类型" class="header-anchor">#</a> 14.1.6 　<code>CDATASection</code>类型</h3> <p><code>CDATASection</code>类型表示 XML 中特有的 CDATA 区块。<code>CDATASection</code>类型继承<code>Text</code>类型，因此拥有包括<code>splitText()</code>在内的所有字符串操作方法。<code>CDATASection</code>类型的节点具有以下特征：</p> <ul><li><code>nodeType</code>等于 4；</li> <li><code>nodeName</code>值为<code>&quot;#cdata-section&quot;</code>；</li> <li><code>nodeValue</code>值为 CDATA 区块的内容；</li> <li><code>parentNode</code>值为<code>Document</code>或<code>Element</code>对象；</li> <li>不支持子节点。</li></ul> <p>CDATA 区块只在 XML 文档中有效，因此某些浏览器比较陈旧的版本会错误地将 CDATA 区块解析为<code>Comment</code>或<code>Element</code>。比如下面这行代码：</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;div id=&quot;myDiv&quot;&gt;&lt;![CDATA[This is some content.]]&gt;&lt;/div&gt;
</code></pre></div><p>这里<code>&lt;div&gt;</code>的第一个子节点应该是<code>CDATASection</code>节点。但主流的四大浏览器没有一个将其识别为<code>CDATASection</code>。即使在有效的 XHTML 文档中，这些浏览器也不能恰当地支持嵌入的 CDATA 区块。</p> <p>在真正的 XML 文档中，可以使用<code>document.createCDataSection()</code>并传入节点内容来创建 CDATA 区块。</p> <h3 id="_14-1-7-documenttype类型"><a href="#_14-1-7-documenttype类型" class="header-anchor">#</a> 14.1.7 　<code>DocumentType</code>类型</h3> <p><code>DocumentType</code>类型的节点包含文档的文档类型（<code>doctype</code>）信息，具有以下特征：</p> <ul><li><code>nodeType</code>等于 10；</li> <li><code>nodeName</code>值为文档类型的名称；</li> <li><code>nodeValue</code>值为<code>null</code>；</li> <li><code>parentNode</code>值为<code>Document</code>对象；</li> <li>不支持子节点。</li></ul> <p><code>DocumentType</code>对象在 DOM Level 1 中不支持动态创建，只能在解析文档代码时创建。对于支持这个类型的浏览器，<code>DocumentType</code>对象保存在<code>document.doctype</code>属性中。DOM Level 1 规定了<code>DocumentType</code>对象的 3 个属性：<code>name</code>、<code>entities</code>和<code>notations</code>。其中，<code>name</code>是文档类型的名称，<code>entities</code>是这个文档类型描述的实体的<code>NamedNodeMap</code>，而<code>notations</code>是这个文档类型描述的表示法的<code>NamedNodeMap</code>。因为浏览器中的文档通常是 HTML 或 XHTML 文档类型，所以<code>entities</code>和<code>notations</code>列表为空。（这个对象只包含行内声明的文档类型。）无论如何，只有<code>name</code>属性是有用的。这个属性包含文档类型的名称，即紧跟在<code>&lt;!DOCTYPE</code>后面的那串文本。比如下面的 HTML 4.01 严格文档类型：</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;!DOCTYPE HTML PUBLIC &quot;-// W3C// DTD HTML 4.01// EN&quot;
  &quot;http:// www.w3.org/TR/html4/strict.dtd&quot;&gt;
</code></pre></div><p>对于这个文档类型，<code>name</code>属性的值是<code>&quot;HTML&quot;</code>：</p> <div class="language- extra-class"><pre class="language-text"><code>alert(document.doctype.name); // &quot;HTML&quot;
</code></pre></div><h3 id="_14-1-8-documentfragment类型"><a href="#_14-1-8-documentfragment类型" class="header-anchor">#</a> 14.1.8 　<code>DocumentFragment</code>类型</h3> <p>在所有节点类型中，<code>DocumentFragment</code>类型是唯一一个在标记中没有对应表示的类型。DOM 将文档片段定义为“轻量级”文档，能够包含和操作节点，却没有完整文档那样额外的消耗。<code>DocumentFragment</code>节点具有以下特征：</p> <ul><li><code>nodeType</code>等于 11；</li> <li><code>nodeName</code>值为<code>&quot;#document-fragment&quot;</code>；</li> <li><code>nodeValue</code>值为<code>null</code>；</li> <li><code>parentNode</code>值为<code>null</code>；</li> <li>子节点可以是<code>Element</code>、<code>ProcessingInstruction</code>、<code>Comment</code>、<code>Text</code>、<code>CDATASection</code>或<code>EntityReference</code>。</li></ul> <p>不能直接把文档片段添加到文档。相反，文档片段的作用是充当其他要被添加到文档的节点的仓库。可以使用<code>document.createDocumentFragment()</code>方法像下面这样创建文档片段：</p> <div class="language- extra-class"><pre class="language-text"><code>let fragment = document.createDocumentFragment();
</code></pre></div><p>文档片段从<code>Node</code>类型继承了所有文档类型具备的可以执行 DOM 操作的方法。如果文档中的一个节点被添加到一个文档片段，则该节点会从文档树中移除，不会再被浏览器渲染。添加到文档片段的新节点同样不属于文档树，不会被浏览器渲染。可以通过<code>appendChild()</code>或<code>insertBefore()</code>方法将文档片段的内容添加到文档。在把文档片段作为参数传给这些方法时，这个文档片段的所有子节点会被添加到文档中相应的位置。文档片段本身永远不会被添加到文档树。以下面的 HTML 为例：</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;ul id=&quot;myList&quot;&gt;&lt;/ul&gt;
</code></pre></div><p>假设想给这个<code>&lt;ul&gt;</code>元素添加 3 个列表项。如果分 3 次给这个元素添加列表项，浏览器就要重新渲染 3 次页面，以反映新添加的内容。为避免多次渲染，下面的代码示例使用文档片段创建了所有列表项，然后一次性将它们添加到了<code>&lt;ul&gt;</code>元素：</p> <div class="language- extra-class"><pre class="language-text"><code>let fragment = document.createDocumentFragment();
let ul = document.getElementById(&quot;myList&quot;);

for (let i = 0; i &lt; 3; ++i) {
  let li = document.createElement(&quot;li&quot;);
  li.appendChild(document.createTextNode(`Item ${i + 1}`));
  fragment.appendChild(li);
}

ul.appendChild(fragment);
</code></pre></div><p>这个例子先创建了一个文档片段，然后取得了<code>&lt;ul&gt;</code>元素的引用。接着通过<code>for</code>循环创建了 3 个列表项，每一项都包含表明自己身份的文本。为此先创建<code>&lt;li&gt;</code>元素，再创建文本节点并添加到该元素。然后通过<code>appendChild()</code>把<code>&lt;li&gt;</code>元素添加到文档片段。循环结束后，通过把文档片段传给<code>appendChild()</code>将所有列表项添加到了<code>&lt;ul&gt;</code>元素。此时，文档片段的子节点全部被转移到了<code>&lt;ul&gt;</code>元素。</p> <h3 id="_14-1-9-attr类型"><a href="#_14-1-9-attr类型" class="header-anchor">#</a> 14.1.9 　<code>Attr</code>类型</h3> <p>元素数据在 DOM 中通过<code>Attr</code>类型表示。<code>Attr</code>类型构造函数和原型在所有浏览器中都可以直接访问。技术上讲，属性是存在于元素<code>attributes</code>属性中的节点。<code>Attr</code>节点具有以下特征：</p> <ul><li><code>nodeType</code>等于 2；</li> <li><code>nodeName</code>值为属性名；</li> <li><code>nodeValue</code>值为属性值；</li> <li><code>parentNode</code>值为<code>null</code>；</li> <li>在 HTML 中不支持子节点；</li> <li>在 XML 中子节点可以是<code>Text</code>或<code>EntityReference</code>。</li></ul> <p>属性节点尽管是节点，却不被认为是 DOM 文档树的一部分。<code>Attr</code>节点很少直接被引用，通常开发者更喜欢使用<code>getAttribute()</code>、<code>removeAttribute()</code>和<code>setAttribute()</code>方法操作属性。</p> <p><code>Attr</code>对象上有 3 个属性：<code>name</code>、<code>value</code>和<code>specified</code>。其中，<code>name</code>包含属性名（与<code>nodeName</code>一样），<code>value</code>包含属性值（与<code>nodeValue</code>一样），而<code>specified</code>是一个布尔值，表示属性使用的是默认值还是被指定的值。</p> <p>可以使用<code>document.createAttribute()</code>方法创建新的<code>Attr</code>节点，参数为属性名。比如，要给元素添加<code>align</code>属性，可以使用下列代码：</p> <div class="language- extra-class"><pre class="language-text"><code>let attr = document.createAttribute(&quot;align&quot;);
attr.value = &quot;left&quot;;
element.setAttributeNode(attr);

alert(element.attributes[&quot;align&quot;].value);       // &quot;left&quot;
alert(element.getAttributeNode(&quot;align&quot;).value); // &quot;left&quot;
alert(element.getAttribute(&quot;align&quot;));           // &quot;left&quot;
</code></pre></div><p>在这个例子中，首先创建了一个新属性。调用<code>createAttribute()</code>并传入<code>&quot;align&quot;</code>为新属性设置了<code>name</code>属性，因此就不用再设置了。随后，<code>value</code>属性被赋值为<code>&quot;left&quot;</code>。为把这个新属性添加到元素上，可以使用元素的<code>setAttributeNode()</code>方法。添加这个属性后，可以通过不同方式访问它，包括<code>attributes</code>属性、<code>getAttributeNode()</code>和<code>getAttribute()</code>方法。其中，<code>attributes</code>属性和<code>getAttributeNode()</code>方法都返回属性对应的<code>Attr</code>节点，而<code>getAttribute()</code>方法只返回属性的值。</p> <blockquote><p><strong>注意</strong>　将属性作为节点来访问多数情况下并无必要。推荐使用<code>getAttribute()</code>、<code>removeAttribute()</code>和<code>setAttribute()</code>方法操作属性，而不是直接操作属性节点。</p></blockquote> <h2 id="_14-2-dom-编程"><a href="#_14-2-dom-编程" class="header-anchor">#</a> 14.2 　 DOM 编程</h2> <p>很多时候，操作 DOM 是很直观的。通过 HTML 代码能实现的，也一样能通过 JavaScript 实现。但有时候，DOM 也没有看起来那么简单。浏览器能力的参差不齐和各种问题，也会导致 DOM 的某些方面会复杂一些。</p> <h3 id="_14-2-1-动态脚本"><a href="#_14-2-1-动态脚本" class="header-anchor">#</a> 14.2.1 　动态脚本</h3> <div class="language- extra-class"><pre class="language-text"><code>
可以像这样通过DOM编程创建这个节点：

</code></pre></div><p>let script = document.createElement(&quot;script&quot;);
script.src = &quot;foo.js&quot;;
document.body.appendChild(script);</p> <div class="language- extra-class"><pre class="language-text"><code>
这里的DOM代码实际上完全照搬了它要表示的HTML代码。注意，在上面最后一行把`&lt;script&gt;`元素添加到页面之前，是不会开始下载外部文件的。当然也可以把它添加到`&lt;head&gt;`元素，同样可以实现动态脚本加载。这个过程可以抽象为一个函数，比如：

</code></pre></div><p>function loadScript(url) {
let script = document.createElement(&quot;script&quot;);
script.src = url;
document.body.appendChild(script);
}</p> <div class="language- extra-class"><pre class="language-text"><code>
然后，就可以像下面这样加载外部JavaScript文件了：

</code></pre></div><p>loadScript(&quot;client.js&quot;);</p> <div class="language- extra-class"><pre class="language-text"><code>
加载之后，这个脚本就可以对页面执行操作了。这里有个问题：怎么能知道脚本什么时候加载完？这个问题并没有标准答案。第17章会讨论一些与加载相关的事件，具体情况取决于使用的浏览器。

另一个动态插入JavaScript的方式是嵌入源代码，如下面的例子所示：

</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>
使用DOM，可以实现以下逻辑：

</code></pre></div><p>let script = document.createElement(&quot;script&quot;);
script.appendChild(document.createTextNode(&quot;function sayHi(){alert('hi');}&quot;));
document.body.appendChild(script);</p> <div class="language- extra-class"><pre class="language-text"><code>
以上代码可以在`Firefox`、`Safari`、`Chrome`和`Opera`中运行。不过在旧版本的IE中可能会导致问题。这是因为IE对`&lt;script&gt;`元素做了特殊处理，不允许常规DOM访问其子节点。但`&lt;script&gt;`元素上有一个`text`属性，可以用来添加JavaScript代码，如下所示：

</code></pre></div><p>var script = document.createElement(&quot;script&quot;);
script.text = &quot;function sayHi(){alert('hi');}&quot;;
document.body.appendChild(script);</p> <div class="language- extra-class"><pre class="language-text"><code>
这样修改后，上面的代码可以在IE、Firefox、Opera和Safari 3及更高版本中运行。Safari 3之前的版本不能正确支持这个`text`属性，但这些版本却支持文本节点赋值。对于早期的Safari版本，需要使用以下代码：

</code></pre></div><p>var script = document.createElement(&quot;script&quot;);
var code = &quot;function sayHi(){alert('hi');}&quot;;
try {
script.appendChild(document.createTextNode(&quot;code&quot;));
} catch (ex){
script.text = &quot;code&quot;;
}
document.body.appendChild(script);</p> <div class="language- extra-class"><pre class="language-text"><code>
这里先尝试使用标准的DOM文本节点插入方式，因为除IE之外的浏览器都支持这种方式。IE此时会抛出错误，那么可以在捕获错误之后再使用`text`属性来插入JavaScript代码。于是，我们就可以抽象出一个跨浏览器的函数：

</code></pre></div><p>function loadScriptString(code){
var script = document.createElement(&quot;script&quot;);
script.type = &quot;text/javascript&quot;;
try {
script.appendChild(document.createTextNode(code));
} catch (ex){
script.text = code;
}
document.body.appendChild(script);
}</p> <div class="language- extra-class"><pre class="language-text"><code>
这个函数可以这样调用：

</code></pre></div><p>loadScriptString(&quot;function sayHi(){alert('hi');}&quot;);</p> <div class="language- extra-class"><pre class="language-text"><code>
以这种方式加载的代码会在全局作用域中执行，并在调用返回后立即生效。基本上，这就相当于在全局作用域中把源代码传给`eval()`方法。

注意，通过`innerHTML`属性创建的`&lt;script&gt;`元素永远不会执行。浏览器会尽责地创建`&lt;script&gt;`元素，以及其中的脚本文本，但解析器会给这个`&lt;script&gt;`元素打上永不执行的标签。只要是使用`innerHTML`创建的`&lt;script&gt;`元素，以后也没有办法强制其执行。

### 14.2.2　动态样式

CSS样式在HTML页面中可以通过两个元素加载。`&lt;link&gt;`元素用于包含CSS外部文件，而`&lt;style&gt;`元素用于添加嵌入样式。与动态脚本类似，动态样式也是页面初始加载时并不存在，而是在之后才添加到页面中的。

来看下面这个典型的`&lt;link&gt;`元素：

</code></pre></div><link rel="stylesheet" type="text/css" href="styles.css">
```
<p>这个元素很容易使用 DOM 编程创建出来：</p> <div class="language- extra-class"><pre class="language-text"><code>let link = document.createElement(&quot;link&quot;);
link.rel = &quot;stylesheet&quot;;
link.type = &quot;text/css&quot;;
link.href = &quot;styles.css&quot;;
let head = document.getElementsByTagName(&quot;head&quot;)[0];
head.appendChild(link);
</code></pre></div><p>以上代码在所有主流浏览器中都能正常运行。注意应该把<code>&lt;link&gt;</code>元素添加到<code>&lt;head&gt;</code>元素而不是<code>&lt;body&gt;</code>元素，这样才能保证所有浏览器都能正常运行。这个过程可以抽象为以下通用函数：</p> <div class="language- extra-class"><pre class="language-text"><code>function loadStyles(url){
  let link = document.createElement(&quot;link&quot;);
  link.rel = &quot;stylesheet&quot;;
  link.type = &quot;text/css&quot;;
  link.href = url;
  let head = document.getElementsByTagName(&quot;head&quot;)[0];
  head.appendChild(link);
}
</code></pre></div><p>然后就可以这样调用这个<code>loadStyles()</code>函数了：</p> <div class="language- extra-class"><pre class="language-text"><code>loadStyles(&quot;styles.css&quot;);
</code></pre></div><p>通过外部文件加载样式是一个异步过程。因此，样式的加载和正执行的 JavaScript 代码并没有先后顺序。一般来说，也没有必要知道样式什么时候加载完成。</p> <p>另一种定义样式的方式是使用<code>&lt;script&gt;</code>元素包含嵌入的 CSS 规则，例如：</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;style type=&quot;text/css&quot;&gt;
body {
  background-color: red;
}
&lt;/style&gt;
</code></pre></div><p>逻辑上，下列 DOM 代码会有同样的效果：</p> <div class="language- extra-class"><pre class="language-text"><code>let style = document.createElement(&quot;style&quot;);
style.type = &quot;text/css&quot;;
style.appendChild(document.createTextNode(&quot;body{background-color:red}&quot;));
let head = document.getElementsByTagName(&quot;head&quot;)[0];
head.appendChild(style);
</code></pre></div><p>以上代码在 Firefox、Safari、Chrome 和 Opera 中都可以运行，但 IE 除外。IE 对<code>&lt;style&gt;</code>节点会施加限制，不允许访问其子节点，这一点与它对<code>&lt;script&gt;</code>元素施加的限制一样。事实上，IE 在执行到给<code>&lt;style&gt;</code>添加子节点的代码时，会抛出与给<code>&lt;script&gt;</code>添加子节点时同样的错误。对于 IE，解决方案是访问元素的<code>styleSheet</code>属性，这个属性又有一个<code>cssText</code>属性，然后给这个属性添加 CSS 代码：</p> <div class="language- extra-class"><pre class="language-text"><code>let style = document.createElement(&quot;style&quot;);
style.type = &quot;text/css&quot;;
try{
  style.appendChild(document.createTextNode(&quot;body{background-color:red}&quot;));
} catch (ex){
  style.styleSheet.cssText = &quot;body{background-color:red}&quot;;
}
let head = document.getElementsByTagName(&quot;head&quot;)[0];
head.appendChild(style);
</code></pre></div><p>与动态添加脚本源代码类似，这里也使用了<code>try...catch</code>语句捕获 IE 抛出的错误，然后再以 IE 特有的方式来设置样式。这是最终的通用函数：</p> <div class="language- extra-class"><pre class="language-text"><code>function loadStyleString(css){
  let style = document.createElement(&quot;style&quot;);
  style.type = &quot;text/css&quot;;
  try{
    style.appendChild(document.createTextNode(css));
  } catch (ex){
    style.styleSheet.cssText = css;
  }
  let head = document.getElementsByTagName(&quot;head&quot;)[0];
    head.appendChild(style);
}
</code></pre></div><p>可以这样调用这个函数：</p> <div class="language- extra-class"><pre class="language-text"><code>loadStyleString(&quot;body{background-color:red}&quot;);
</code></pre></div><p>这样添加的样式会立即生效，因此所有变化会立即反映出来。</p> <blockquote><p><strong>注意</strong>　对于 IE，要小心使用<code>styleSheet.cssText</code>。如果重用同一个<code>&lt;style&gt;</code>元素并设置该属性超过一次，则可能导致浏览器崩溃。同样，将<code>cssText</code>设置为空字符串也可能导致浏览器崩溃。</p></blockquote> <h3 id="_14-2-3-操作表格"><a href="#_14-2-3-操作表格" class="header-anchor">#</a> 14.2.3 　操作表格</h3> <p>表格是 HTML 中最复杂的结构之一。通过 DOM 编程创建<code>&lt;table&gt;</code>元素，通常要涉及大量标签，包括表行、表元、表题，等等。因此，通过 DOM 编程创建和修改表格时可能要写很多代码。假设要通过 DOM 来创建以下 HTML 表格：</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;table border=&quot;1&quot; width=&quot;100%&quot;&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Cell 1,1&lt;/td&gt;
      &lt;td&gt;Cell 2,1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Cell 1,2&lt;/td&gt;
      &lt;td&gt;Cell 2,2&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
</code></pre></div><p>下面就是以 DOM 编程方式重建这个表格的代码：</p> <div class="language- extra-class"><pre class="language-text"><code>// 创建表格
let table = document.createElement(&quot;table&quot;);
table.border = 1;
table.width = &quot;100%&quot;;

// 创建表体
let tbody = document.createElement(&quot;tbody&quot;);
table.appendChild(tbody);

// 创建第一行
let row1 = document.createElement(&quot;tr&quot;);
tbody.appendChild(row1);
let cell1_1 = document.createElement(&quot;td&quot;);
cell1_1.appendChild(document.createTextNode(&quot;Cell 1,1&quot;));
row1.appendChild(cell1_1);
let cell2_1 = document.createElement(&quot;td&quot;);
cell2_1.appendChild(document.createTextNode(&quot;Cell 2,1&quot;));
row1.appendChild(cell2_1);

// 创建第二行
let row2 = document.createElement(&quot;tr&quot;);
tbody.appendChild(row2);
let cell1_2 = document.createElement(&quot;td&quot;);
cell1_2.appendChild(document.createTextNode(&quot;Cell 1,2&quot;));
row2.appendChild(cell1_2);
let cell2_2= document.createElement(&quot;td&quot;);
cell2_2.appendChild(document.createTextNode(&quot;Cell 2,2&quot;));
row2.appendChild(cell2_2);

// 把表格添加到文档主体
document.body.appendChild(table);
</code></pre></div><p>以上代码相当烦琐，也不好理解。为了方便创建表格，HTML DOM 给<code>&lt;table&gt;</code>、<code>&lt;tbody&gt;</code>和<code>&lt;tr&gt;</code>元素添加了一些属性和方法。</p> <p><code>&lt;table&gt;</code>元素添加了以下属性和方法：</p> <ul><li><code>caption</code>，指向<code>&lt;caption&gt;</code>元素的指针（如果存在）；</li> <li><code>tBodies</code>，包含<code>&lt;tbody&gt;</code>元素的<code>HTMLCollection</code>；</li> <li><code>tFoot</code>，指向<code>&lt;tfoot&gt;</code>元素（如果存在）；</li> <li><code>tHead</code>，指向<code>&lt;thead&gt;</code>元素（如果存在）；</li> <li><code>rows</code>，包含表示所有行的<code>HTMLCollection</code>；</li> <li><code>createTHead()</code>，创建<code>&lt;thead&gt;</code>元素，放到表格中，返回引用；</li> <li><code>createTFoot()</code>，创建<code>&lt;tfoot&gt;</code>元素，放到表格中，返回引用；</li> <li><code>createCaption()</code>，创建<code>&lt;caption&gt;</code>元素，放到表格中，返回引用；</li> <li><code>deleteTHead()</code>，删除<code>&lt;thead&gt;</code>元素；</li> <li><code>deleteTFoot()</code>，删除<code>&lt;tfoot&gt;</code>元素；</li> <li><code>deleteCaption()</code>，删除<code>&lt;caption&gt;</code>元素；</li> <li><code>deleteRow(*pos*)</code>，删除给定位置的行；</li> <li><code>insertRow(*pos*)</code>，在行集合中给定位置插入一行。</li></ul> <p><code>&lt;tbody&gt;</code>元素添加了以下属性和方法：</p> <ul><li><code>rows</code>，包含<code>&lt;tbody&gt;</code>元素中所有行的<code>HTMLCollection</code>；</li> <li><code>deleteRow(*pos*)</code>，删除给定位置的行；</li> <li><code>insertRow(*pos*)</code>，在行集合中给定位置插入一行，返回该行的引用。</li></ul> <p><code>&lt;tr&gt;</code>元素添加了以下属性和方法：</p> <ul><li><code>cells</code>，包含<code>&lt;tr&gt;</code>元素所有表元的<code>HTMLCollection</code>；</li> <li><code>deleteCell(*pos*)</code>，删除给定位置的表元；</li> <li><code>insertCell(*pos*)</code>，在表元集合给定位置插入一个表元，返回该表元的引用。</li></ul> <p>这些属性和方法极大地减少了创建表格所需的代码量。例如，使用这些方法重写前面的代码之后是这样的（加粗代码表示更新的部分）：</p> <div class="language- extra-class"><pre class="language-text"><code>// 创建表格
let table = document.createElement(&quot;table&quot;);
table.border = 1;
table.width = &quot;100%&quot;;

// 创建表体
let tbody = document.createElement(&quot;tbody&quot;);
table.appendChild(tbody);

// 创建第一行
tbody.insertRow(0);
tbody.rows[0].insertCell(0);
tbody.rows[0].cells[0].appendChild(document.createTextNode(&quot;Cell 1,1&quot;));
tbody.rows[0].insertCell(1);
tbody.rows[0].cells[1].appendChild(document.createTextNode(&quot;Cell 2,1&quot;));

// 创建第二行
tbody.insertRow(1);
tbody.rows[1].insertCell(0);
tbody.rows[1].cells[0].appendChild(document.createTextNode(&quot;Cell 1,2&quot;));
tbody.rows[1].insertCell(1);
tbody.rows[1].cells[1].appendChild(document.createTextNode(&quot;Cell 2,2&quot;));

// 把表格添加到文档主体
document.body.appendChild(table);
</code></pre></div><p>这里创建<code>&lt;table&gt;</code>和<code>&lt;tbody&gt;</code>元素的代码没有变。变化的是创建两行的部分，这次使用了 HTML DOM 表格的属性和方法。创建第一行时，在<code>&lt;tbody&gt;</code>元素上调用了<code>insertRow()</code>方法。传入参数<code>0</code>，表示把这一行放在什么位置。然后，使用<code>tbody.rows[0]</code>来引用这一行，因为这一行刚刚创建并被添加到了<code>&lt;tbody&gt;</code>的位置<code>0</code>。</p> <p>创建表元的方式也与之类似。在<code>&lt;tr&gt;</code>元素上调用<code>insertCell()</code>方法，传入参数<code>0</code>，表示把这个表元放在什么位置上。然后，使用<code>tbody.rows[0].cells[0]</code>来引用这个表元，因为这个表元刚刚创建并被添加到了<code>&lt;tr&gt;</code>的位置<code>0</code>。</p> <p>虽然以上两种代码在技术上都是正确的，但使用这些属性和方法创建表格让代码变得更有逻辑性，也更容易理解。</p> <h3 id="_14-2-4-使用nodelist"><a href="#_14-2-4-使用nodelist" class="header-anchor">#</a> 14.2.4 　使用<code>NodeList</code></h3> <p>理解<code>NodeList</code>对象和相关的<code>NamedNodeMap</code>、<code>HTMLCollection</code>，是理解 DOM 编程的关键。这 3 个集合类型都是“实时的”，意味着文档结构的变化会实时地在它们身上反映出来，因此它们的值始终代表最新的状态。实际上，<code>NodeList</code>就是基于 DOM 文档的实时查询。例如，下面的代码会导致无穷循环：</p> <div class="language- extra-class"><pre class="language-text"><code>let divs = document.getElementsByTagName(&quot;div&quot;);

for (let i = 0; i &lt; divs.length; ++i){
  let div = document.createElement(&quot;div&quot;);
  document.body.appendChild(div);
}
</code></pre></div><p>第一行取得了包含文档中所有<code>&lt;div&gt;</code>元素的<code>HTMLCollection</code>。因为这个集合是“实时的”，所以任何时候只要向页面中添加一个新<code>&lt;div&gt;</code>元素，再查询这个集合就会多一项。因为浏览器不希望保存每次创建的集合，所以就会在每次访问时更新集合。这样就会出现前面使用循环的例子中所演示的问题。每次循环开始，都会求值<code>i &lt; divs.length</code>。这意味着要执行获取所有<code>&lt;div&gt;</code>元素的查询。因为循环体中会创建并向文档添加一个新<code>&lt;div&gt;</code>元素，所以每次循环<code>divs.length</code>的值也会递增。因为两个值都会递增，所以<code>i</code>将永远不会等于<code>divs.length</code>。</p> <p>使用 ES6 迭代器并不会解决这个问题，因为迭代的是一个永远增长的实时集合。以下代码仍然会导致无穷循环：</p> <div class="language- extra-class"><pre class="language-text"><code>for (let div of document.getElementsByTagName(&quot;div&quot;)){
  let newDiv = document.createElement(&quot;div&quot;);
  document.body.appendChild(newDiv);
}
</code></pre></div><p>任何时候要迭代<code>NodeList</code>，最好再初始化一个变量保存当时查询时的长度，然后用循环变量与这个变量进行比较，如下所示：</p> <div class="language- extra-class"><pre class="language-text"><code>let divs = document.getElementsByTagName(&quot;div&quot;);

for (let i = 0, len = divs.length; i &lt; len; ++i) {
  let div = document.createElement(&quot;div&quot;);
  document.body.appendChild(div);
}
</code></pre></div><p>在这个例子中，又初始化了一个保存集合长度的变量<code>len</code>。因为<code>len</code>保存着循环开始时集合的长度，而这个值不会随集合增大动态增长，所以就可以避免前面例子中出现的无穷循环。本章还会使用这种技术来演示迭代<code>NodeList</code>对象的首选方式。</p> <p>另外，如果不想再初始化一个变量，也可以像下面这样反向迭代集合：</p> <div class="language- extra-class"><pre class="language-text"><code>let divs = document.getElementsByTagName(&quot;div&quot;);

for (let i = divs.length - 1; i &gt;= 0; --i) {
  let div = document.createElement(&quot;div&quot;);
  document.body.appendChild(div);
}
</code></pre></div><p>一般来说，最好限制操作<code>NodeList</code>的次数。因为每次查询都会搜索整个文档，所以最好把查询到的<code>NodeList</code>缓存起来。</p> <h2 id="_14-3-mutationobserver接口"><a href="#_14-3-mutationobserver接口" class="header-anchor">#</a> 14.3 　<code>MutationObserver</code>接口</h2> <p>不久前添加到 DOM 规范中的<code>MutationObserver</code>接口，可以在 DOM 被修改时异步执行回调。使用<code>MutationObserver</code>可以观察整个文档、DOM 树的一部分，或某个元素。此外还可以观察元素属性、子节点、文本，或者前三者任意组合的变化。</p> <blockquote><p><strong>注意</strong>　新引进<code>MutationObserver</code>接口是为了取代废弃的<code>MutationEvent</code>。</p></blockquote> <h3 id="_14-3-1-基本用法"><a href="#_14-3-1-基本用法" class="header-anchor">#</a> 14.3.1 　基本用法</h3> <p><code>MutationObserver</code>的实例要通过调用<code>MutationObserver</code>构造函数并传入一个回调函数来创建：</p> <div class="language- extra-class"><pre class="language-text"><code>let observer = new MutationObserver(() =&gt; console.log('DOM was mutated!'));
</code></pre></div><ol><li><p><strong>observe()方法</strong></p> <p>新创建的<code>MutationObserver</code>实例不会关联 DOM 的任何部分。要把这个<code>observer</code>与 DOM 关联起来，需要使用<code>observe()</code>方法。这个方法接收两个必需的参数：要观察其变化的 DOM 节点，以及一个<code>MutationObserverInit</code>对象。</p> <p><code>MutationObserverInit</code>对象用于控制观察哪些方面的变化，是一个键/值对形式配置选项的字典。例如，下面的代码会创建一个观察者（<code>observer</code>）并配置它观察<code>&lt;body&gt;</code>元素上的属性变化：</p> <div class="language- extra-class"><pre class="language-text"><code>let observer = new MutationObserver(() =&gt; console.log('&lt;body&gt; attributes changed'));

observer.observe(document.body, { attributes: true });
</code></pre></div><p>执行以上代码后，<code>&lt;body&gt;</code>元素上任何属性发生变化都会被这个<code>MutationObserver</code>实例发现，然后就会异步执行注册的回调函数。<code>&lt;body&gt;</code>元素后代的修改或其他非属性修改都不会触发回调进入任务队列。可以通过以下代码来验证：</p> <div class="language- extra-class"><pre class="language-text"><code>let observer = new MutationObserver(() =&gt; console.log('&lt;body&gt; attributes changed'));

observer.observe(document.body, { attributes: true });

document.body.className = 'foo';
console.log('Changed body class');

// Changed body class
// &lt;body&gt; attributes changed
</code></pre></div><p>注意，回调中的<code>console.log()</code>是后执行的。这表明回调并非与实际的 DOM 变化同步执行。</p></li></ol> <ol start="2"><li><p><strong>回调与 MutationRecord</strong></p> <p>每个回调都会收到一个<code>MutationRecord</code>实例的数组。<code>MutationRecord</code>实例包含的信息包括发生了什么变化，以及 DOM 的哪一部分受到了影响。因为回调执行之前可能同时发生多个满足观察条件的事件，所以每次执行回调都会传入一个包含按顺序入队的<code>MutationRecord</code>实例的数组。</p> <p>下面展示了反映一个属性变化的<code>MutationRecord</code>实例的数组：</p> <div class="language- extra-class"><pre class="language-text"><code>let observer = new MutationObserver(
    (mutationRecords) =&gt; console.log(mutationRecords));

observer.observe(document.body, { attributes: true });

document.body.setAttribute('foo', 'bar');
// [
//   {
//     addedNodes: NodeList [],
//     attributeName: &quot;foo&quot;,
//     attributeNamespace: null,
//     nextSibling: null,
//     oldValue: null,
//     previousSibling: null
//     removedNodes: NodeList [],
//     target: body
//     type: &quot;attributes&quot;
//   }
// ]
</code></pre></div><p>下面是一次涉及命名空间的类似变化：</p> <div class="language- extra-class"><pre class="language-text"><code>let observer = new MutationObserver(
    (mutationRecords) =&gt; console.log(mutationRecords));

observer.observe(document.body, { attributes: true });

document.body.setAttributeNS('baz', 'foo', 'bar');

// [
//   {
//     addedNodes: NodeList [],
//     attributeName: &quot;foo&quot;,
//     attributeNamespace: &quot;baz&quot;,
//     nextSibling: null,
//     oldValue: null,
//     previousSibling: null
//     removedNodes: NodeList [],
//     target: body
//     type: &quot;attributes&quot;
//   }
// ]
</code></pre></div><p>连续修改会生成多个<code>MutationRecord</code>实例，下次回调执行时就会收到包含所有这些实例的数组，顺序为变化事件发生的顺序：</p> <div class="language- extra-class"><pre class="language-text"><code>let observer = new MutationObserver(
    (mutationRecords) =&gt; console.log(mutationRecords));

observer.observe(document.body, { attributes: true });

document.body.className = 'foo';
document.body.className = 'bar';
document.body.className = 'baz';

// [MutationRecord, MutationRecord, MutationRecord]
</code></pre></div><p>下表列出了<code>MutationRecord</code>实例的属性。</p> <table><thead><tr><th style="text-align:left;">属性</th> <th style="text-align:left;">说明</th></tr></thead> <tbody><tr><td style="text-align:left;"><code>target</code></td> <td style="text-align:left;">被修改影响的目标节点</td></tr> <tr><td style="text-align:left;"><code>type</code></td> <td style="text-align:left;">字符串，表示变化的类型：<code>&quot;attributes&quot;</code>、<code>&quot;characterData&quot;</code>或<code>&quot;childList&quot;</code></td></tr> <tr><td style="text-align:left;"><code>oldValue</code></td> <td style="text-align:left;">如果在<code>MutationObserverInit</code>对象中启用（<code>attributeOldValue</code>或<code>characterData OldValue</code>为<code>true</code>），<code>&quot;attributes&quot;</code>或<code>&quot;characterData&quot;</code>的变化事件会设置这个属性为被替代的值 <code>&quot;childList&quot;</code>类型的变化始终将这个属性设置为<code>null</code></td></tr> <tr><td style="text-align:left;"><code>attributeName</code></td> <td style="text-align:left;">对于<code>&quot;attributes&quot;</code>类型的变化，这里保存被修改属性的名字 其他变化事件会将这个属性设置为<code>null</code></td></tr> <tr><td style="text-align:left;"><code>attributeNamespace</code></td> <td style="text-align:left;">对于使用了命名空间的<code>&quot;attributes&quot;</code>类型的变化，这里保存被修改属性的名字 其他变化事件会将这个属性设置为<code>null</code></td></tr> <tr><td style="text-align:left;"><code>addedNodes</code></td> <td style="text-align:left;">对于<code>&quot;childList&quot;</code>类型的变化，返回包含变化中添加节点的<code>NodeList</code> 默认为空<code>NodeList</code></td></tr> <tr><td style="text-align:left;"><code>removedNodes</code></td> <td style="text-align:left;">对于<code>&quot;childList&quot;</code>类型的变化，返回包含变化中删除节点的<code>NodeList</code> 默认为空<code>NodeList</code></td></tr> <tr><td style="text-align:left;"><code>previousSibling</code></td> <td style="text-align:left;">对于<code>&quot;childList&quot;</code>类型的变化，返回变化节点的前一个同胞<code>Node</code> 默认为<code>null</code></td></tr> <tr><td style="text-align:left;"><code>nextSibling</code></td> <td style="text-align:left;">对于<code>&quot;childList&quot;</code>类型的变化，返回变化节点的后一个同胞<code>Node</code> 默认为<code>null</code></td></tr></tbody></table> <p>传给回调函数的第二个参数是观察变化的<code>MutationObserver</code>的实例，演示如下：</p> <div class="language- extra-class"><pre class="language-text"><code>let observer = new MutationObserver(
    (mutationRecords, mutationObserver) =&gt; console.log(mutationRecords,
mutationObserver));

observer.observe(document.body, { attributes: true });

document.body.className = 'foo';

// [MutationRecord], MutationObserver
</code></pre></div></li></ol> <ol start="3"><li><p><strong>disconnect()方法</strong></p> <p>默认情况下，只要被观察的元素不被垃圾回收，<code>MutationObserver</code>的回调就会响应 DOM 变化事件，从而被执行。要提前终止执行回调，可以调用<code>disconnect()</code>方法。下面的例子演示了同步调用<code>disconnect()</code>之后，不仅会停止此后变化事件的回调，也会抛弃已经加入任务队列要异步执行的回调：</p> <div class="language- extra-class"><pre class="language-text"><code>let observer = new MutationObserver(() =&gt; console.log('&lt;body&gt; attributes changed'));

observer.observe(document.body, { attributes: true });

document.body.className = 'foo';

observer.disconnect();

document.body.className = 'bar';

//（没有日志输出）
</code></pre></div><p>要想让已经加入任务队列的回调执行，可以使用<code>setTimeout()</code>让已经入列的回调执行完毕再调用<code>disconnect()</code>：</p> <div class="language- extra-class"><pre class="language-text"><code>let observer = new MutationObserver(() =&gt; console.log('&lt;body&gt; attributes changed'));

observer.observe(document.body, { attributes: true });

document.body.className = 'foo';

setTimeout(() =&gt; {
  observer.disconnect();
  document.body.className = 'bar';
}, 0);

// &lt;body&gt; attributes changed
</code></pre></div></li></ol> <ol start="4"><li><p><strong>复用 MutationObserver</strong></p> <p>多次调用<code>observe()</code>方法，可以复用一个<code>MutationObserver</code>对象观察多个不同的目标节点。此时，<code>MutationRecord</code>的<code>target</code>属性可以标识发生变化事件的目标节点。下面的示例演示了这个过程：</p> <div class="language- extra-class"><pre class="language-text"><code>let observer = new MutationObserver(
               (mutationRecords) =&gt; console.log(mutationRecords.map((x) =&gt;
x.target)));

// 向页面主体添加两个子节点
let childA = document.createElement('div'),
    childB = document.createElement('span');
document.body.appendChild(childA);
document.body.appendChild(childB);

// 观察两个子节点
observer.observe(childA, { attributes: true });
observer.observe(childB, { attributes: true });

// 修改两个子节点的属性
childA.setAttribute('foo', 'bar');
childB.setAttribute('foo', 'bar');

// [&lt;div&gt;, &lt;span&gt;]
</code></pre></div><p><code>disconnect()</code>方法是一个“一刀切”的方案，调用它会停止观察所有目标：</p> <div class="language- extra-class"><pre class="language-text"><code>let observer = new MutationObserver(
               (mutationRecords) =&gt; console.log(mutationRecords.map((x) =&gt;
x.target)));

// 向页面主体添加两个子节点
let childA = document.createElement('div'),
    childB = document.createElement('span');
document.body.appendChild(childA);
document.body.appendChild(childB);

// 观察两个子节点
observer.observe(childA, { attributes: true });
observer.observe(childB, { attributes: true });

observer.disconnect();

// 修改两个子节点的属性
childA.setAttribute('foo', 'bar');
childB.setAttribute('foo', 'bar');

// （没有日志输出）
</code></pre></div></li></ol> <ol start="5"><li><p><strong>重用 MutationObserver</strong></p> <p>调用<code>disconnect()</code>并不会结束<code>MutationObserver</code>的生命。还可以重新使用这个观察者，再将它关联到新的目标节点。下面的示例在两个连续的异步块中先断开然后又恢复了观察者与<code>&lt;body&gt;</code>元素的关联：</p> <div class="language- extra-class"><pre class="language-text"><code>let observer = new MutationObserver(() =&gt; console.log('&lt;body&gt; attributes
changed'));

observer.observe(document.body, { attributes: true });

// 这行代码会触发变化事件
document.body.setAttribute('foo', 'bar');

setTimeout(() =&gt; {
  observer.disconnect();

  // 这行代码不会触发变化事件
  document.body.setAttribute('bar', 'baz');
}, 0);
　
　
setTimeout(() =&gt; {
  // Reattach
  observer.observe(document.body, { attributes: true });

  // 这行代码会触发变化事件
  document.body.setAttribute('baz', 'qux');
}, 0);

// &lt;body&gt; attributes changed
// &lt;body&gt; attributes changed
</code></pre></div></li></ol> <h3 id="_14-3-2-mutationobserverinit与观察范围"><a href="#_14-3-2-mutationobserverinit与观察范围" class="header-anchor">#</a> 14.3.2 　<code>MutationObserverInit</code>与观察范围</h3> <p><code>MutationObserverInit</code>对象用于控制对目标节点的观察范围。粗略地讲，观察者可以观察的事件包括属性变化、文本变化和子节点变化。</p> <p>下表列出了<code>MutationObserverInit</code>对象的属性。</p> <table><thead><tr><th style="text-align:left;">属性</th> <th style="text-align:left;">说明</th></tr></thead> <tbody><tr><td style="text-align:left;"><code>subtree</code></td> <td style="text-align:left;">布尔值，表示除了目标节点，是否观察目标节点的子树（后代） 如果是<code>false</code>，则只观察目标节点的变化；如果是<code>true</code>，则观察目标节点及其整个子树 默认为<code>false</code></td></tr> <tr><td style="text-align:left;"><code>attributes</code></td> <td style="text-align:left;">布尔值，表示是否观察目标节点的属性变化 默认为<code>false</code></td></tr> <tr><td style="text-align:left;"><code>attributeFilter</code></td> <td style="text-align:left;">字符串数组，表示要观察哪些属性的变化 把这个值设置为<code>true</code>也会将<code>attributes</code>的值转换为<code>true</code> 默认为观察所有属性</td></tr> <tr><td style="text-align:left;"><code>attributeOldValue</code></td> <td style="text-align:left;">布尔值，表示<code>MutationRecord</code>是否记录变化之前的属性值 把这个值设置为<code>true</code>也会将<code>attributes</code>的值转换为<code>true</code> 默认为<code>false</code></td></tr> <tr><td style="text-align:left;"><code>characterData</code></td> <td style="text-align:left;">布尔值，表示修改字符数据是否触发变化事件 默认为<code>false</code></td></tr> <tr><td style="text-align:left;"><code>characterDataOldValue</code></td> <td style="text-align:left;">布尔值，表示<code>MutationRecord</code>是否记录变化之前的字符数据 把这个值设置为<code>true</code>也会将<code>characterData</code>的值转换为<code>true</code> 默认为<code>false</code></td></tr> <tr><td style="text-align:left;"><code>childList</code></td> <td style="text-align:left;">布尔值，表示修改目标节点的子节点是否触发变化事件 默认为<code>false</code></td></tr></tbody></table> <blockquote><p><strong>注意</strong>　在调用<code>observe()</code>时，<code>MutationObserverInit</code>对象中的<code>attribute</code>、<code>characterData</code>和<code>childList</code>属性必须至少有一项为<code>true</code>（无论是直接设置这几个属性，还是通过设置<code>attributeOldValue</code>等属性间接导致它们的值转换为<code>true</code>）。否则会抛出错误，因为没有任何变化事件可能触发回调。</p></blockquote> <ol><li><p><strong>观察属性</strong></p> <p><code>MutationObserver</code>可以观察节点属性的添加、移除和修改。要为属性变化注册回调，需要在<code>MutationObserverInit</code>对象中将<code>attributes</code>属性设置为<code>true</code>，如下所示：</p> <div class="language- extra-class"><pre class="language-text"><code>let observer = new MutationObserver(
    (mutationRecords) =&gt; console.log(mutationRecords));

observer.observe(document.body, { attributes: true });

// 添加属性
document.body.setAttribute('foo', 'bar');

// 修改属性
document.body.setAttribute('foo', 'baz');

// 移除属性
document.body.removeAttribute('foo');

// 以上变化都被记录下来了
// [MutationRecord, MutationRecord, MutationRecord]
</code></pre></div><p>把<code>attributes</code>设置为<code>true</code>的默认行为是观察所有属性，但不会在<code>MutationRecord</code>对象中记录原来的属性值。如果想观察某个或某几个属性，可以使用<code>attributeFilter</code>属性来设置白名单，即一个属性名字符串数组：</p> <div class="language- extra-class"><pre class="language-text"><code>let observer = new MutationObserver(
    (mutationRecords) =&gt; console.log(mutationRecords));

observer.observe(document.body, { attributeFilter: ['foo'] });

// 添加白名单属性
document.body.setAttribute('foo', 'bar');

// 添加被排除的属性
document.body.setAttribute('baz', 'qux');

// 只有foo属性的变化被记录了
// [MutationRecord]
</code></pre></div><p>如果想在变化记录中保存属性原来的值，可以将<code>attributeOldValue</code>属性设置为<code>true</code>：</p> <div class="language- extra-class"><pre class="language-text"><code>let observer = new MutationObserver(
    (mutationRecords) =&gt; console.log(mutationRecords.map((x) =&gt; x.oldValue)));

observer.observe(document.body, { attributeOldValue: true });

document.body.setAttribute('foo', 'bar');
document.body.setAttribute('foo', 'baz');
document.body.setAttribute('foo', 'qux');

// 每次变化都保留了上一次的值
// [null, 'bar', 'baz']
</code></pre></div></li></ol> <ol start="2"><li><p><strong>观察字符数据</strong></p> <p><code>MutationObserver</code>可以观察文本节点（如<code>Text</code>、<code>Comment</code>或<code>ProcessingInstruction</code>节点）中字符的添加、删除和修改。要为字符数据注册回调，需要在<code>MutationObserverInit</code>对象中将<code>characterData</code>属性设置为<code>true</code>，如下所示：</p> <div class="language- extra-class"><pre class="language-text"><code>let observer = new MutationObserver(
    (mutationRecords) =&gt; console.log(mutationRecords));

// 创建要观察的文本节点
document.body.innerText = 'foo';

observer.observe(document.body.firstChild, { characterData: true });

// 赋值为相同的字符串
document.body.innerText = 'foo';

// 赋值为新字符串
document.body.innerText = 'bar';

// 通过节点设置函数赋值
document.body.firstChild.textContent = 'baz';

// 以上变化都被记录下来了
// [MutationRecord, MutationRecord, MutationRecord]
</code></pre></div><p>将<code>characterData</code>属性设置为<code>true</code>的默认行为不会在<code>MutationRecord</code>对象中记录原来的字符数据。如果想在变化记录中保存原来的字符数据，可以将<code>characterDataOldValue</code>属性设置为<code>true</code>：</p> <div class="language- extra-class"><pre class="language-text"><code>let observer = new MutationObserver(
    (mutationRecords) =&gt; console.log(mutationRecords.map((x) =&gt; x.oldValue)));
document.body.innerText = 'foo';

observer.observe(document.body.firstChild, { characterDataOldValue: true });

document.body.innerText = 'foo';
document.body.innerText = 'bar';
document.body.firstChild.textContent = 'baz';

// 每次变化都保留了上一次的值
// [&quot;foo&quot;, &quot;foo&quot;, &quot;bar&quot;]
</code></pre></div></li></ol> <ol start="3"><li><p><strong>观察子节点</strong></p> <p><code>MutationObserver</code>可以观察目标节点子节点的添加和移除。要观察子节点，需要在<code>MutationObserverInit</code>对象中将<code>childList</code>属性设置为<code>true</code>。</p> <p>下面的例子演示了添加子节点：</p> <div class="language- extra-class"><pre class="language-text"><code>// 清空主体
document.body.innerHTML = '';

let observer = new MutationObserver(
    (mutationRecords) =&gt; console.log(mutationRecords));

observer.observe(document.body, { childList: true });

document.body.appendChild(document.createElement('div'));

// [
//   {
//     addedNodes: NodeList[div],
//     attributeName: null,
//     attributeNamespace: null,
//     oldValue: null,
//     nextSibling: null,
//     previousSibling: null,
//     removedNodes: NodeList[],
//     target: body,
//     type: &quot;childList&quot;,
//   }
// ]
</code></pre></div><p>下面的例子演示了移除子节点：</p> <div class="language- extra-class"><pre class="language-text"><code>// 清空主体
document.body.innerHTML = '';

let observer = new MutationObserver(
    (mutationRecords) =&gt; console.log(mutationRecords));

observer.observe(document.body, { childList: true });

document.body.appendChild(document.createElement('div'));

// [
//   {
//     addedNodes: NodeList[],
//     attributeName: null,
//     attributeNamespace: null,
//     oldValue: null,
//     nextSibling: null,
//     previousSibling: null,
//     removedNodes: NodeList[div],
//     target: body,
//     type: &quot;childList&quot;,
//   }
// ]
</code></pre></div><p>对子节点<strong>重新排序</strong>（尽管调用一个方法即可实现）会报告两次变化事件，因为从技术上会涉及先移除和再添加：</p> <div class="language- extra-class"><pre class="language-text"><code>// 清空主体
document.body.innerHTML = '';

let observer = new MutationObserver(
    (mutationRecords) =&gt; console.log(mutationRecords));

// 创建两个初始子节点
document.body.appendChild(document.createElement('div'));
document.body.appendChild(document.createElement('span'));

observer.observe(document.body, { childList: true });

// 交换子节点顺序
document.body.insertBefore(document.body.lastChild, document.body.firstChild);

// 发生了两次变化：第一次是节点被移除，第二次是节点被添加
// [
//   {
//     addedNodes: NodeList[],
//     attributeName: null,
//     attributeNamespace: null,
//     oldValue: null,
//     nextSibling: null,
//     previousSibling: div,
//     removedNodes: NodeList[span],
//     target: body,
//       type: childList,
//   },
//   {
//     addedNodes: NodeList[span],
//     attributeName: null,
//     attributeNamespace: null,
//     oldValue: null,
//     nextSibling: div,
//     previousSibling: null,
//     removedNodes: NodeList[],
//     target: body,
//     type: &quot;childList&quot;,
//   }
// ]
</code></pre></div></li></ol> <ol start="4"><li><p><strong>观察子树</strong></p> <p>默认情况下，<code>MutationObserver</code>将观察的范围限定为一个元素及其子节点的变化。可以把观察的范围扩展到这个元素的子树（所有后代节点），这需要在<code>MutationObserverInit</code>对象中将<code>subtree</code>属性设置为<code>true</code>。</p> <p>下面的代码展示了观察元素及其后代节点属性的变化：</p> <div class="language- extra-class"><pre class="language-text"><code>// 清空主体
document.body.innerHTML = '';

let observer = new MutationObserver(
    (mutationRecords) =&gt; console.log(mutationRecords));

// 创建一个后代
document.body.appendChild(document.createElement('div'));

// 观察&lt;body&gt;元素及其子树
observer.observe(document.body, { attributes: true, subtree: true });

// 修改&lt;body&gt;元素的子树
document.body.firstChild.setAttribute('foo', 'bar');

// 记录了子树变化的事件
// [
//   {
//     addedNodes: NodeList[],
//     attributeName: &quot;foo&quot;,
//     attributeNamespace: null,
//     oldValue: null,
//     nextSibling: null,
//     previousSibling: null,
//     removedNodes: NodeList[],
//     target: div,
//     type: &quot;attributes&quot;,
//   }
// ]
</code></pre></div><p>有意思的是，被观察子树中的节点被移出子树之后仍然能够触发变化事件。这意味着在子树中的节点离开该子树后，即使严格来讲该节点已经脱离了原来的子树，但它仍然会触发变化事件。</p> <p>下面的代码演示了这种情况：</p> <div class="language- extra-class"><pre class="language-text"><code>// 清空主体
document.body.innerHTML = '';

let observer = new MutationObserver(
    (mutationRecords) =&gt; console.log(mutationRecords));

let subtreeRoot = document.createElement('div'),
    subtreeLeaf = document.createElement('span');

// 创建包含两层的子树
document.body.appendChild(subtreeRoot);
subtreeRoot.appendChild(subtreeLeaf);

// 观察子树
observer.observe(subtreeRoot, { attributes: true, subtree: true });

// 把节点转移到其他子树
document.body.insertBefore(subtreeLeaf, subtreeRoot);

subtreeLeaf.setAttribute('foo', 'bar');

// 移出的节点仍然触发变化事件
// [MutationRecord]
</code></pre></div></li></ol> <h3 id="_14-3-3-异步回调与记录队列"><a href="#_14-3-3-异步回调与记录队列" class="header-anchor">#</a> 14.3.3 　异步回调与记录队列</h3> <p><code>MutationObserver</code>接口是出于性能考虑而设计的，其核心是异步回调与记录队列模型。为了在大量变化事件发生时不影响性能，每次变化的信息（由观察者实例决定）会保存在<code>MutationRecord</code>实例中，然后添加到<strong>记录队列</strong>。这个队列对每个<code>MutationObserver</code>实例都是唯一的，是所有 DOM 变化事件的有序列表。</p> <ol><li><p><strong>记录队列</strong></p> <p>每次<code>MutationRecord</code>被添加到<code>MutationObserver</code>的记录队列时，仅当之前没有已排期的微任务回调时（队列中微任务长度为 0），才会将观察者注册的回调（在初始化<code>MutationObserver</code>时传入）作为微任务调度到任务队列上。这样可以保证记录队列的内容不会被回调处理两次。</p> <p>不过在回调的微任务异步执行期间，有可能又会发生更多变化事件。因此被调用的回调会接收到一个<code>MutationRecord</code>实例的数组，顺序为它们进入记录队列的顺序。回调要负责处理这个数组的每一个实例，因为函数退出之后这些实现就不存在了。回调执行后，这些<code>MutationRecord</code>就用不着了，因此记录队列会被清空，其内容会被丢弃。</p></li></ol> <ol start="2"><li><p><strong>takeRecords()方法</strong></p> <p>调用<code>MutationObserver</code>实例的<code>takeRecords()</code>方法可以清空记录队列，取出并返回其中的所有<code>MutationRecord</code>实例。看这个例子：</p> <div class="language- extra-class"><pre class="language-text"><code>let observer = new MutationObserver(
    (mutationRecords) =&gt; console.log(mutationRecords));

observer.observe(document.body, { attributes: true });

document.body.className = 'foo';
document.body.className = 'bar';
document.body.className = 'baz';

console.log(observer.takeRecords());
console.log(observer.takeRecords());

// [MutationRecord, MutationRecord, MutationRecord]
// []
</code></pre></div><p>这在希望断开与观察目标的联系，但又希望处理由于调用<code>disconnect()</code>而被抛弃的记录队列中的<code>MutationRecord</code>实例时比较有用。</p></li></ol> <h3 id="_14-3-4-性能、内存与垃圾回收"><a href="#_14-3-4-性能、内存与垃圾回收" class="header-anchor">#</a> 14.3.4 　性能、内存与垃圾回收</h3> <p>DOM Level 2 规范中描述的<code>MutationEvent</code>定义了一组会在各种 DOM 变化时触发的事件。由于浏览器事件的实现机制，这个接口出现了严重的性能问题。因此，DOM Level 3 规定废弃了这些事件。<code>MutationObserver</code>接口就是为替代这些事件而设计的更实用、性能更好的方案。</p> <p>将变化回调委托给微任务来执行可以保证事件同步触发，同时避免随之而来的混乱。为<code>MutationObserver</code>而实现的记录队列，可以保证即使变化事件被爆发式地触发，也不会显著地拖慢浏览器。</p> <p>无论如何，使用<code>MutationObservder</code>仍然<strong>不是没有代价</strong>的。因此理解什么时候避免出现这种情况就很重要了。</p> <ol><li><p><strong>MutationObserver 的引用</strong></p> <p><code>MutationObserver</code>实例与目标节点之间的引用关系是非对称的。<code>MutationObserver</code>拥有对要观察的目标节点的弱引用。因为是弱引用，所以不会妨碍垃圾回收程序回收目标节点。</p> <p>然而，目标节点却拥有对<code>MutationObserver</code>的强引用。如果目标节点从 DOM 中被移除，随后被垃圾回收，则关联的<code>MutationObserver</code>也会被垃圾回收。</p></li></ol> <ol start="2"><li><p><strong>MutationRecord 的引用</strong></p> <p>记录队列中的每个<code>MutationRecord</code>实例至少包含对已有 DOM 节点的一个引用。如果变化是<code>childList</code>类型，则会包含多个节点的引用。记录队列和回调处理的默认行为是耗尽这个队列，处理每个<code>MutationRecord</code>，然后让它们超出作用域并被垃圾回收。</p> <p>有时候可能需要保存某个观察者的完整变化记录。保存这些<code>MutationRecord</code>实例，也就会保存它们引用的节点，因而会妨碍这些节点被回收。如果需要尽快地释放内存，建议从每个<code>MutationRecord</code>中抽取出最有用的信息，然后保存到一个新对象中，最后抛弃<code>MutationRecord</code>。</p></li></ol> <h2 id="_14-4-小结"><a href="#_14-4-小结" class="header-anchor">#</a> 14.4 　小结</h2> <p>文档对象模型（DOM，Document Object Model）是语言中立的 HTML 和 XML 文档的 API。DOM Level 1 将 HTML 和 XML 文档定义为一个节点的多层级结构，并暴露出 JavaScript 接口以操作文档的底层结构和外观。</p> <p>DOM 由一系列节点类型构成，主要包括以下几种。</p> <ul><li><code>Node</code>是基准节点类型，是文档一个部分的抽象表示，所有其他类型都继承<code>Node</code>。</li> <li><code>Document</code>类型表示整个文档，对应树形结构的根节点。在 JavaScript 中，<code>document</code>对象是<code>Document</code>的实例，拥有查询和获取节点的很多方法。</li> <li><code>Element</code>节点表示文档中所有 HTML 或 XML 元素，可以用来操作它们的内容和属性。</li> <li>其他节点类型分别表示文本内容、注释、文档类型、CDATA 区块和文档片段。</li></ul> <p>DOM 编程在多数情况下没什么问题，在涉及<code>&lt;script&gt;</code>和<code>&lt;style&gt;</code>元素时会有一点兼容性问题。因为这些元素分别包含脚本和样式信息，所以浏览器会将它们与其他元素区别对待。</p> <p>要理解 DOM，最关键的一点是知道影响其性能的问题所在。DOM 操作在 JavaScript 代码中是代价比较高的，<code>NodeList</code>对象尤其需要注意。<code>NodeList</code>对象是“实时更新”的，这意味着每次访问它都会执行一次新的查询。考虑到这些问题，实践中要尽量减少 DOM 操作的数量。</p> <p><code>MutationObserver</code>是为代替性能不好的<code>MutationEvent</code>而问世的。使用它可以有效精准地监控 DOM 变化，而且 API 也相对简单。</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">11/16/2020, 3:12:43 AM</span></div></footer> <!----> </main></div><div class="global-ui"><!----><!----></div></div>
    <script src="/VuePressBlogHtml/assets/js/app.a22e24ce.js" defer></script><script src="/VuePressBlogHtml/assets/js/2.273354d5.js" defer></script><script src="/VuePressBlogHtml/assets/js/15.622f6d38.js" defer></script><script src="/VuePressBlogHtml/assets/js/17.398b5375.js" defer></script>
  </body>
</html>
