<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>第 5 章　基本引用类型 | Hertz&#39;s Blog</title>
    <meta name="generator" content="VuePress 1.7.1">
    
    <meta name="description" content="Hertz's Blog By VuePress">
    
    <link rel="preload" href="/VuePressBlogHtml/assets/css/0.styles.7994d51b.css" as="style"><link rel="preload" href="/VuePressBlogHtml/assets/js/app.a22e24ce.js" as="script"><link rel="preload" href="/VuePressBlogHtml/assets/js/2.273354d5.js" as="script"><link rel="preload" href="/VuePressBlogHtml/assets/js/54.d2f28937.js" as="script"><link rel="preload" href="/VuePressBlogHtml/assets/js/17.398b5375.js" as="script"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/10.2906bcb7.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/11.44da5627.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/12.603be071.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/13.bbb59baa.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/14.37104393.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/15.622f6d38.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/16.e98dda23.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/18.87fb9473.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/19.35af09b5.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/20.0860f27f.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/21.80170eb6.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/22.32e3b412.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/23.71a3bc07.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/24.92a37d9c.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/25.6c06b0ec.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/26.56de950a.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/27.389f6e4c.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/28.93cf295c.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/29.8299c662.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/3.82a8b2ed.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/30.030ded92.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/31.37328e23.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/32.33720530.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/33.dbf791bd.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/34.3f59d278.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/35.4db82d0c.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/36.993714ab.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/37.d14d1abc.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/38.5d2531bd.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/39.04716fa1.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/4.89240616.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/40.af165ce2.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/41.be41ee81.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/42.9d0cef92.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/43.d679c459.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/44.d12455da.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/45.50996042.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/46.4ae0dc93.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/47.297e0925.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/48.0b5098bb.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/49.2331b452.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/5.7f54006c.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/50.ed621c31.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/51.ffa15a18.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/52.f023092e.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/53.dcf36f26.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/55.8d4c4343.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/56.bf7841ef.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/57.0cf87538.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/58.a33d519a.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/59.100761af.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/6.583fbbc7.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/60.2547a25b.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/61.0a622c79.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/62.8bdae0f0.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/63.ae32cec9.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/64.3f841214.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/65.9967bc83.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/66.2b33b58e.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/67.5183b069.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/68.ac765712.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/69.278cdc53.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/7.d3e576f7.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/70.1f5428d0.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/71.44ee8fdb.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/72.4c087926.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/73.2c3e7645.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/74.e2a67ac9.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/8.d70fcbe5.js"><link rel="prefetch" href="/VuePressBlogHtml/assets/js/9.59956eee.js">
    <link rel="stylesheet" href="/VuePressBlogHtml/assets/css/0.styles.7994d51b.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/VuePressBlogHtml/" class="home-link router-link-active"><!----> <span class="site-name">Hertz's Blog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/VuePressBlogHtml/FrontEnd/" class="nav-link router-link-active">
  前端
</a></div><div class="nav-item"><a href="/VuePressBlogHtml/BackEnd/" class="nav-link">
  后端
</a></div><div class="nav-item"><a href="/VuePressBlogHtml/GIS/" class="nav-link">
  GIS
</a></div><div class="nav-item"><a href="/VuePressBlogHtml/Others/" class="nav-link">
  其他
</a></div><div class="nav-item"><a href="https://github.com/Hertz9409" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/VuePressBlogHtml/FrontEnd/" class="nav-link router-link-active">
  前端
</a></div><div class="nav-item"><a href="/VuePressBlogHtml/BackEnd/" class="nav-link">
  后端
</a></div><div class="nav-item"><a href="/VuePressBlogHtml/GIS/" class="nav-link">
  GIS
</a></div><div class="nav-item"><a href="/VuePressBlogHtml/Others/" class="nav-link">
  其他
</a></div><div class="nav-item"><a href="https://github.com/Hertz9409" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>CSS</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/VuePressBlogHtml/FrontEnd/CSS/CSS1/" class="sidebar-link">CSS1</a></li><li><a href="/VuePressBlogHtml/FrontEnd/CSS/CSS2/" class="sidebar-link">CSS2</a></li><li><a href="/VuePressBlogHtml/FrontEnd/CSS/CSS%E5%8F%98%E6%8D%A2,%E8%BF%87%E6%B8%A1,%E5%8A%A8%E7%94%BB/" class="sidebar-link">CSS变换,过渡,动画</a></li><li><a href="/VuePressBlogHtml/FrontEnd/CSS/CSS%E5%B1%82%E5%8F%A0%E6%80%A7/" class="sidebar-link">CSS层叠性</a></li><li><a href="/VuePressBlogHtml/FrontEnd/CSS/CSS%E6%96%87%E6%9C%AC%E6%A0%B7%E5%BC%8F/" class="sidebar-link">CSS文本样式</a></li><li><a href="/VuePressBlogHtml/FrontEnd/CSS/CSS%E6%B5%81/" class="sidebar-link">CSS流</a></li><li><a href="/VuePressBlogHtml/FrontEnd/CSS/CSS%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/" class="sidebar-link">CSS经典面试题</a></li><li><a href="/VuePressBlogHtml/FrontEnd/CSS/Flex%E5%B8%83%E5%B1%80/" class="sidebar-link">Flex布局</a></li><li><a href="/VuePressBlogHtml/FrontEnd/CSS/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D/" class="sidebar-link">移动端适配</a></li><li><a href="/VuePressBlogHtml/FrontEnd/CSS/%E9%A2%9C%E8%89%B2%E4%B8%8E%E8%83%8C%E6%99%AF/" class="sidebar-link">颜色与背景</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>HTML</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/VuePressBlogHtml/FrontEnd/HTML/%E9%A1%B5%E9%9D%A2%E7%BB%93%E6%9E%84%E8%AF%AD%E4%B9%89%E5%8C%96/" class="sidebar-link">页面结构语义化</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>JS</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/VuePressBlogHtml/FrontEnd/JS/Canvas%E5%9F%BA%E7%A1%80%E4%B8%80/" class="sidebar-link">Canvas基础一</a></li><li><a href="/VuePressBlogHtml/FrontEnd/JS/Canvas%E5%9F%BA%E7%A1%80%E4%BA%8C/" class="sidebar-link">Canvas基础二</a></li><li><a href="/VuePressBlogHtml/FrontEnd/JS/Cookie,Session,Token,Oauth%E5%92%8CJWT/" class="sidebar-link">Cookie,Session,Token,Oauth和JWT</a></li><li><a href="/VuePressBlogHtml/FrontEnd/JS/Echarts%E7%AE%80%E4%BB%8B/" class="sidebar-link">Echarts简介</a></li><li><a href="/VuePressBlogHtml/FrontEnd/JS/Event%20Loop/" class="sidebar-link">Event Loop</a></li><li><a href="/VuePressBlogHtml/FrontEnd/JS/JavaScript%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E3%80%81%E9%97%AD%E5%8C%85/" class="sidebar-link">JavaScript执行上下文、作用域链、闭包</a></li><li><a href="/VuePressBlogHtml/FrontEnd/JS/Promise/" class="sidebar-link">Promise</a></li><li><a href="/VuePressBlogHtml/FrontEnd/JS/Web%20Workers/" class="sidebar-link">Web Workers</a></li><li><a href="/VuePressBlogHtml/FrontEnd/JS/this%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB/" class="sidebar-link">this知识汇总</a></li><li><a href="/VuePressBlogHtml/FrontEnd/JS/%E4%BA%8B%E4%BB%B6%E6%8D%95%E8%8E%B7%E5%92%8C%E5%86%92%E6%B3%A1/" class="sidebar-link">事件捕获和冒泡</a></li><li><a href="/VuePressBlogHtml/FrontEnd/JS/%E5%87%BD%E6%95%B0%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/" class="sidebar-link">函数防抖和节流</a></li><li><a href="/VuePressBlogHtml/FrontEnd/JS/%E5%89%8D%E7%AB%AF%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE/" class="sidebar-link">前端浏览器本地存储数据</a></li><li><a href="/VuePressBlogHtml/FrontEnd/JS/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E7%BB%A7%E6%89%BF/" class="sidebar-link">原型与继承</a></li><li><a href="/VuePressBlogHtml/FrontEnd/JS/%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0/" class="sidebar-link">断点续传</a></li><li><a href="/VuePressBlogHtml/FrontEnd/JS/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%9F%BA%E7%A1%80/" class="sidebar-link">正则表达式基础</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>JS高级程序设计-第四版</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/VuePressBlogHtml/FrontEnd/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E7%AC%AC%E5%9B%9B%E7%89%88/1.%E4%BB%80%E4%B9%88%E6%98%AFJavaScript/" class="sidebar-link">1.什么是JavaScript</a></li><li><a href="/VuePressBlogHtml/FrontEnd/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E7%AC%AC%E5%9B%9B%E7%89%88/10.%E5%87%BD%E6%95%B0/" class="sidebar-link">10.函数</a></li><li><a href="/VuePressBlogHtml/FrontEnd/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E7%AC%AC%E5%9B%9B%E7%89%88/11.%E6%9C%9F%E7%BA%A6%E4%B8%8E%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0/" class="sidebar-link">11.期约与异步函数</a></li><li><a href="/VuePressBlogHtml/FrontEnd/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E7%AC%AC%E5%9B%9B%E7%89%88/12.BOM/" class="sidebar-link">12.BOM</a></li><li><a href="/VuePressBlogHtml/FrontEnd/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E7%AC%AC%E5%9B%9B%E7%89%88/13.%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%A3%80%E6%B5%8B/" class="sidebar-link">13.客户端检测</a></li><li><a href="/VuePressBlogHtml/FrontEnd/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E7%AC%AC%E5%9B%9B%E7%89%88/14.DOM/" class="sidebar-link">14.DOM</a></li><li><a href="/VuePressBlogHtml/FrontEnd/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E7%AC%AC%E5%9B%9B%E7%89%88/15.DOM%E6%89%A9%E5%B1%95/" class="sidebar-link">15.DOM扩展</a></li><li><a href="/VuePressBlogHtml/FrontEnd/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E7%AC%AC%E5%9B%9B%E7%89%88/2HTML%E4%B8%AD%E7%9A%84JavaScript/" class="sidebar-link">2HTML中的JavaScript</a></li><li><a href="/VuePressBlogHtml/FrontEnd/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E7%AC%AC%E5%9B%9B%E7%89%88/3.%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/" class="sidebar-link">3.语言基础</a></li><li><a href="/VuePressBlogHtml/FrontEnd/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E7%AC%AC%E5%9B%9B%E7%89%88/4.%E5%8F%98%E9%87%8F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98/" class="sidebar-link">4.变量、作用域与内存</a></li><li><a href="/VuePressBlogHtml/FrontEnd/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E7%AC%AC%E5%9B%9B%E7%89%88/5.%E5%9F%BA%E6%9C%AC%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/" aria-current="page" class="active sidebar-link">5.基本引用类型</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/VuePressBlogHtml/FrontEnd/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E7%AC%AC%E5%9B%9B%E7%89%88/5.%E5%9F%BA%E6%9C%AC%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/#第-5-章-基本引用类型" class="sidebar-link">第 5 章　基本引用类型</a></li><li class="sidebar-sub-header"><a href="/VuePressBlogHtml/FrontEnd/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E7%AC%AC%E5%9B%9B%E7%89%88/5.%E5%9F%BA%E6%9C%AC%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/#_5-1-date" class="sidebar-link">5.1 　 Date</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/VuePressBlogHtml/FrontEnd/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E7%AC%AC%E5%9B%9B%E7%89%88/5.%E5%9F%BA%E6%9C%AC%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/#_5-1-1-继承的方法" class="sidebar-link">5.1.1 　继承的方法</a></li><li class="sidebar-sub-header"><a href="/VuePressBlogHtml/FrontEnd/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E7%AC%AC%E5%9B%9B%E7%89%88/5.%E5%9F%BA%E6%9C%AC%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/#_5-1-2-日期格式化方法" class="sidebar-link">5.1.2 　日期格式化方法</a></li><li class="sidebar-sub-header"><a href="/VuePressBlogHtml/FrontEnd/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E7%AC%AC%E5%9B%9B%E7%89%88/5.%E5%9F%BA%E6%9C%AC%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/#_5-1-3-日期-时间组件方法" class="sidebar-link">5.1.3 　日期/时间组件方法</a></li></ul></li><li class="sidebar-sub-header"><a href="/VuePressBlogHtml/FrontEnd/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E7%AC%AC%E5%9B%9B%E7%89%88/5.%E5%9F%BA%E6%9C%AC%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/#_5-2-regexp" class="sidebar-link">5.2 　 RegExp</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/VuePressBlogHtml/FrontEnd/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E7%AC%AC%E5%9B%9B%E7%89%88/5.%E5%9F%BA%E6%9C%AC%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/#_5-2-1-regexp实例属性" class="sidebar-link">5.2.1 　RegExp实例属性</a></li><li class="sidebar-sub-header"><a href="/VuePressBlogHtml/FrontEnd/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E7%AC%AC%E5%9B%9B%E7%89%88/5.%E5%9F%BA%E6%9C%AC%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/#_5-2-2-regexp实例方法" class="sidebar-link">5.2.2 　RegExp实例方法</a></li><li class="sidebar-sub-header"><a href="/VuePressBlogHtml/FrontEnd/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E7%AC%AC%E5%9B%9B%E7%89%88/5.%E5%9F%BA%E6%9C%AC%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/#_5-2-3-regexp构造函数属性" class="sidebar-link">5.2.3 　RegExp构造函数属性</a></li><li class="sidebar-sub-header"><a href="/VuePressBlogHtml/FrontEnd/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E7%AC%AC%E5%9B%9B%E7%89%88/5.%E5%9F%BA%E6%9C%AC%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/#_5-2-4-模式局限" class="sidebar-link">5.2.4 　模式局限</a></li></ul></li><li class="sidebar-sub-header"><a href="/VuePressBlogHtml/FrontEnd/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E7%AC%AC%E5%9B%9B%E7%89%88/5.%E5%9F%BA%E6%9C%AC%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/#_5-3-原始值包装类型" class="sidebar-link">5.3 　原始值包装类型</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/VuePressBlogHtml/FrontEnd/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E7%AC%AC%E5%9B%9B%E7%89%88/5.%E5%9F%BA%E6%9C%AC%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/#_5-3-1-boolean" class="sidebar-link">5.3.1 　Boolean</a></li><li class="sidebar-sub-header"><a href="/VuePressBlogHtml/FrontEnd/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E7%AC%AC%E5%9B%9B%E7%89%88/5.%E5%9F%BA%E6%9C%AC%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/#_5-3-2-number" class="sidebar-link">5.3.2 　Number</a></li><li class="sidebar-sub-header"><a href="/VuePressBlogHtml/FrontEnd/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E7%AC%AC%E5%9B%9B%E7%89%88/5.%E5%9F%BA%E6%9C%AC%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/#_5-3-3-string" class="sidebar-link">5.3.3 　String</a></li></ul></li><li class="sidebar-sub-header"><a href="/VuePressBlogHtml/FrontEnd/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E7%AC%AC%E5%9B%9B%E7%89%88/5.%E5%9F%BA%E6%9C%AC%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/#_5-4-单例内置对象" class="sidebar-link">5.4 　单例内置对象</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/VuePressBlogHtml/FrontEnd/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E7%AC%AC%E5%9B%9B%E7%89%88/5.%E5%9F%BA%E6%9C%AC%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/#_5-4-1-global" class="sidebar-link">5.4.1 　Global</a></li><li class="sidebar-sub-header"><a href="/VuePressBlogHtml/FrontEnd/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E7%AC%AC%E5%9B%9B%E7%89%88/5.%E5%9F%BA%E6%9C%AC%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/#_5-4-2-math" class="sidebar-link">5.4.2 　Math</a></li></ul></li><li class="sidebar-sub-header"><a href="/VuePressBlogHtml/FrontEnd/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E7%AC%AC%E5%9B%9B%E7%89%88/5.%E5%9F%BA%E6%9C%AC%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/#_5-5-小结" class="sidebar-link">5.5 　小结</a></li></ul></li><li><a href="/VuePressBlogHtml/FrontEnd/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E7%AC%AC%E5%9B%9B%E7%89%88/6.%E9%9B%86%E5%90%88%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/" class="sidebar-link">6.集合引用类型</a></li><li><a href="/VuePressBlogHtml/FrontEnd/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E7%AC%AC%E5%9B%9B%E7%89%88/7.%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8/" class="sidebar-link">7.迭代器与生成器</a></li><li><a href="/VuePressBlogHtml/FrontEnd/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E7%AC%AC%E5%9B%9B%E7%89%88/8.%E5%AF%B9%E8%B1%A1%E3%80%81%E7%B1%BB%E4%B8%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/" class="sidebar-link">8.对象、类与面向对象编程</a></li><li><a href="/VuePressBlogHtml/FrontEnd/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E7%AC%AC%E5%9B%9B%E7%89%88/9.%E4%BB%A3%E7%90%86%E4%B8%8E%E5%8F%8D%E5%B0%84/" class="sidebar-link">9.代理与反射</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>VUE</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/VuePressBlogHtml/FrontEnd/VUE/My-Vue-Study-1/" class="sidebar-link">My-Vue-Study-1</a></li><li><a href="/VuePressBlogHtml/FrontEnd/VUE/My-Vue-Study-2/" class="sidebar-link">My-Vue-Study-2</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>其他</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/VuePressBlogHtml/FrontEnd/%E5%85%B6%E4%BB%96/Https%E4%BB%A5%E5%8F%8A%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/" class="sidebar-link">Https以及前端安全</a></li><li><a href="/VuePressBlogHtml/FrontEnd/%E5%85%B6%E4%BB%96/http%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/" class="sidebar-link">http缓存机制</a></li><li><a href="/VuePressBlogHtml/FrontEnd/%E5%85%B6%E4%BB%96/%E4%BB%8E%E8%BE%93%E5%85%A5url%E5%88%B0%E7%95%8C%E9%9D%A2%E5%B1%95%E7%A4%BA/" class="sidebar-link">从输入url到界面展示</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>前端工程化</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/VuePressBlogHtml/FrontEnd/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/WebPack%E5%9F%BA%E7%A1%80/" class="sidebar-link">WebPack基础</a></li><li><a href="/VuePressBlogHtml/FrontEnd/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/%E5%8E%86%E5%8F%B2%E8%BF%9B%E7%A8%8B/" class="sidebar-link">历史进程</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="第-5-章-基本引用类型"><a href="#第-5-章-基本引用类型" class="header-anchor">#</a> 第 5 章　基本引用类型</h2> <blockquote><p><strong>本章内容</strong></p> <ul><li>理解对象</li> <li>基本 JavaScript 数据类型</li> <li>原始值与原始值包装类型</li></ul></blockquote> <p>引用值（或者对象）是某个特定<strong>引用类型</strong>的实例。在 ECMAScript 中，引用类型是把数据和功能组织到一起的结构，经常被人错误地称作“类”。虽然从技术上讲 JavaScript 是一门面向对象语言，但 ECMAScript 缺少传统的面向对象编程语言所具备的某些基本结构，包括类和接口。引用类型有时候也被称为<strong>对象定义</strong>，因为它们描述了自己的对象应有的属性和方法。</p> <blockquote><p><strong>注意</strong>　引用类型虽然有点像类，但跟类并不是一个概念。为避免混淆，本章后面不会使用术语“类”。</p></blockquote> <p>对象被认为是某个特定引用类型的<strong>实例</strong>。新对象通过使用<code>new</code>操作符后跟一个<strong>构造函数</strong>（constructor）来创建。构造函数就是用来创建新对象的函数，比如下面这行代码：</p> <div class="language- extra-class"><pre class="language-text"><code>let now = new Date();
</code></pre></div><p>这行代码创建了引用类型<code>Date</code>的一个新实例，并将它保存在变量<code>now</code>中。<code>Date()</code>在这里就是构造函数，它负责创建一个只有默认属性和方法的简单对象。ECMAScript 提供了很多像<code>Date</code>这样的原生引用类型，帮助开发者实现常见的任务。</p> <blockquote><p><strong>注意</strong>　函数也是一种引用类型，但有关函数的内容太多了，一章放不下，所以本书专门用第 10 章来介绍函数。</p></blockquote> <h2 id="_5-1-date"><a href="#_5-1-date" class="header-anchor">#</a> 5.1 　 Date</h2> <p>ECMAScript 的<code>Date</code>类型参考了 Java 早期版本中的<code>java.util.Date</code>。为此，<code>Date</code>类型将日期保存为自协调世界时（UTC，Universal Time Coordinated）时间 1970 年 1 月 1 日午夜（零时）至今所经过的毫秒数。使用这种存储格式，<code>Date</code>类型可以精确表示 1970 年 1 月 1 日之前及之后 285 616 年的日期。</p> <p>要创建日期对象，就使用<code>new</code>操作符来调用<code>Date</code>构造函数：</p> <div class="language- extra-class"><pre class="language-text"><code>let now = new Date();
</code></pre></div><p>在不给<code>Date</code>构造函数传参数的情况下，创建的对象将保存当前日期和时间。要基于其他日期和时间创建日期对象，必须传入其毫秒表示（UNIX 纪元 1970 年 1 月 1 日午夜之后的毫秒数）。ECMAScript 为此提供了两个辅助方法：<code>Date.parse()</code>和<code>Date.UTC()</code>。</p> <p><code>Date.parse()</code>方法接收一个表示日期的字符串参数，尝试将这个字符串转换为表示该日期的毫秒数。ECMA-262 第 5 版定义了<code>Date.parse()</code>应该支持的日期格式，填充了第 3 版遗留的空白。所有实现都必须支持下列日期格式：</p> <ul><li>“月/日/年”，如<code>&quot;5/23/2019&quot;</code>；</li> <li>“月名 日, 年”，如<code>&quot;May 23, 2019&quot;</code>；</li> <li>“周几 月名 日 年 时:分:秒 时区”，如<code>&quot;Tue May 23 2019 00:00:00 GMT-0700&quot;</code>；</li> <li>ISO 8601 扩展格式“YYYY-MM-DDTHH:mm:ss.sssZ”，如<code>2019-05-23T00:00:00</code>（只适用于兼容 ES5 的实现）。</li></ul> <p>比如，要创建一个表示“2019 年 5 月 23 日”的日期对象，可以使用以下代码：</p> <div class="language- extra-class"><pre class="language-text"><code>let someDate = new Date(Date.parse(&quot;May 23, 2019&quot;));
</code></pre></div><p>如果传给<code>Date.parse()</code>的字符串并不表示日期，则该方法会返回<code>NaN</code>。如果直接把表示日期的字符串传给<code>Date</code>构造函数，那么<code>Date</code>会在后台调用<code>Date.parse()</code>。换句话说，下面这行代码跟前面那行代码是等价的：</p> <div class="language- extra-class"><pre class="language-text"><code>let someDate = new Date(&quot;May 23, 2019&quot;);
</code></pre></div><p>这两行代码得到的日期对象相同。</p> <blockquote><p><strong>注意</strong>　不同的浏览器对<code>Date</code>类型的实现有很多问题。比如，很多浏览器会选择用当前日期替代越界的日期，因此有些浏览器会将<code>&quot;January 32, 2019&quot;</code>解释为<code>&quot;February 1, 2019&quot;</code>。Opera 则会插入当前月的当前日，返回<code>&quot;January 当前日, 2019&quot;</code>。就是说，如果是在 9 月 21 日运行代码，会返回<code>&quot;January 21, 2019&quot;</code>。</p></blockquote> <p><code>Date.UTC()</code>方法也返回日期的毫秒表示，但使用的是跟<code>Date.parse()</code>不同的信息来生成这个值。传给<code>Date.UTC()</code>的参数是年、零起点月数（1 月是 0，2 月是 1，以此类推）、日（1~31）、时（0~23）、分、秒和毫秒。这些参数中，只有前两个（年和月）是必需的。如果不提供日，那么默认为 1 日。其他参数的默认值都是 0。下面是使用<code>Date.UTC()</code>的两个例子：</p> <div class="language- extra-class"><pre class="language-text"><code>// GMT时间2000年1月1日零点
let y2k = new Date(Date.UTC(2000, 0));

// GMT时间2005年5月5日下午5点55分55秒
let allFives = new Date(Date.UTC(2005, 4, 5, 17, 55, 55));
</code></pre></div><p>这个例子创建了两个日期 。第一个日期是 2000 年 1 月 1 日零点（GMT），<code>2000</code>代表年，<code>0</code>代表月（1 月）。因为没有其他参数（日取<code>1</code>，其他取<code>0</code>），所以结果就是该月第 1 天零点。第二个日期表示 2005 年 5 月 5 日下午 5 点 55 分 55 秒（GMT）。虽然日期里面涉及的都是 5，但月数必须用<code>4</code>，因为月数是零起点的。小时也必须是 17，因为这里采用的是 24 小时制，即取值范围是 0~23。其他参数就都很直观了。</p> <p>与<code>Date.parse()</code>一样，<code>Date.UTC()</code>也会被<code>Date</code>构造函数隐式调用，但有一个区别：这种情况下创建的是本地日期，不是 GMT 日期。不过<code>Date</code>构造函数跟<code>Date.UTC()</code>接收的参数是一样的。因此，如果第一个参数是数值，则构造函数假设它是日期中的年，第二个参数就是月，以此类推。前面的例子也可以这样来写：</p> <div class="language- extra-class"><pre class="language-text"><code>// 本地时间2000年1月1日零点
let y2k = new Date(2000, 0);

// 本地时间2005年5月5日下午5点55分55秒
let allFives = new Date(2005, 4, 5, 17, 55, 55);
</code></pre></div><p>以上代码创建了与前面例子中相同的两个日期，但这次的两个日期是（由于系统设置决定的）本地时区的日期。</p> <p>ECMAScript 还提供了<code>Date.now()</code>方法，返回表示方法执行时日期和时间的毫秒数。这个方法可以方便地用在代码分析中：</p> <div class="language- extra-class"><pre class="language-text"><code>// 起始时间
let start = Date.now();

// 调用函数
doSomething();

// 结束时间
let stop = Date.now(),
  result = stop - start;
</code></pre></div><h3 id="_5-1-1-继承的方法"><a href="#_5-1-1-继承的方法" class="header-anchor">#</a> 5.1.1 　继承的方法</h3> <p>与其他类型一样，<code>Date</code>类型重写了<code>toLocaleString()</code>、<code>toString()</code>和<code>valueOf()</code>方法。但与其他类型不同，重写后这些方法的返回值不一样。<code>Date</code>类型的<code>toLocaleString()</code>方法返回与浏览器运行的本地环境一致的日期和时间。这通常意味着格式中包含针对时间的 AM（上午）或 PM（下午），但不包含时区信息（具体格式可能因浏览器而不同）。<code>toString()</code>方法通常返回带时区信息的日期和时间，而时间也是以 24 小时制（0~23）表示的。下面给出了<code>toLocaleString()</code>和<code>toString()</code>返回的 2019 年 2 月 1 日零点的示例（地区为<code>&quot;en-US&quot;</code>的 PST，即 Pacific Standard Time，太平洋标准时间）：</p> <div class="language- extra-class"><pre class="language-text"><code>toLocaleString() - 2/1/2019 12:00:00 AM

toString() - Thu Feb 1 2019 00:00:00 GMT-0800 (Pacific Standard Time)
</code></pre></div><p>现代浏览器在这两个方法的输出上已经趋于一致。在比较老的浏览器上，每个方法返回的结果可能在每个浏览器上都是不同的。这些差异意味着<code>toLocaleString()</code>和<code>toString()</code>可能只对调试有用，不能用于显示。</p> <p><code>Date</code>类型的<code>valueOf()</code>方法根本就不返回字符串，这个方法被重写后返回的是日期的毫秒表示。因此，操作符（如小于号和大于号）可以直接使用它返回的值。比如下面的例子：</p> <div class="language- extra-class"><pre class="language-text"><code>let date1 = new Date(2019, 0, 1);    // 2019年1月1日
let date2 = new Date(2019, 1, 1);    // 2019年2月1日

console.log(date1 &lt; date2); // true
console.log(date1 &gt; date2); // false
</code></pre></div><p>日期 2019 年 1 月 1 日在 2019 年 2 月 1 日之前，所以说前者小于后者没问题。因为 2019 年 1 月 1 日的毫秒表示小于 2019 年 2 月 1 日的毫秒表示，所以用小于号比较这两个日期时会返回<code>true</code>。这也是确保日期先后的一个简单方式。</p> <h3 id="_5-1-2-日期格式化方法"><a href="#_5-1-2-日期格式化方法" class="header-anchor">#</a> 5.1.2 　日期格式化方法</h3> <p><code>Date</code>类型有几个专门用于格式化日期的方法，它们都会返回字符串：</p> <ul><li><code>toDateString()</code>显示日期中的周几、月、日、年（格式特定于实现）；</li> <li><code>toTimeString()</code>显示日期中的时、分、秒和时区（格式特定于实现）；</li> <li><code>toLocaleDateString()</code>显示日期中的周几、月、日、年（格式特定于实现和地区）；</li> <li><code>toLocaleTimeString()</code>显示日期中的时、分、秒（格式特定于实现）；</li> <li><code>toUTCString()</code>显示完整的 UTC 日期（格式特定于实现）。</li></ul> <p>这些方法的输出与<code>toLocaleString()</code>和<code>toString()</code>一样，会因浏览器而异。因此不能用于在用户界面上一致地显示日期。</p> <blockquote><p><strong>注意</strong>　还有一个方法叫<code>toGMTString()</code>，这个方法跟<code>toUTCString()</code>是一样的，目的是为了向后兼容。不过，规范建议新代码使用<code>toUTCString()</code>。</p></blockquote> <h3 id="_5-1-3-日期-时间组件方法"><a href="#_5-1-3-日期-时间组件方法" class="header-anchor">#</a> 5.1.3 　日期/时间组件方法</h3> <p><code>Date</code>类型剩下的方法（见下表）直接涉及取得或设置日期值的特定部分。注意表中“UTC 日期”，指的是没有时区偏移（将日期转换为 GMT）时的日期。</p> <table><thead><tr><th style="text-align:left;">方法</th> <th style="text-align:left;">说明</th></tr></thead> <tbody><tr><td style="text-align:left;"><code>getTime()</code></td> <td style="text-align:left;">返回日期的毫秒表示；与<code>valueOf()</code>相同</td></tr> <tr><td style="text-align:left;"><code>setTime(*milliseconds*)</code></td> <td style="text-align:left;">设置日期的毫秒表示，从而修改整个日期</td></tr> <tr><td style="text-align:left;"><code>getFullYear()</code></td> <td style="text-align:left;">返回 4 位数年（即 2019 而不是 19）</td></tr> <tr><td style="text-align:left;"><code>getUTCFullYear()</code></td> <td style="text-align:left;">返回 UTC 日期的 4 位数年</td></tr> <tr><td style="text-align:left;"><code>setFullYear(*year*)</code></td> <td style="text-align:left;">设置日期的年（<code>*year*</code>必须是 4 位数）</td></tr> <tr><td style="text-align:left;"><code>setUTCFullYear(*year*)</code></td> <td style="text-align:left;">设置 UTC 日期的年（<code>*year*</code>必须是 4 位数）</td></tr> <tr><td style="text-align:left;"><code>getMonth()</code></td> <td style="text-align:left;">返回日期的月（0 表示 1 月，11 表示 12 月）</td></tr> <tr><td style="text-align:left;"><code>getUTCMonth()</code></td> <td style="text-align:left;">返回 UTC 日期的月（0 表示 1 月，11 表示 12 月）</td></tr> <tr><td style="text-align:left;"><code>setMonth(*month*)</code></td> <td style="text-align:left;">设置日期的月（<code>*month*</code>为大于 0 的数值，大于 11 加年）</td></tr> <tr><td style="text-align:left;"><code>setUTCMonth(*month*)</code></td> <td style="text-align:left;">设置 UTC 日期的月（<code>*month*</code>为大于 0 的数值，大于 11 加年）</td></tr> <tr><td style="text-align:left;"><code>getDate()</code></td> <td style="text-align:left;">返回日期中的日（1~31）</td></tr> <tr><td style="text-align:left;"><code>getUTCDate()</code></td> <td style="text-align:left;">返回 UTC 日期中的日（1~31）</td></tr> <tr><td style="text-align:left;"><code>setDate(*date*)</code></td> <td style="text-align:left;">设置日期中的日（如果<code>*date*</code>大于该月天数，则加月）</td></tr> <tr><td style="text-align:left;"><code>setUTCDate(*date*)</code></td> <td style="text-align:left;">设置 UTC 日期中的日（如果<code>*date*</code>大于该月天数，则加月）</td></tr> <tr><td style="text-align:left;"><code>getDay()</code></td> <td style="text-align:left;">返回日期中表示周几的数值（0 表示周日，6 表示周六）</td></tr> <tr><td style="text-align:left;"><code>getUTCDay()</code></td> <td style="text-align:left;">返回 UTC 日期中表示周几的数值（0 表示周日，6 表示周六）</td></tr> <tr><td style="text-align:left;"><code>getHours()</code></td> <td style="text-align:left;">返回日期中的时（0~23）</td></tr> <tr><td style="text-align:left;"><code>getUTCHours()</code></td> <td style="text-align:left;">返回 UTC 日期中的时（0~23）</td></tr> <tr><td style="text-align:left;"><code>setHours(*hours*)</code></td> <td style="text-align:left;">设置日期中的时（如果<code>*hours*</code>大于 23，则加日）</td></tr> <tr><td style="text-align:left;"><code>setUTCHours(*hours*)</code></td> <td style="text-align:left;">设置 UTC 日期中的时（如果<code>*hours*</code>大于 23，则加日）</td></tr> <tr><td style="text-align:left;"><code>getMinutes()</code></td> <td style="text-align:left;">返回日期中的分（0~59）</td></tr> <tr><td style="text-align:left;"><code>getUTCMinutes()</code></td> <td style="text-align:left;">返回 UTC 日期中的分（0~59）</td></tr> <tr><td style="text-align:left;"><code>setMinutes(*minutes*)</code></td> <td style="text-align:left;">设置日期中的分（如果<code>*minutes*</code>大于 59，则加时）</td></tr> <tr><td style="text-align:left;"><code>setUTCMinutes(*minutes*)</code></td> <td style="text-align:left;">设置 UTC 日期中的分（如果<code>*minutes*</code>大于 59，则加时）</td></tr> <tr><td style="text-align:left;"><code>getSeconds()</code></td> <td style="text-align:left;">返回日期中的秒（0~59）</td></tr> <tr><td style="text-align:left;"><code>getUTCSeconds()</code></td> <td style="text-align:left;">返回 UTC 日期中的秒（0~59）</td></tr> <tr><td style="text-align:left;"><code>setSeconds(*seconds*)</code></td> <td style="text-align:left;">设置日期中的秒（如果<code>*seconds*</code>大于 59，则加分）</td></tr> <tr><td style="text-align:left;"><code>setUTCSeconds(*seconds*)</code></td> <td style="text-align:left;">设置 UTC 日期中的秒（如果<code>*seconds*</code>大于 59，则加分）</td></tr> <tr><td style="text-align:left;"><code>getMilliseconds()</code></td> <td style="text-align:left;">返回日期中的毫秒</td></tr> <tr><td style="text-align:left;"><code>getUTCMilliseconds()</code></td> <td style="text-align:left;">返回 UTC 日期中的毫秒</td></tr> <tr><td style="text-align:left;"><code>setMilliseconds(*milliseconds*)</code></td> <td style="text-align:left;">设置日期中的毫秒</td></tr> <tr><td style="text-align:left;"><code>setUTCMilliseconds(*milliseconds*)</code></td> <td style="text-align:left;">设置 UTC 日期中的毫秒</td></tr> <tr><td style="text-align:left;"><code>getTimezoneOffset()</code></td> <td style="text-align:left;">返回以分钟计的 UTC 与本地时区的偏移量（如美国 EST 即“东部标准时间”返回 300，进入夏令时的地区可能有所差异）</td></tr></tbody></table> <h2 id="_5-2-regexp"><a href="#_5-2-regexp" class="header-anchor">#</a> 5.2 　 RegExp</h2> <p>ECMAScript 通过<code>RegExp</code>类型支持正则表达式。正则表达式使用类似 Perl 的简洁语法来创建：</p> <div class="language- extra-class"><pre class="language-text"><code>let expression = /pattern/flags;
</code></pre></div><p>这个正则表达式的<code>pattern</code>（模式）可以是任何简单或复杂的正则表达式，包括字符类、限定符、分组、向前查找和反向引用。每个正则表达式可以带零个或多个<code>flags</code>（标记），用于控制正则表达式的行为。下面给出了表示匹配模式的标记。</p> <ul><li><code>g</code>：全局模式，表示查找字符串的全部内容，而不是找到第一个匹配的内容就结束。</li> <li><code>i</code>：不区分大小写，表示在查找匹配时忽略<code>pattern</code>和字符串的大小写。</li> <li><code>m</code>：多行模式，表示查找到一行文本末尾时会继续查找。</li> <li><code>y</code>：粘附模式，表示只查找从<code>lastIndex</code>开始及之后的字符串。</li> <li><code>u</code>：Unicode 模式，启用 Unicode 匹配。</li> <li><code>s</code>：<code>dotAll</code>模式，表示元字符<code>.</code>匹配任何字符（包括<code>\n</code>或<code>\r</code>）。</li></ul> <p>使用不同模式和标记可以创建出各种正则表达式，比如：</p> <div class="language- extra-class"><pre class="language-text"><code>// 匹配字符串中的所有&quot;at&quot;
let pattern1 = /at/g;

// 匹配第一个&quot;bat&quot;或&quot;cat&quot;，忽略大小写
let pattern2 = /[bc]at/i;

// 匹配所有以&quot;at&quot;结尾的三字符组合，忽略大小写
let pattern3 = /.at/gi;
</code></pre></div><p>与其他语言中的正则表达式类似，所有<strong>元字符</strong>在模式中也必须转义，包括：</p> <div class="language- extra-class"><pre class="language-text"><code>( [ { \ ^ $ | ) ] } ? * + .
</code></pre></div><p>元字符在正则表达式中都有一种或多种特殊功能，所以要匹配上面这些字符本身，就必须使用反斜杠来转义。下面是几个例子：</p> <div class="language- extra-class"><pre class="language-text"><code>// 匹配第一个&quot;bat&quot;或&quot;cat&quot;，忽略大小写
let pattern1 = /[bc]at/i;

// 匹配第一个&quot;[bc]at&quot;，忽略大小写
let pattern2 = /\[bc\]at/i;

// 匹配所有以&quot;at&quot;结尾的三字符组合，忽略大小写
let pattern3 = /.at/gi;

// 匹配所有&quot;.at&quot;，忽略大小写
let pattern4 = /\.at/gi;
</code></pre></div><p>这里的<code>pattern1</code>匹配<code>&quot;bat&quot;</code>或<code>&quot;cat&quot;</code>，不区分大小写。要直接匹配<code>&quot;[bc]at&quot;</code>，左右中括号都必须像<code>pattern2</code>中那样使用反斜杠转义。在<code>pattern3</code>中，点号表示<code>&quot;at&quot;</code>前面的任意字符都可以匹配。如果想匹配<code>&quot;.at&quot;</code>，那么要像<code>pattern4</code>中那样对点号进行转义。</p> <p>前面例子中的正则表达式都是使用字面量形式定义的。正则表达式也可以使用<code>RegExp</code>构造函数来创建，它接收两个参数：模式字符串和（可选的）标记字符串。任何使用字面量定义的正则表达式也可以通过构造函数来创建，比如：</p> <div class="language- extra-class"><pre class="language-text"><code>// 匹配第一个&quot;bat&quot;或&quot;cat&quot;，忽略大小写
let pattern1 = /[bc]at/i;

// 跟pattern1一样，只不过是用构造函数创建的
let pattern2 = new RegExp(&quot;[bc]at&quot;, &quot;i&quot;);
</code></pre></div><p>这里的<code>pattern1</code>和<code>pattern2</code>是等效的正则表达式。注意，<code>RegExp</code>构造函数的两个参数都是字符串。因为<code>RegExp</code>的模式参数是字符串，所以在某些情况下需要二次转义。所有元字符都必须二次转义，包括转义字符序列，如<code>\n</code>（<code>\</code>转义后的字符串是<code>\\</code>，在正则表达式字符串中则要写成<code>\\\\</code>）。下表展示了几个正则表达式的字面量形式，以及使用<code>RegExp</code>构造函数创建时对应的模式字符串。</p> <table><thead><tr><th style="text-align:left;">字面量模式</th> <th style="text-align:left;">对应的字符串</th></tr></thead> <tbody><tr><td style="text-align:left;"><code>/\[bc\]at/</code></td> <td style="text-align:left;"><code>&quot;\\[bc\\]at&quot;</code></td></tr> <tr><td style="text-align:left;"><code>/\.at/</code></td> <td style="text-align:left;"><code>&quot;\\.at&quot;</code></td></tr> <tr><td style="text-align:left;"><code>/name\/age/</code></td> <td style="text-align:left;"><code>&quot;name\\/age&quot;</code></td></tr> <tr><td style="text-align:left;"><code>/\d.\d{1,2}/</code></td> <td style="text-align:left;"><code>&quot;\\d.\\d{1,2}&quot;</code></td></tr> <tr><td style="text-align:left;"><code>/\w\\hello\\123/</code></td> <td style="text-align:left;"><code>&quot;\\w\\\\hello\\\\123&quot;</code></td></tr></tbody></table> <p>此外，使用<code>RegExp</code>也可以基于已有的正则表达式实例，并可选择性地修改它们的标记：</p> <div class="language- extra-class"><pre class="language-text"><code>const re1 = /cat/g;
console.log(re1);  // &quot;/cat/g&quot;

const re2 = new RegExp(re1);
console.log(re2);  // &quot;/cat/g&quot;

const re3 = new RegExp(re1, &quot;i&quot;);
console.log(re3);  // &quot;/cat/i&quot;
</code></pre></div><h3 id="_5-2-1-regexp实例属性"><a href="#_5-2-1-regexp实例属性" class="header-anchor">#</a> 5.2.1 　<code>RegExp</code>实例属性</h3> <p>每个<code>RegExp</code>实例都有下列属性，提供有关模式的各方面信息。</p> <ul><li><code>global</code>：布尔值，表示是否设置了<code>g</code>标记。</li> <li><code>ignoreCase</code>：布尔值，表示是否设置了<code>i</code>标记。</li> <li><code>unicode</code>：布尔值，表示是否设置了<code>u</code>标记。</li> <li><code>sticky</code>：布尔值，表示是否设置了<code>y</code>标记。</li> <li><code>lastIndex</code>：整数，表示在源字符串中下一次搜索的开始位置，始终从 0 开始。</li> <li><code>multiline</code>：布尔值，表示是否设置了<code>m</code>标记。</li> <li><code>dotAll</code>：布尔值，表示是否设置了<code>s</code>标记。</li> <li><code>source</code>：正则表达式的字面量字符串（不是传给构造函数的模式字符串），没有开头和结尾的斜杠。</li> <li><code>flags</code>：正则表达式的标记字符串。始终以字面量而非传入构造函数的字符串模式形式返回（没有前后斜杠）。</li></ul> <p>通过这些属性可以全面了解正则表达式的信息，不过实际开发中用得并不多，因为模式声明中包含这些信息。下面是一个例子：</p> <div class="language- extra-class"><pre class="language-text"><code>let pattern1 = /\[bc\]at/i;

console.log(pattern1.global);      // false
console.log(pattern1.ignoreCase);  // true
console.log(pattern1.multiline);   // false
console.log(pattern1.lastIndex);   // 0
console.log(pattern1.source);      // &quot;\[bc\]at&quot;
console.log(pattern1.flags);       // &quot;i&quot;

let pattern2 = new RegExp(&quot;\\[bc\\]at&quot;, &quot;i&quot;);

console.log(pattern2.global);      // false
console.log(pattern2.ignoreCase);  // true
console.log(pattern2.multiline);   // false
console.log(pattern2.lastIndex);   // 0
console.log(pattern2.source);      // &quot;\[bc\]at&quot;
console.log(pattern2.flags);       // &quot;i&quot;
</code></pre></div><p>注意，虽然第一个模式是通过字面量创建的，第二个模式是通过<code>RegExp</code>构造函数创建的，但两个模式的<code>source</code>和<code>flags</code>属性是相同的。<code>source</code>和<code>flags</code>属性返回的是规范化之后可以在字面量中使用的形式。</p> <h3 id="_5-2-2-regexp实例方法"><a href="#_5-2-2-regexp实例方法" class="header-anchor">#</a> 5.2.2 　<code>RegExp</code>实例方法</h3> <p><code>RegExp</code>实例的主要方法是<code>exec()</code>，主要用于配合捕获组使用。这个方法只接收一个参数，即要应用模式的字符串。如果找到了匹配项，则返回包含第一个匹配信息的数组；如果没找到匹配项，则返回<code>null</code>。返回的数组虽然是<code>Array</code>的实例，但包含两个额外的属性：<code>index</code>和<code>input</code>。<code>index</code>是字符串中匹配模式的起始位置，<code>input</code>是要查找的字符串。这个数组的第一个元素是匹配整个模式的字符串，其他元素是与表达式中的捕获组匹配的字符串。如果模式中没有捕获组，则数组只包含一个元素。来看下面的例子：</p> <div class="language- extra-class"><pre class="language-text"><code>let text = &quot;mom and dad and baby&quot;;
let pattern = /mom( and dad( and baby)?)?/gi;

let matches = pattern.exec(text);
console.log(matches.index);   // 0
console.log(matches.input);   // &quot;mom and dad and baby&quot;
console.log(matches[0]);      // &quot;mom and dad and baby&quot;
console.log(matches[1]);      // &quot; and dad and baby&quot;
console.log(matches[2]);      // &quot; and baby&quot;
</code></pre></div><p>在这个例子中，模式包含两个捕获组：最内部的匹配项<code>&quot; and baby&quot;</code>，以及外部的匹配项<code>&quot; and dad&quot;</code>或<code>&quot; and dad and baby&quot;</code>。调用<code>exec()</code>后找到了一个匹配项。因为整个字符串匹配模式，所以<code>matchs</code>数组的<code>index</code>属性就是 0。数组的第一个元素是匹配的整个字符串，第二个元素是匹配第一个捕获组的字符串，第三个元素是匹配第二个捕获组的字符串。</p> <p>如果模式设置了全局标记，则每次调用<code>exec()</code>方法会返回一个匹配的信息。如果没有设置全局标记，则无论对同一个字符串调用多少次<code>exec()</code>，也只会返回第一个匹配的信息。</p> <div class="language- extra-class"><pre class="language-text"><code>let text = &quot;cat, bat, sat, fat&quot;;
let pattern = /.at/;

let matches = pattern.exec(text);
console.log(matches.index);      // 0
console.log(matches[0]);         // cat
console.log(pattern.lastIndex);  // 0

matches = pattern.exec(text);
console.log(matches.index);      // 0
console.log(matches[0]);         // cat
console.log(pattern.lastIndex);  // 0
</code></pre></div><p>上面例子中的模式没有设置全局标记，因此调用<code>exec()</code>只返回第一个匹配项（<code>&quot;cat&quot;</code>）。<code>lastIndex</code>在非全局模式下始终不变。</p> <p>如果在这个模式上设置了<code>g</code>标记，则每次调用<code>exec()</code>都会在字符串中向前搜索下一个匹配项，如下面的例子所示：</p> <div class="language- extra-class"><pre class="language-text"><code>let text = &quot;cat, bat, sat, fat&quot;;
let pattern = /.at/g;
let matches = pattern.exec(text);
console.log(matches.index);      // 0
console.log(matches[0]);         // cat
console.log(pattern.lastIndex);  // 3

matches = pattern.exec(text);
console.log(matches.index);      // 5
console.log(matches[0]);         // bat
console.log(pattern.lastIndex);  // 8

matches = pattern.exec(text);
console.log(matches.index);      // 10
console.log(matches[0]);         // sat
console.log(pattern.lastIndex);  // 13
</code></pre></div><p>这次模式设置了全局标记，因此每次调用<code>exec()</code>都会返回字符串中的下一个匹配项，直到搜索到字符串末尾。注意模式的<code>lastIndex</code>属性每次都会变化。在全局匹配模式下，每次调用<code>exec()</code>都会更新<code>lastIndex</code>值，以反映上次匹配的最后一个字符的索引。</p> <p>如果模式设置了粘附标记<code>y</code>，则每次调用<code>exec()</code>就只会在<code>lastIndex</code>的位置上寻找匹配项。粘附标记覆盖全局标记。</p> <div class="language- extra-class"><pre class="language-text"><code>let text = &quot;cat, bat, sat, fat&quot;;
let pattern = /.at/y;

let matches = pattern.exec(text);
console.log(matches.index);       // 0
console.log(matches[0]);          // cat
console.log(pattern.lastIndex);   // 3

// 以索引3对应的字符开头找不到匹配项，因此exec()返回null
// exec()没找到匹配项，于是将lastIndex设置为0
matches = pattern.exec(text);
console.log(matches);             // null
console.log(pattern.lastIndex);   // 0

// 向前设置lastIndex可以让粘附的模式通过exec()找到下一个匹配项：
pattern.lastIndex = 5;
matches = pattern.exec(text);
console.log(matches.index);       // 5
console.log(matches[0]);          // bat
console.log(pattern.lastIndex);   // 8
</code></pre></div><p>正则表达式的另一个方法是<code>test()</code>，接收一个字符串参数。如果输入的文本与模式匹配，则参数返回<code>true</code>，否则返回<code>false</code>。这个方法适用于只想测试模式是否匹配，而不需要实际匹配内容的情况。<code>test()</code>经常用在<code>if</code>语句中：</p> <div class="language- extra-class"><pre class="language-text"><code>let text = &quot;000-00-0000&quot;;
let pattern = /\d{3}-\d{2}-\d{4}/;

if (pattern.test(text)) {
  console.log(&quot;The pattern was matched.&quot;);
}
</code></pre></div><p>在这个例子中，正则表达式用于测试特定的数值序列。如果输入的文本与模式匹配，则显示匹配成功的消息。这个用法常用于验证用户输入，此时我们只在乎输入是否有效，不关心为什么无效。</p> <p>无论正则表达式是怎么创建的，继承的方法<code>toLocaleString()</code>和<code>toString()</code>都返回正则表达式的字面量表示。比如：</p> <div class="language- extra-class"><pre class="language-text"><code>let pattern = new RegExp(&quot;\\[bc\\]at&quot;, &quot;gi&quot;);
console.log(pattern.toString());       // /\[bc\]at/gi
console.log(pattern.toLocaleString()); // /\[bc\]at/gi
</code></pre></div><p>这里的模式是通过<code>RegExp</code>构造函数创建的，但<code>toLocaleString()</code>和<code>toString()</code>返回的都是其字面量的形式。</p> <blockquote><p><strong>注意</strong>　正则表达式的<code>valueOf()</code>方法返回正则表达式本身。</p></blockquote> <h3 id="_5-2-3-regexp构造函数属性"><a href="#_5-2-3-regexp构造函数属性" class="header-anchor">#</a> 5.2.3 　<code>RegExp</code>构造函数属性</h3> <p><code>RegExp</code>构造函数本身也有几个属性。（在其他语言中，这种属性被称为静态属性。）这些属性适用于作用域中的所有正则表达式，而且会根据最后执行的正则表达式操作而变化。这些属性还有一个特点，就是可以通过两种不同的方式访问它们。换句话说，每个属性都有一个全名和一个简写。下表列出了<code>RegExp</code>构造函数的属性。</p> <table><thead><tr><th style="text-align:left;">全名</th> <th style="text-align:left;">简写</th> <th style="text-align:left;">说明</th></tr></thead> <tbody><tr><td style="text-align:left;"><code>input</code></td> <td style="text-align:left;"><code>$_</code></td> <td style="text-align:left;">最后搜索的字符串</td></tr> <tr><td style="text-align:left;"><code>lastMatch</code></td> <td style="text-align:left;"><code>$&amp;</code></td> <td style="text-align:left;">最后匹配的文本</td></tr> <tr><td style="text-align:left;"><code>lastParen</code></td> <td style="text-align:left;"><code>$+</code></td> <td style="text-align:left;">最后匹配的捕获组</td></tr> <tr><td style="text-align:left;"><code>leftContext</code></td> <td style="text-align:left;"><code>\$`` |</code>input<code>字符串中出现在</code>lastMatch`前面的文本</td> <td style="text-align:left;"></td></tr> <tr><td style="text-align:left;"><code>rightContext</code></td> <td style="text-align:left;"><code>$'</code></td> <td style="text-align:left;"><code>input</code>字符串中出现在<code>lastMatch</code>后面的文本</td></tr></tbody></table> <p>通过这些属性可以提取出与<code>exec()</code>和<code>test()</code>执行的操作相关的信息。来看下面的例子：</p> <div class="language- extra-class"><pre class="language-text"><code>let text = &quot;this has been a short summer&quot;;
let pattern = /(.)hort/g;

if (pattern.test(text)) {
  console.log(RegExp.input);        // this has been a short summer
  console.log(RegExp.leftContext);  // this has been a
  console.log(RegExp.rightContext); // summer
  console.log(RegExp.lastMatch);    // short
  console.log(RegExp.lastParen);    // s
}
</code></pre></div><p>以上代码创建了一个模式，用于搜索任何后跟<code>&quot;hort&quot;</code>的字符，并把第一个字符放在了捕获组中。不同属性包含的内容如下。</p> <ul><li><code>input</code>属性中包含原始的字符串。</li> <li><code>leftConext</code>属性包含原始字符串中<code>&quot;short&quot;</code>之前的内容，<code>rightContext</code>属性包含<code>&quot;short&quot;</code>之后的内容。</li> <li><code>lastMatch</code>属性包含匹配整个正则表达式的上一个字符串，即<code>&quot;short&quot;</code>。</li> <li><code>lastParen</code>属性包含捕获组的上一次匹配，即<code>&quot;s&quot;</code>。</li></ul> <p>这些属性名也可以替换成简写形式，只不过要使用中括号语法来访问，如下面的例子所示，因为大多数简写形式都不是合法的 ECMAScript 标识符：</p> <div class="language- extra-class"><pre class="language-text"><code>let text = &quot;this has been a short summer&quot;;
let pattern = /(.)hort/g;

/*
 * 注意：Opera不支持简写属性名
 * IE不支持多行匹配
 */
if (pattern.test(text)) {
  console.log(RegExp.$_);       // this has been a short summer
  console.log(RegExp[&quot;$`&quot;]);    // this has been a
  console.log(RegExp[&quot;$'&quot;]);    // summer
  console.log(RegExp[&quot;$&amp;&quot;]);    // short
  console.log(RegExp[&quot;$+&quot;]);    // s
  console.log(RegExp[&quot;$*&quot;]);    // false
}
</code></pre></div><p><code>RegExp</code>还有其他几个构造函数属性，可以存储最多 9 个捕获组的匹配项。这些属性通过<code>RegExp.$1~RegExp.$9</code>来访问，分别包含第 1~9 个捕获组的匹配项。在调用<code>exec()</code>或<code>test()</code>时，这些属性就会被填充，然后就可以像下面这样使用它们：</p> <div class="language- extra-class"><pre class="language-text"><code>let text = &quot;this has been a short summer&quot;;
let pattern = /(..)or(.)/g;

if (pattern.test(text)) {
  console.log(RegExp.$1);  // sh
  console.log(RegExp.$2);  // t
}
</code></pre></div><p>在这个例子中，模式包含两个捕获组。调用<code>test()</code>搜索字符串之后，因为找到了匹配项所以返回<code>true</code>，而且可以打印出通过<code>RegExp</code>构造函数的<code>$1</code>和<code>$2</code>属性取得的两个捕获组匹配的内容。</p> <blockquote><p><strong>注意</strong> <code>RegExp</code>构造函数的所有属性都没有任何 Web 标准出处，因此不要在生产环境中使用它们。</p></blockquote> <h3 id="_5-2-4-模式局限"><a href="#_5-2-4-模式局限" class="header-anchor">#</a> 5.2.4 　模式局限</h3> <p>虽然 ECMAScript 对正则表达式的支持有了长足的进步，但仍然缺少 Perl 语言中的一些高级特性。下列特性目前还没有得到 ECMAScript 的支持（想要了解更多信息，可以参考 Regular-Expressions.info 网站）：</p> <ul><li><code>\A</code>和<code>\Z</code>锚（分别匹配字符串的开始和末尾）</li> <li>联合及交叉类</li> <li>原子组</li> <li><code>x</code>（忽略空格）匹配模式</li> <li>条件式匹配</li> <li>正则表达式注释</li></ul> <p>虽然还有这些局限，但 ECMAScript 的正则表达式已经非常强大，可以用于大多数模式匹配任务。</p> <h2 id="_5-3-原始值包装类型"><a href="#_5-3-原始值包装类型" class="header-anchor">#</a> 5.3 　原始值包装类型</h2> <p>为了方便操作原始值，ECMAScript 提供了 3 种特殊的引用类型：<code>Boolean</code>、<code>Number</code>和<code>String</code>。这些类型具有本章介绍的其他引用类型一样的特点，但也具有与各自原始类型对应的特殊行为。每当用到某个原始值的方法或属性时，后台都会创建一个相应原始包装类型的对象，从而暴露出操作原始值的各种方法。来看下面的例子：</p> <div class="language- extra-class"><pre class="language-text"><code>let s1 = &quot;some text&quot;;
let s2 = s1.substring(2);
</code></pre></div><p>在这里，<code>s1</code>是一个包含字符串的变量，它是一个原始值。第二行紧接着在<code>s1</code>上调用了<code>substring()</code>方法，并把结果保存在<code>s2</code>中。我们知道，原始值本身不是对象，因此逻辑上不应该有方法。而实际上这个例子又确实按照预期运行了。这是因为后台进行了很多处理，从而实现了上述操作。具体来说，当第二行访问<code>s1</code>时，是以读模式访问的，也就是要从内存中读取变量保存的值。在以读模式访问字符串值的任何时候，后台都会执行以下 3 步：</p> <p>(1) 创建一个<code>String</code>类型的实例；</p> <p>(2) 调用实例上的特定方法；</p> <p>(3) 销毁实例。</p> <p>可以把这 3 步想象成执行了如下 3 行 ECMAScript 代码：</p> <div class="language- extra-class"><pre class="language-text"><code>let s1 = new String(&quot;some text&quot;);
let s2 = s1.substring(2);
s1 = null;
</code></pre></div><p>这种行为可以让原始值拥有对象的行为。对布尔值和数值而言，以上 3 步也会在后台发生，只不过使用的是<code>Boolean</code>和<code>Number</code>包装类型而已。</p> <p>引用类型与原始值包装类型的主要区别在于对象的生命周期。在通过<code>new</code>实例化引用类型后，得到的实例会在离开作用域时被销毁，而自动创建的原始值包装对象则只存在于访问它的那行代码执行期间。这意味着不能在运行时给原始值添加属性和方法。比如下面的例子：</p> <div class="language- extra-class"><pre class="language-text"><code>let s1 = &quot;some text&quot;;
s1.color = &quot;red&quot;;
console.log(s1.color);  // undefined
</code></pre></div><p>这里的第二行代码尝试给字符串<code>s1</code>添加了一个<code>color</code>属性。可是，第三行代码访问<code>color</code>属性时，它却不见了。原因就是第二行代码运行时会临时创建一个<code>String</code>对象，而当第三行代码执行时，这个对象已经被销毁了。实际上，第三行代码在这里创建了自己的<code>String</code>对象，但这个对象没有<code>color</code>属性。</p> <p>可以显式地使用<code>Boolean</code>、<code>Number</code>和<code>String</code>构造函数创建原始值包装对象。不过应该在确实必要时再这么做，否则容易让开发者疑惑，分不清它们到底是原始值还是引用值。在原始值包装类型的实例上调用<code>typeof</code>会返回<code>&quot;object&quot;</code>，所有原始值包装对象都会转换为布尔值<code>true</code>。</p> <p>另外，<code>Object</code>构造函数作为一个工厂方法，能够根据传入值的类型返回相应原始值包装类型的实例。比如：</p> <div class="language- extra-class"><pre class="language-text"><code>let obj = new Object(&quot;some text&quot;);
console.log(obj instanceof String);  // true
</code></pre></div><p>如果传给<code>Object</code>的是字符串，则会创建一个<code>String</code>的实例。如果是数值，则会创建<code>Number</code>的实例。布尔值则会得到<code>Boolean</code>的实例。</p> <p>注意，使用<code>new</code>调用原始值包装类型的构造函数，与调用同名的转型函数并不一样。例如：</p> <div class="language- extra-class"><pre class="language-text"><code>let value = &quot;25&quot;;
let number = Number(value);    // 转型函数
console.log(typeof number);    // &quot;number&quot;
let obj = new Number(value);   // 构造函数
console.log(typeof obj);       // &quot;object&quot;
</code></pre></div><p>在这个例子中，变量<code>number</code>中保存的是一个值为 25 的原始数值，而变量<code>obj</code>中保存的是一个<code>Number</code>的实例。</p> <p>虽然不推荐显式创建原始值包装类型的实例，但它们对于操作原始值的功能是很重要的。每个原始值包装类型都有相应的一套方法来方便数据操作。</p> <h3 id="_5-3-1-boolean"><a href="#_5-3-1-boolean" class="header-anchor">#</a> 5.3.1 　<code>Boolean</code></h3> <p><code>Boolean</code>是对应布尔值的引用类型。要创建一个<code>Boolean</code>对象，就使用<code>Boolean</code>构造函数并传入<code>true</code>或<code>false</code>，如下例所示：</p> <div class="language- extra-class"><pre class="language-text"><code>let booleanObject = new Boolean(true);
</code></pre></div><p><code>Boolean</code>的实例会重写<code>valueOf()</code>方法，返回一个原始值<code>true</code>或<code>false</code>。<code>toString()</code>方法被调用时也会被覆盖，返回字符串<code>&quot;true&quot;</code>或<code>&quot;false&quot;</code>。不过，<code>Boolean</code>对象在 ECMAScript 中用得很少。不仅如此，它们还容易引起误会，尤其是在布尔表达式中使用<code>Boolean</code>对象时，比如：</p> <div class="language- extra-class"><pre class="language-text"><code>let falseObject = new Boolean(false);
let result = falseObject &amp;&amp; true;
console.log(result); // true

let falseValue = false;
result = falseValue &amp;&amp; true;
console.log(result); // false
</code></pre></div><p>在这段代码中，我们创建一个值为<code>false</code>的<code>Boolean</code>对象。然后，在一个布尔表达式中通过<code>&amp;&amp;</code>操作将这个对象与一个原始值<code>true</code>组合起来。在布尔算术中，<code>false &amp;&amp; true</code>等于<code>false</code>。可是，这个表达式是对<code>falseObject</code>对象而不是对它表示的值（<code>false</code>）求值。前面刚刚说过，所有对象在布尔表达式中都会自动转换为<code>true</code>，因此<code>falseObject</code>在这个表达式里实际上表示一个<code>true</code>值。那么<code>true &amp;&amp; true</code>当然是<code>true</code>。</p> <p>除此之外，原始值和引用值（<code>Boolean</code>对象）还有几个区别。首先，<code>typeof</code>操作符对原始值返回<code>&quot;boolean&quot;</code>，但对引用值返回<code>&quot;object&quot;</code>。同样，<code>Boolean</code>对象是<code>Boolean</code>类型的实例，在使用<code>instaceof</code>操作符时返回<code>true</code>，但对原始值则返回<code>false</code>，如下所示：</p> <div class="language- extra-class"><pre class="language-text"><code>console.log(typeof falseObject);             // object
console.log(typeof falseValue);              // boolean
console.log(falseObject instanceof Boolean); // true
console.log(falseValue instanceof Boolean);  // false
</code></pre></div><p>理解原始布尔值和<code>Boolean</code>对象之间的区别非常重要，强烈建议永远不要使用后者。</p> <h3 id="_5-3-2-number"><a href="#_5-3-2-number" class="header-anchor">#</a> 5.3.2 　<code>Number</code></h3> <p><code>Number</code>是对应数值的引用类型。要创建一个<code>Number</code>对象，就使用<code>Number</code>构造函数并传入一个数值，如下例所示：</p> <div class="language- extra-class"><pre class="language-text"><code>let numberObject = new Number(10);
</code></pre></div><p>与<code>Boolean</code>类型一样，<code>Number</code>类型重写了<code>valueOf()</code>、<code>toLocaleString()</code>和<code>toString()</code>方法。<code>valueOf()</code>方法返回<code>Number</code>对象表示的原始数值，另外两个方法返回数值字符串。<code>toString()</code>方法可选地接收一个表示基数的参数，并返回相应基数形式的数值字符串，如下所示：</p> <div class="language- extra-class"><pre class="language-text"><code>let num = 10;
console.log(num.toString());   // &quot;10&quot;
console.log(num.toString(2));  // &quot;1010&quot;
console.log(num.toString(8));  // &quot;12&quot;
console.log(num.toString(10)); // &quot;10&quot;
console.log(num.toString(16)); // &quot;a&quot;
</code></pre></div><p>除了继承的方法，<code>Number</code>类型还提供了几个用于将数值格式化为字符串的方法。</p> <p><code>toFixed()</code>方法返回包含指定小数点位数的数值字符串，如：</p> <div class="language- extra-class"><pre class="language-text"><code>let num = 10;
console.log(num.toFixed(2)); // &quot;10.00&quot;
</code></pre></div><p>这里的<code>toFixed()</code>方法接收了参数<code>2</code>，表示返回的数值字符串要包含两位小数。结果返回值为<code>&quot;10.00&quot;</code>，小数位填充了 0。如果数值本身的小数位超过了参数指定的位数，则四舍五入到最接近的小数位：</p> <div class="language- extra-class"><pre class="language-text"><code>let num = 10.005;
console.log(num.toFixed(2)); // &quot;10.01&quot;
</code></pre></div><p><code>toFixed()</code>自动舍入的特点可以用于处理货币。不过要注意的是，多个浮点数值的数学计算不一定得到精确的结果。比如，<code>0.1 + 0.2 = 0.30000000000000004</code>。</p> <blockquote><p><strong>注意</strong> <code>toFixed()</code>方法可以表示有 0~20 个小数位的数值。某些浏览器可能支持更大的范围，但这是通常被支持的范围。</p></blockquote> <p>另一个用于格式化数值的方法是<code>toExponential()</code>，返回以科学记数法（也称为指数记数法）表示的数值字符串。与<code>toFixed()</code>一样，<code>toExponential()</code>也接收一个参数，表示结果中小数的位数。来看下面的例子：</p> <div class="language- extra-class"><pre class="language-text"><code>let num = 10;
console.log(num.toExponential(1));  // &quot;1.0e+1&quot;
</code></pre></div><p>这段代码的输出为<code>&quot;1.0e+1&quot;</code>。一般来说，这么小的数不用表示为科学记数法形式。如果想得到数值最适当的形式，那么可以使用<code>toPrecision()</code>。</p> <p><code>toPrecision()</code>方法会根据情况返回最合理的输出结果，可能是固定长度，也可能是科学记数法形式。这个方法接收一个参数，表示结果中数字的总位数（不包含指数）。来看几个例子：</p> <div class="language- extra-class"><pre class="language-text"><code>let num = 99;
console.log(num.toPrecision(1)); // &quot;1e+2&quot;
console.log(num.toPrecision(2)); // &quot;99&quot;
console.log(num.toPrecision(3)); // &quot;99.0&quot;
</code></pre></div><p>在这个例子中，首先要用 1 位数字表示数值 99，得到<code>&quot;1e+2&quot;</code>，也就是 100。因为 99 不能只用 1 位数字来精确表示，所以这个方法就将它舍入为 100，这样就可以只用 1 位数字（及其科学记数法形式）来表示了。用 2 位数字表示 99 得到<code>&quot;99&quot;</code>，用 3 位数字则是<code>&quot;99.0&quot;</code>。本质上，<code>toPrecision()</code>方法会根据数值和精度来决定调用<code>toFixed()</code>还是<code>toExponential()</code>。为了以正确的小数位精确表示数值，这 3 个方法都会向上或向下舍入。</p> <blockquote><p><strong>注意</strong> <code>toPrecision()</code>方法可以表示带 1~21 个小数位的数值。某些浏览器可能支持更大的范围，但这是通常被支持的范围。</p></blockquote> <p>与<code>Boolean</code>对象类似，<code>Number</code>对象也为数值提供了重要能力。但是，考虑到两者存在同样的潜在问题，因此并不建议直接实例化<code>Number</code>对象。在处理原始数值和引用数值时，<code>typeof</code>和<code>instacnceof</code>操作符会返回不同的结果，如下所示：</p> <div class="language- extra-class"><pre class="language-text"><code>let numberObject = new Number(10);
let numberValue = 10;
console.log(typeof numberObject);             // &quot;object&quot;
console.log(typeof numberValue);              // &quot;number&quot;
console.log(numberObject instanceof Number);  // true
console.log(numberValue instanceof Number);   // false
</code></pre></div><p>原始数值在调用<code>typeof</code>时始终返回<code>&quot;number&quot;</code>，而<code>Number</code>对象则返回<code>&quot;object&quot;</code>。类似地，<code>Number</code>对象是<code>Number</code>类型的实例，而原始数值不是。</p> <p><strong>isInteger()方法与安全整数</strong></p> <p>ES6 新增了<code>Number.isInteger()</code>方法，用于辨别一个数值是否保存为整数。有时候，小数位的 0 可能会让人误以为数值是一个浮点值：</p> <div class="language- extra-class"><pre class="language-text"><code>console.log(Number.isInteger(1));    // true
console.log(Number.isInteger(1.00)); // true
console.log(Number.isInteger(1.01)); // false
</code></pre></div><p>IEEE 754 数值格式有一个特殊的数值范围，在这个范围内二进制值可以表示一个整数值。这个数值范围从<code>Number.MIN_SAFE_INTEGER</code>（<img src="https://private.codecogs.com/gif.latex?-2%5E%7B53%7D+1" alt="-2^{53}+1">）到<code>Number.MAX_SAFE_INTEGER</code>（<img src="https://private.codecogs.com/gif.latex?2%5E%7B53%7D-1" alt="2^{53}-1">）。对超出这个范围的数值，即使尝试保存为整数，IEEE 754 编码格式也意味着二进制值可能会表示一个完全不同的数值。为了鉴别整数是否在这个范围内，可以使用<code>Number.isSafeInteger()</code>方法：</p> <div class="language- extra-class"><pre class="language-text"><code>console.log(Number.isSafeInteger(-1 * (2 ** 53)));      // false
console.log(Number.isSafeInteger(-1 * (2 ** 53) + 1));  // true

console.log(Number.isSafeInteger(2 ** 53));             // false
console.log(Number.isSafeInteger((2 ** 53) - 1));       // true
</code></pre></div><h3 id="_5-3-3-string"><a href="#_5-3-3-string" class="header-anchor">#</a> 5.3.3 　<code>String</code></h3> <p><code>String</code>是对应字符串的引用类型。要创建一个<code>String</code>对象，使用<code>String</code>构造函数并传入一个数值，如下例所示：</p> <div class="language- extra-class"><pre class="language-text"><code>let stringObject = new String(&quot;hello world&quot;);
</code></pre></div><p><code>String</code>对象的方法可以在所有字符串原始值上调用。3 个继承的方法<code>valueOf()</code>、<code>toLcaleString()</code>和<code>toString()</code>都返回对象的原始字符串值。</p> <p>每个<code>String</code>对象都有一个<code>length</code>属性，表示字符串中字符的数量。来看下面的例子：</p> <div class="language- extra-class"><pre class="language-text"><code>let stringValue = &quot;hello world&quot;;
console.log(stringValue.length); // &quot;11&quot;
</code></pre></div><p>这个例子输出了字符串<code>&quot;hello world&quot;</code>中包含的字符数量：<code>11</code>。注意，即使字符串中包含双字节字符（而不是单字节的 ASCII 字符），也仍然会按单字符来计数。</p> <p><code>String</code>类型提供了很多方法来解析和操作字符串。</p> <ol><li><p><strong>JavaScript 字符</strong></p> <p>JavaScript 字符串由 16 位码元（code unit）组成。对多数字符来说，每 16 位码元对应一个字符。换句话说，字符串的<code>length</code>属性表示字符串包含多少 16 位码元：</p> <div class="language- extra-class"><pre class="language-text"><code>let message = &quot;abcde&quot;;

console.log(message.length); // 5
</code></pre></div><p>此外，<code>charAt()</code>方法返回给定索引位置的字符，由传给方法的整数参数指定。具体来说，这个方法查找指定索引位置的 16 位码元，并返回该码元对应的字符：</p> <div class="language- extra-class"><pre class="language-text"><code>let message = &quot;abcde&quot;;

console.log(message.charAt(2)); // &quot;c&quot;
</code></pre></div><p>JavaScript 字符串使用了两种 Unicode 编码混合的策略：UCS-2 和 UTF-16。对于可以采用 16 位编码的字符（U+0000~U+FFFF），这两种编码实际上是一样的。</p> <blockquote><p><strong>注意</strong>　要深入了解关于字符编码的内容，推荐 Joel Spolsky 写的博客文章：“The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets (No Excuses!)”。</p> <p>另一个有用的资源是 Mathias Bynens 的博文：“JavaScript's Internal Character Encoding: UCS-2 or UTF-16?”。</p></blockquote> <p>使用<code>charCodeAt()</code>方法可以查看指定码元的字符编码。这个方法返回指定索引位置的码元值，索引以整数指定。比如：</p> <div class="language- extra-class"><pre class="language-text"><code>let message = &quot;abcde&quot;;

// Unicode &quot;Latin small letter C&quot;的编码是U+0063
console.log(message.charCodeAt(2));  // 99

// 十进制99等于十六进制63
console.log(99 === 0x63);            // true
</code></pre></div><p><code>fromCharCode()</code>方法用于根据给定的 UTF-16 码元创建字符串中的字符。这个方法可以接受任意多个数值，并返回将所有数值对应的字符拼接起来的字符串：</p> <div class="language- extra-class"><pre class="language-text"><code>// Unicode &quot;Latin small letter A&quot;的编码是U+0061
// Unicode &quot;Latin small letter B&quot;的编码是U+0062
// Unicode &quot;Latin small letter C&quot;的编码是U+0063
// Unicode &quot;Latin small letter D&quot;的编码是U+0064
// Unicode &quot;Latin small letter E&quot;的编码是U+0065

console.log(String.fromCharCode(0x61, 0x62, 0x63, 0x64, 0x65));  // &quot;abcde&quot;

// 0x0061 === 97
// 0x0062 === 98
// 0x0063 === 99
// 0x0064 === 100
// 0x0065 === 101

console.log(String.fromCharCode(97, 98, 99, 100, 101));          // &quot;abcde&quot;
</code></pre></div><p>对于 U+0000~U+FFFF 范围内的字符，<code>length</code>、<code>charAt()</code>、<code>charCodeAt()</code>和<code>fromCharCode()</code>返回的结果都跟预期是一样的。这是因为在这个范围内，每个字符都是用 16 位表示的，而这几个方法也都基于 16 位码元完成操作。只要字符编码大小与码元大小一一对应，这些方法就能如期工作。</p> <p>这个对应关系在扩展到 Unicode 增补字符平面时就不成立了。问题很简单，即 16 位只能唯一表示 65 536 个字符。这对于大多数语言字符集是足够了，在 Unicode 中称为<strong>基本多语言平面</strong>（BMP）。为了表示更多的字符，Unicode 采用了一个策略，即每个字符使用另外 16 位去选择一个<strong>增补平面</strong>。这种每个字符使用两个 16 位码元的策略称为<strong>代理对</strong>。</p> <p>在涉及增补平面的字符时，前面讨论的字符串方法就会出问题。比如，下面的例子中使用了一个笑脸表情符号，也就是一个使用代理对编码的字符：</p> <div class="language- extra-class"><pre class="language-text"><code>// &quot;smiling face with smiling eyes&quot; 表情符号的编码是U+1F60A
// 0x1F60A === 128522
let message = &quot;ab☺de&quot;;

console.log(message.length);          // 6
console.log(message.charAt(1));       // b
console.log(message.charAt(2));       // &lt;?&gt;
console.log(message.charAt(3));       // &lt;?&gt;
console.log(message.charAt(4));       // d

console.log(message.charCodeAt(1));   // 98
console.log(message.charCodeAt(2));   // 55357
console.log(message.charCodeAt(3));   // 56842
console.log(message.charCodeAt(4));   // 100

console.log(String.fromCodePoint(0x1F60A)); // ☺

console.log(String.fromCharCode(97, 98, 55357, 56842, 100, 101)); // ab☺de
</code></pre></div><p>这些方法仍然将 16 位码元当作一个字符，事实上索引 2 和索引 3 对应的码元应该被看成一个代理对，只对应一个字符。<code>fromCharCode()</code>方法仍然返回正确的结果，因为它实际上是基于提供的二进制表示直接组合成字符串。浏览器可以正确解析代理对（由两个码元构成），并正确地将其识别为一个 Unicode 笑脸字符。</p> <p>为正确解析既包含单码元字符又包含代理对字符的字符串，可以使用<code>codePointAt()</code>来代替<code>charCodeAt()</code>。跟使用<code>charCodeAt()</code>时类似，<code>codePointAt()</code>接收 16 位码元的索引并返回该索引位置上的码点（code point）。<strong>码点</strong>是 Unicode 中一个字符的完整标识。比如，<code>&quot;c&quot;</code>的码点是 0x0063，而&quot;☺&quot;的码点是 0x1F60A。码点可能是 16 位，也可能是 32 位，而<code>codePointAt()</code>方法可以从指定码元位置识别完整的码点。</p> <div class="language- extra-class"><pre class="language-text"><code>let message = &quot;ab☺de&quot;;

console.log(message.codePointAt(1)); // 98
console.log(message.codePointAt(2)); // 128522
console.log(message.codePointAt(3)); // 56842
console.log(message.codePointAt(4)); // 100
</code></pre></div><p>注意，如果传入的码元索引并非代理对的开头，就会返回错误的码点。这种错误只有检测单个字符的时候才会出现，可以通过从左到右按正确的码元数遍历字符串来规避。迭代字符串可以智能地识别代理对的码点：</p> <div class="language- extra-class"><pre class="language-text"><code>console.log([...&quot;ab☺de&quot;]); // [&quot;a&quot;, &quot;b&quot;, &quot;☺&quot;, &quot;d&quot;, &quot;e&quot;]
</code></pre></div><p>与<code>charCodeAt()</code>有对应的<code>codePointAt()</code>一样，<code>fromCharCode()</code>也有一个对应的<code>fromCodePoint()</code>。这个方法接收任意数量的码点，返回对应字符拼接起来的字符串：</p> <div class="language- extra-class"><pre class="language-text"><code>console.log(String.fromCharCode(97, 98, 55357, 56842, 100, 101));  // ab☺de
console.log(String.fromCodePoint(97, 98, 128522, 100, 101));       // ab☺de
</code></pre></div></li></ol> <ol start="2"><li><p><strong>normalize()方法</strong></p> <p>某些 Unicode 字符可以有多种编码方式。有的字符既可以通过一个 BMP 字符表示，也可以通过一个代理对表示。比如：</p> <div class="language- extra-class"><pre class="language-text"><code>// U+00C5：上面带圆圈的大写拉丁字母A
console.log(String.fromCharCode(0x00C5));          // Å

// U+212B：长度单位“埃”
console.log(String.fromCharCode(0x212B));          // Å

// U+004：大写拉丁字母A
// U+030A：上面加个圆圈
console.log(String.fromCharCode(0x0041, 0x030A));  // Å
</code></pre></div><p>比较操作符不在乎字符看起来是什么样的，因此这 3 个字符互不相等。</p> <div class="language- extra-class"><pre class="language-text"><code>let a1 = String.fromCharCode(0x00C5),
    a2 = String.fromCharCode(0x212B),
    a3 = String.fromCharCode(0x0041, 0x030A);

console.log(a1, a2, a3); // Å, Å, Å

console.log(a1 === a2);  // false
console.log(a1 === a3);  // false
console.log(a2 === a3);  // false
</code></pre></div><p>为解决这个问题，Unicode 提供了 4 种规范化形式，可以将类似上面的字符规范化为一致的格式，无论底层字符的代码是什么。这 4 种规范化形式是：NFD（Normalization Form D）、NFC（Normalization Form C）、NFKD（Normalization Form KD）和 NFKC（Normalization Form KC）。可以使用<code>normalize()</code>方法对字符串应用上述规范化形式，使用时需要传入表示哪种形式的字符串：<code>&quot;NFD&quot;</code>、<code>&quot;NFC&quot;</code>、<code>&quot;NFKD&quot;</code>或<code>&quot;NFKC&quot;</code>。</p> <blockquote><p><strong>注意</strong>　这 4 种规范化形式的具体细节超出了本书范围，有兴趣的读者可以自行参考<em>UAX 15#: Unicode Normalization Forms</em>中的 1.2 节“Normalization Forms”。</p></blockquote> <p>通过比较字符串与其调用<code>normalize()</code>的返回值，就可以知道该字符串是否已经规范化了：</p> <div class="language- extra-class"><pre class="language-text"><code>let a1 = String.fromCharCode(0x00C5),
    a2 = String.fromCharCode(0x212B),
    a3 = String.fromCharCode(0x0041, 0x030A);

// U+00C5是对0+212B进行NFC/NFKC规范化之后的结果
console.log(a1 === a1.normalize(&quot;NFD&quot;));  // false
console.log(a1 === a1.normalize(&quot;NFC&quot;));  // true
console.log(a1 === a1.normalize(&quot;NFKD&quot;)); // false
console.log(a1 === a1.normalize(&quot;NFKC&quot;)); // true

// U+212B是未规范化的
console.log(a2 === a2.normalize(&quot;NFD&quot;));  // false
console.log(a2 === a2.normalize(&quot;NFC&quot;));  // false
console.log(a2 === a2.normalize(&quot;NFKD&quot;)); // false
console.log(a2 === a2.normalize(&quot;NFKC&quot;)); // false

// U+0041/U+030A是对0+212B进行NFD/NFKD规范化之后的结果
console.log(a3 === a3.normalize(&quot;NFD&quot;));  // true
console.log(a3 === a3.normalize(&quot;NFC&quot;));  // false
console.log(a3 === a3.normalize(&quot;NFKD&quot;)); // true
console.log(a3 === a3.normalize(&quot;NFKC&quot;)); // false
</code></pre></div><p>选择同一种规范化形式可以让比较操作符返回正确的结果：</p> <div class="language- extra-class"><pre class="language-text"><code>let a1 = String.fromCharCode(0x00C5),
    a2 = String.fromCharCode(0x212B),
    a3 = String.fromCharCode(0x0041, 0x030A);

console.log(a1.normalize(&quot;NFD&quot;) === a2.normalize(&quot;NFD&quot;));    // true
console.log(a2.normalize(&quot;NFKC&quot;) === a3.normalize(&quot;NFKC&quot;));  // true
console.log(a1.normalize(&quot;NFC&quot;) === a3.normalize(&quot;NFC&quot;));    // true
</code></pre></div></li></ol> <ol start="3"><li><p><strong>字符串操作方法</strong></p> <p>本节介绍几个操作字符串值的方法。首先是<code>concat()</code>，用于将一个或多个字符串拼接成一个新字符串。来看下面的例子：</p> <div class="language- extra-class"><pre class="language-text"><code>let stringValue = &quot;hello &quot;;
let result = stringValue.concat(&quot;world&quot;);

console.log(result);      // &quot;hello world&quot;
console.log(stringValue); // &quot;hello&quot;
</code></pre></div><p>在这个例子中，对<code>stringValue</code>调用<code>concat()</code>方法的结果是得到<code>&quot;hello world&quot;</code>，但<code>stringValue</code>的值保持不变。<code>concat()</code>方法可以接收任意多个参数，因此可以一次性拼接多个字符串，如下所示：</p> <div class="language- extra-class"><pre class="language-text"><code>let stringValue = &quot;hello &quot;;
let result = stringValue.concat(&quot;world&quot;, &quot;!&quot;);

console.log(result);      // &quot;hello world!&quot;
console.log(stringValue); // &quot;hello&quot;
</code></pre></div><p>这个修改后的例子将字符串<code>&quot;world&quot;</code>和<code>&quot;!&quot;</code>追加到了<code>&quot;hello &quot;</code>后面。虽然<code>concat()</code>方法可以拼接字符串，但更常用的方式是使用加号操作符（<code>+</code>）。而且多数情况下，对于拼接多个字符串来说，使用加号更方便。</p> <p>ECMAScript 提供了 3 个从字符串中提取子字符串的方法：<code>slice()</code>、<code>substr()</code>和<code>substring()</code>。这 3 个方法都返回调用它们的字符串的一个子字符串，而且都接收一或两个参数。第一个参数表示子字符串开始的位置，第二个参数表示子字符串结束的位置。对<code>slice()</code>和<code>substring()</code>而言，第二个参数是提取结束的位置（即该位置之前的字符会被提取出来）。对<code>substr()</code>而言，第二个参数表示返回的子字符串数量。任何情况下，省略第二个参数都意味着提取到字符串末尾。与<code>concat()</code>方法一样，<code>slice()</code>、<code>substr()</code>和<code>substring()</code>也不会修改调用它们的字符串，而只会返回提取到的原始新字符串值。来看下面的例子：</p> <div class="language- extra-class"><pre class="language-text"><code>let stringValue = &quot;hello world&quot;;
console.log(stringValue.slice(3));       // &quot;lo world&quot;
console.log(stringValue.substring(3));   // &quot;lo world&quot;
console.log(stringValue.substr(3));      // &quot;lo world&quot;
console.log(stringValue.slice(3, 7));    // &quot;lo w&quot;
console.log(stringValue.substring(3,7)); // &quot;lo w&quot;
console.log(stringValue.substr(3, 7));   // &quot;lo worl&quot;
</code></pre></div><p>在这个例子中，<code>slice()</code>、<code>substr()</code>和<code>substring()</code>是以相同方式被调用的，而且多数情况下返回的值也相同。如果只传一个参数<code>3</code>，则所有方法都将返回<code>&quot;lo world&quot;</code>，因为<code>&quot;hello&quot;</code>中<code>&quot;l&quot;</code>位置为 3。如果传入两个参数<code>3</code>和<code>7</code>，则<code>slice()</code>和<code>substring()</code>返回<code>&quot;lo w&quot;</code>（因为<code>&quot;world&quot;</code>中<code>&quot;o&quot;</code>在位置 7，不包含），而<code>substr()</code>返回<code>&quot;lo worl&quot;</code>，因为第二个参数对它而言表示返回的字符数。</p> <p>当某个参数是负值时，这 3 个方法的行为又有不同。比如，<code>slice()</code>方法将所有负值参数都当成字符串长度加上负参数值。</p> <p>而<code>substr()</code>方法将第一个负参数值当成字符串长度加上该值，将第二个负参数值转换为 0。<code>substring()</code>方法会将所有负参数值都转换为 0。看下面的例子：</p> <div class="language- extra-class"><pre class="language-text"><code>let stringValue = &quot;hello world&quot;;
console.log(stringValue.slice(-3));         // &quot;rld&quot;
console.log(stringValue.substring(-3));     // &quot;hello world&quot;
console.log(stringValue.substr(-3));        // &quot;rld&quot;
console.log(stringValue.slice(3, -4));      // &quot;lo w&quot;
console.log(stringValue.substring(3, -4));  // &quot;hel&quot;
console.log(stringValue.substr(3, -4));     // &quot;&quot; (empty string)
</code></pre></div><p>这个例子明确演示了 3 个方法的差异。在给<code>slice()</code>和<code>substr()</code>传入负参数时，它们的返回结果相同。这是因为<code>-3</code>会被转换为<code>8</code>（长度加上负参数），实际上调用的是<code>slice(8)</code>和<code>substr(8)</code>。而<code>substring()</code>方法返回整个字符串，因为<code>-3</code>会转换为<code>0</code>。</p> <p>在第二个参数是负值时，这 3 个方法各不相同。<code>slice()</code>方法将第二个参数转换为<code>7</code>，实际上相当于调用<code>slice(3, 7)</code>，因此返回<code>&quot;lo w&quot;</code>。而<code>substring()</code>方法会将第二个参数转换为<code>0</code>，相当于调用<code>substring(3, 0)</code>，等价于<code>substring(0, 3)</code>，这是因为这个方法会将较小的参数作为起点，将较大的参数作为终点。对<code>substr()</code>来说，第二个参数会被转换为<code>0</code>，意味着返回的字符串包含零个字符，因而会返回一个空字符串。</p></li></ol> <ol start="4"><li><p><strong>字符串位置方法</strong></p> <p>有两个方法用于在字符串中定位子字符串：<code>indexOf()</code>和<code>lastIndexOf()</code>。这两个方法从字符串中搜索传入的字符串，并返回位置（如果没找到，则返回<code>-1</code>）。两者的区别在于，<code>indexOf()</code>方法从字符串开头开始查找子字符串，而<code>lastIndexOf()</code>方法从字符串末尾开始查找子字符串。来看下面的例子：</p> <div class="language- extra-class"><pre class="language-text"><code>let stringValue = &quot;hello world&quot;;
console.log(stringValue.indexOf(&quot;o&quot;));     // 4
console.log(stringValue.lastIndexOf(&quot;o&quot;)); // 7
</code></pre></div><p>这里，字符串中第一个<code>&quot;o&quot;</code>的位置是 4，即<code>&quot;hello&quot;</code>中的<code>&quot;o&quot;</code>。最后一个<code>&quot;o&quot;</code>的位置是 7，即<code>&quot;world&quot;</code>中的<code>&quot;o&quot;</code>。如果字符串中只有一个<code>&quot;o&quot;</code>，则<code>indexOf()</code>和<code>lastIndexOf()</code>返回同一个位置。</p> <p>这两个方法都可以接收可选的第二个参数，表示开始搜索的位置。这意味着，<code>indexOf()</code>会从这个参数指定的位置开始向字符串末尾搜索，忽略该位置之前的字符；<code>lastIndexOf()</code>则会从这个参数指定的位置开始向字符串开头搜索，忽略该位置之后直到字符串末尾的字符。下面看一个例子：</p> <div class="language- extra-class"><pre class="language-text"><code>let stringValue = &quot;hello world&quot;;
console.log(stringValue.indexOf(&quot;o&quot;, 6));     // 7
console.log(stringValue.lastIndexOf(&quot;o&quot;, 6)); // 4
</code></pre></div><p>在传入第二个参数<code>6</code>以后，结果跟前面的例子恰好相反。这一次，<code>indexOf()</code>返回<code>7</code>，因为它从位置 6（字符<code>&quot;w&quot;</code>）开始向后搜索字符串，在位置 7 找到了<code>&quot;o&quot;</code>。而<code>lastIndexOf()</code>返回<code>4</code>，因为它从位置 6 开始反向搜索至字符串开头，因此找到了<code>&quot;hello&quot;</code>中的<code>&quot;o&quot;</code>。像这样使用第二个参数并循环调用<code>indexOf()</code>或<code>lastIndexOf()</code>，就可以在字符串中找到所有的目标子字符串，如下所示：</p> <div class="language- extra-class"><pre class="language-text"><code>let stringValue = &quot;Lorem ipsum dolor sit amet, consectetur adipisicing elit&quot;;
let positions = new Array();
let pos = stringValue.indexOf(&quot;e&quot;);

while(pos &gt; -1) {
  positions.push(pos);
  pos = stringValue.indexOf(&quot;e&quot;, pos + 1);
}

console.log(positions); // [3,24,32,35,52]
</code></pre></div><p>这个例子逐步增大开始搜索的位置，通过<code>indexOf()</code>遍历了整个字符串。首先取得第一个<code>&quot;e&quot;</code>的位置，然后进入循环，将上一次的位置加 1 再传给<code>indexOf()</code>，确保搜索到最后一个子字符串实例之后。每个位置都保存在<code>positions</code>数组中，可供以后使用。</p></li></ol> <ol start="5"><li><p><strong>字符串包含方法</strong></p> <p>ECMAScript 6 增加了 3 个用于判断字符串中是否包含另一个字符串的方法：<code>startsWith()</code>、<code>endsWith()</code>和<code>includes()</code>。这些方法都会从字符串中搜索传入的字符串，并返回一个表示是否包含的布尔值。它们的区别在于，<code>startsWith()</code>检查开始于索引 0 的匹配项，<code>endsWith()</code>检查开始于索引<code>(string.length - substring.length)</code>的匹配项，而<code>includes()</code>检查整个字符串：</p> <div class="language- extra-class"><pre class="language-text"><code>let message = &quot;foobarbaz&quot;;

console.log(message.startsWith(&quot;foo&quot;));  // true
console.log(message.startsWith(&quot;bar&quot;));  // false

console.log(message.endsWith(&quot;baz&quot;));    // true
console.log(message.endsWith(&quot;bar&quot;));    // false

console.log(message.includes(&quot;bar&quot;));    // true
console.log(message.includes(&quot;qux&quot;));    // false
</code></pre></div><p><code>startsWith()</code>和<code>includes()</code>方法接收可选的第二个参数，表示开始搜索的位置。如果传入第二个参数，则意味着这两个方法会从指定位置向着字符串末尾搜索，忽略该位置之前的所有字符。下面是一个例子：</p> <div class="language- extra-class"><pre class="language-text"><code>let message = &quot;foobarbaz&quot;;

console.log(message.startsWith(&quot;foo&quot;));     // true
console.log(message.startsWith(&quot;foo&quot;, 1));  // false

console.log(message.includes(&quot;bar&quot;));       // true
console.log(message.includes(&quot;bar&quot;, 4));    // false
</code></pre></div><p><code>endsWith()</code>方法接收可选的第二个参数，表示应该当作字符串末尾的位置。如果不提供这个参数，那么默认就是字符串长度。如果提供这个参数，那么就好像字符串只有那么多字符一样：</p> <div class="language- extra-class"><pre class="language-text"><code>let message = &quot;foobarbaz&quot;;

console.log(message.endsWith(&quot;bar&quot;));     // false
console.log(message.endsWith(&quot;bar&quot;, 6));  // true
</code></pre></div></li></ol> <ol start="6"><li><p><strong>trim()方法</strong></p> <p>ECMAScript 在所有字符串上都提供了<code>trim()</code>方法。这个方法会创建字符串的一个副本，删除前、后所有空格符，再返回结果。比如：</p> <div class="language- extra-class"><pre class="language-text"><code>let stringValue = &quot;  hello world  &quot;;
let trimmedStringValue = stringValue.trim();
console.log(stringValue);         // &quot;  hello world &quot;
console.log(trimmedStringValue);  // &quot;hello world&quot;
</code></pre></div><p>由于<code>trim()</code>返回的是字符串的副本，因此原始字符串不受影响，即原本的前、后空格符都会保留。</p> <p>另外，<code>trimeLeft()</code>和<code>trimRight()</code>方法分别用于从字符串开始和末尾清理空格符。</p></li></ol> <ol start="7"><li><p><strong>repeat()方法</strong></p> <p>ECMAScript 在所有字符串上都提供了<code>repeat()</code>方法。这个方法接收一个整数参数，表示要将字符串复制多少次，然后返回拼接所有副本后的结果。</p> <div class="language- extra-class"><pre class="language-text"><code>let stringValue = &quot;na &quot;;
console.log(stringValue.repeat(16) + &quot;batman&quot;);
// na na na na na na na na na na na na na na na na batman
</code></pre></div></li></ol> <ol start="8"><li><p><strong>padStart()和 padEnd()方法</strong></p> <p><code>padStart()</code>和<code>padEnd()</code>方法会复制字符串，如果小于指定长度，则在相应一边填充字符，直至满足长度条件。这两个方法的第一个参数是长度，第二个参数是可选的填充字符串，默认为空格（U+0020）。</p> <div class="language- extra-class"><pre class="language-text"><code>let stringValue = &quot;foo&quot;;

console.log(stringValue.padStart(6));       // &quot;   foo&quot;
console.log(stringValue.padStart(9, &quot;.&quot;));  // &quot;......foo&quot;

console.log(stringValue.padEnd(6));         // &quot;foo   &quot;
console.log(stringValue.padEnd(9, &quot;.&quot;));    // &quot;foo......&quot;
</code></pre></div><p>可选的第二个参数并不限于一个字符。如果提供了多个字符的字符串，则会将其拼接并截断以匹配指定长度。此外，如果长度小于或等于字符串长度，则会返回原始字符串。</p> <div class="language- extra-class"><pre class="language-text"><code>let stringValue = &quot;foo&quot;;

console.log(stringValue.padStart(8, &quot;bar&quot;)); // &quot;barbafoo&quot;
console.log(stringValue.padStart(2));        // &quot;foo&quot;

console.log(stringValue.padEnd(8, &quot;bar&quot;));   // &quot;foobarba&quot;
console.log(stringValue.padEnd(2));          // &quot;foo&quot;
</code></pre></div></li></ol> <ol start="9"><li><p><strong>字符串迭代与解构</strong></p> <p>字符串的原型上暴露了一个<code>@@iterator</code>方法，表示可以迭代字符串的每个字符。可以像下面这样手动使用迭代器：</p> <div class="language- extra-class"><pre class="language-text"><code>let message = &quot;abc&quot;;
let stringIterator = message[Symbol.iterator]();

console.log(stringIterator.next());  // {value: &quot;a&quot;, done: false}
console.log(stringIterator.next());  // {value: &quot;b&quot;, done: false}
console.log(stringIterator.next());  // {value: &quot;c&quot;, done: false}
console.log(stringIterator.next());  // {value: undefined, done: true}
</code></pre></div><p>在<code>for-of</code>循环中可以通过这个迭代器按序访问每个字符：</p> <div class="language- extra-class"><pre class="language-text"><code>for (const c of &quot;abcde&quot;) {
  console.log(c);
}

// a
// b
// c
// d
// e
</code></pre></div><p>有了这个迭代器之后，字符串就可以通过解构操作符来解构了。比如，可以更方便地把字符串分割为字符数组：</p> <div class="language- extra-class"><pre class="language-text"><code>let message = &quot;abcde&quot;;

console.log([...message]); // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;]
</code></pre></div></li></ol> <ol start="10"><li><p><strong>字符串大小写转换</strong></p> <p>下一组方法涉及大小写转换，包括 4 个方法：<code>toLowerCase()</code>、<code>toLocaleLowerCase()</code>、<code>toUpperCase()</code>和<code>toLocaleUpperCase()</code>。<code>toLowerCase()</code>和<code>toUpperCase()</code>方法是原来就有的方法，与<code>java.lang.String</code>中的方法同名。<code>toLocaleLowerCase()</code>和<code>toLocaleUpperCase()</code>方法旨在基于特定地区实现。在很多地区，地区特定的方法与通用的方法是一样的。但在少数语言中（如土耳其语），Unicode 大小写转换需应用特殊规则，要使用地区特定的方法才能实现正确转换。下面是几个例子：</p> <div class="language- extra-class"><pre class="language-text"><code>let stringValue = &quot;hello world&quot;;
console.log(stringValue.toLocaleUpperCase());  // &quot;HELLO WORLD&quot;
console.log(stringValue.toUpperCase());        // &quot;HELLO WORLD&quot;
console.log(stringValue.toLocaleLowerCase());  // &quot;hello world&quot;
console.log(stringValue.toLowerCase());        // &quot;hello world&quot;
</code></pre></div><p>这里，<code>toLowerCase()</code>和<code>toLocaleLowerCase()</code>都返回<code>hello world</code>，而<code>toUpperCase()</code>和<code>toLocaleUpperCase()</code>都返回<code>HELLO WORLD</code>。通常，如果不知道代码涉及什么语言，则最好使用地区特定的转换方法。</p></li></ol> <ol start="11"><li><p><strong>字符串模式匹配方法</strong></p> <p><code>String</code>类型专门为在字符串中实现模式匹配设计了几个方法。第一个就是<code>match()</code>方法，这个方法本质上跟<code>RegExp</code>对象的<code>exec()</code>方法相同。<code>match()</code>方法接收一个参数，可以是一个正则表达式字符串，也可以是一个<code>RegExp</code>对象。来看下面的例子：</p> <div class="language- extra-class"><pre class="language-text"><code>let text = &quot;cat, bat, sat, fat&quot;;
let pattern = /.at/;

// 等价于pattern.exec(text)
let matches = text.match(pattern);
console.log(matches.index);      // 0
console.log(matches[0]);         // &quot;cat&quot;
console.log(pattern.lastIndex);  // 0
</code></pre></div><p><code>match()</code>方法返回的数组与<code>RegExp</code>对象的<code>exec()</code>方法返回的数组是一样的：第一个元素是与整个模式匹配的字符串，其余元素则是与表达式中的捕获组匹配的字符串（如果有的话）。</p> <p>另一个查找模式的字符串方法是<code>search()</code>。这个方法唯一的参数与<code>match()</code>方法一样：正则表达式字符串或<code>RegExp</code>对象。这个方法返回模式第一个匹配的位置索引，如果没找到则返回-1。<code>search()</code>始终从字符串开头向后匹配模式。看下面的例子：</p> <div class="language- extra-class"><pre class="language-text"><code>let text = &quot;cat, bat, sat, fat&quot;;
let pos = text.search(/at/);
console.log(pos);  // 1
</code></pre></div><p>这里，<code>search(/at/)</code>返回<code>1</code>，即<code>&quot;at&quot;</code>的第一个字符在字符串中的位置。</p> <p>为简化子字符串替换操作，ECMAScript 提供了<code>replace()</code>方法。这个方法接收两个参数，第一个参数可以是一个<code>RegExp</code>对象或一个字符串（这个字符串不会转换为正则表达式），第二个参数可以是一个字符串或一个函数。如果第一个参数是字符串，那么只会替换第一个子字符串。要想替换所有子字符串，第一个参数必须为正则表达式并且带全局标记，如下面的例子所示：</p> <div class="language- extra-class"><pre class="language-text"><code>let text = &quot;cat, bat, sat, fat&quot;;
let result = text.replace(&quot;at&quot;, &quot;ond&quot;);
console.log(result);  // &quot;cond, bat, sat, fat&quot;

result = text.replace(/at/g, &quot;ond&quot;);
console.log(result);  // &quot;cond, bond, sond, fond&quot;
</code></pre></div><p>在这个例子中，字符串<code>&quot;at&quot;</code>先传给<code>replace()</code>函数，而替换文本是<code>&quot;ond&quot;</code>。结果是<code>&quot;cat&quot;</code>被修改为<code>&quot;cond&quot;</code>，而字符串的剩余部分保持不变。通过将第一个参数改为带全局标记的正则表达式，字符串中的所有<code>&quot;at&quot;</code>都被替换成了<code>&quot;ond&quot;</code>。</p> <p>第二个参数是字符串的情况下，有几个特殊的字符序列，可以用来插入正则表达式操作的值。ECMA-262 中规定了下表中的值。</p> <table><thead><tr><th style="text-align:left;">字符序列</th> <th style="text-align:left;">替换文本</th></tr></thead> <tbody><tr><td style="text-align:left;"><code>$$</code></td> <td style="text-align:left;"><code>$</code></td></tr> <tr><td style="text-align:left;"><code>$&amp;</code></td> <td style="text-align:left;">匹配整个模式的子字符串。与<code>RegExp.lastMatch</code>相同</td></tr> <tr><td style="text-align:left;"><code>$'</code></td> <td style="text-align:left;">匹配的子字符串之前的字符串。与<code>RegExp.rightContext</code>相同</td></tr> <tr><td style="text-align:left;"><code>\$`` | 匹配的子字符串之后的字符串。与</code>RegExp.leftContext`相同</td> <td style="text-align:left;"></td></tr> <tr><td style="text-align:left;"><code>$*n*</code></td> <td style="text-align:left;">匹配第<code>*n*</code>个捕获组的字符串，其中<code>*n*</code>是 0~9。比如，<code>$1</code>是匹配第一个捕获组的字符串，<code>$2</code>是匹配第二个捕获组的字符串，以此类推。如果没有捕获组，则值为空字符串</td></tr> <tr><td style="text-align:left;"><code>$*nn*</code></td> <td style="text-align:left;">匹配第<code>*nn*</code>个捕获组字符串，其中<code>*nn*</code>是 01~99。比如，<code>$01</code>是匹配第一个捕获组的字符串，<code>$02</code>是匹配第二个捕获组的字符串，以此类推。如果没有捕获组，则值为空字符串</td></tr></tbody></table> <p>使用这些特殊的序列，可以在替换文本中使用之前匹配的内容，如下面的例子所示：</p> <div class="language- extra-class"><pre class="language-text"><code>let text = &quot;cat, bat, sat, fat&quot;;
result = text.replace(/(.at)/g, &quot;word ($1)&quot;);
console.log(result);  // word (cat), word (bat), word (sat), word (fat)
</code></pre></div><p>这里，每个以<code>&quot;at&quot;</code>结尾的词都会被替换成<code>&quot;word&quot;</code>后跟一对小括号，其中包含捕获组匹配的内容<code>$1</code>。</p> <p><code>replace()</code>的第二个参数可以是一个函数。在只有一个匹配项时，这个函数会收到 3 个参数：与整个模式匹配的字符串、匹配项在字符串中的开始位置，以及整个字符串。在有多个捕获组的情况下，每个匹配捕获组的字符串也会作为参数传给这个函数，但最后两个参数还是与整个模式匹配的开始位置和原始字符串。这个函数应该返回一个字符串，表示应该把匹配项替换成什么。使用函数作为第二个参数可以更细致地控制替换过程，如下所示：</p> <div class="language- extra-class"><pre class="language-text"><code>function htmlEscape(text) {
  return text.replace(/[&lt;&gt;&quot;&amp;]/g, function(match, pos, originalText) {
    switch(match) {
      case &quot;&lt;&quot;:
        return &quot;&amp;lt;&quot;;
      case &quot;&gt;&quot;:
        return &quot;&amp;gt;&quot;;
      case &quot;&amp;&quot;:
        return &quot;&amp;amp;&quot;;
      case &quot;\&quot;&quot;:
        return &quot;&amp;quot;&quot;;
    }
  });
}

console.log(htmlEscape(&quot;&lt;p class=\&quot;greeting\&quot;&gt;Hello world!&lt;/p&gt;&quot;));
// &quot;&amp;lt;p class=&amp;quot;greeting&amp;quot;&amp;gt;Hello world!&lt;/p&gt;&quot;
</code></pre></div><p>这里，函数<code>htmlEscape()</code>用于将一段 HTML 中的 4 个字符替换成对应的实体：小于号、大于号、和号，还有双引号（都必须经过转义）。实现这个任务最简单的办法就是用一个正则表达式查找这些字符，然后定义一个函数，根据匹配的每个字符分别返回特定的 HTML 实体。</p> <p>最后一个与模式匹配相关的字符串方法是<code>split()</code>。这个方法会根据传入的分隔符将字符串拆分成数组。作为分隔符的参数可以是字符串，也可以是<code>RegExp</code>对象。（字符串分隔符不会被这个方法当成正则表达式。）还可以传入第二个参数，即数组大小，确保返回的数组不会超过指定大小。来看下面的例子：</p> <div class="language- extra-class"><pre class="language-text"><code>let colorText = &quot;red,blue,green,yellow&quot;;
let colors1 = colorText.split(&quot;,&quot;);       // [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;yellow&quot;]
let colors2 = colorText.split(&quot;,&quot;, 2);    // [&quot;red&quot;, &quot;blue&quot;]
let colors3 = colorText.split(/[^,]+/);   // [&quot;&quot;, &quot;,&quot;, &quot;,&quot;, &quot;,&quot;, &quot;&quot;]
</code></pre></div><p>在这里，字符串<code>colorText</code>是一个逗号分隔的颜色名称符串。调用<code>split(&quot;,&quot;)</code>会得到包含这些颜色名的数组，基于逗号进行拆分。要把数组元素限制为 2 个，传入第二个参数 2 即可。最后，使用正则表达式可以得到一个包含逗号的数组。注意在最后一次调用<code>split()</code>时，返回的数组前后包含两个空字符串。这是因为正则表达式指定的分隔符出现在了字符串开头（<code>&quot;red&quot;</code>）和末尾（<code>&quot;yellow&quot;</code>）。</p></li></ol> <ol start="12"><li><p><strong>localeCompare()方法</strong></p> <p>最后一个方法是<code>localeCompare()</code>，这个方法比较两个字符串，返回如下 3 个值中的一个。</p> <ul><li>如果按照字母表顺序，字符串应该排在字符串参数前头，则返回负值。（通常是<code>-1</code>，具体还要看与实际值相关的实现。）</li> <li>如果字符串与字符串参数相等，则返回<code>0</code>。</li> <li>如果按照字母表顺序，字符串应该排在字符串参数后头，则返回正值。（通常是<code>1</code>，具体还要看与实际值相关的实现。）</li></ul> <p>下面是一个例子：</p> <div class="language- extra-class"><pre class="language-text"><code>let stringValue = &quot;yellow&quot;;
console.log(stringValue.localeCompare(&quot;brick&quot;));  // 1
console.log(stringValue.localeCompare(&quot;yellow&quot;)); // 0
console.log(stringValue.localeCompare(&quot;zoo&quot;));    // -1
</code></pre></div><p>在这里，字符串<code>&quot;yellow&quot;</code>与 3 个不同的值进行了比较：<code>&quot;brick&quot;</code>、<code>&quot;yellow&quot;</code>和<code>&quot;zoo&quot;</code>。<code>&quot;brick&quot;</code>按字母表顺序应该排在<code>&quot;yellow&quot;</code>前头，因此<code>localeCompare()</code>返回 1。<code>&quot;yellow&quot;</code>等于<code>&quot;yellow&quot;</code>，因此<code>&quot;localeCompare()&quot;</code>返回<code>0</code>。最后，<code>&quot;zoo&quot;</code>在<code>&quot;yellow&quot;</code>后面，因此<code>localeCompare()</code>返回<code>-1</code>。强调一下，因为返回的具体值可能因具体实现而异，所以最好像下面的示例中一样使用<code>localeCompare()</code>：</p> <div class="language- extra-class"><pre class="language-text"><code>function determineOrder(value) {
  let result = stringValue.localeCompare(value);
  if (result &lt; 0) {
    console.log(`The string 'yellow' comes before the string '${value}'.`);
  } else if (result &gt; 0) {
    console.log(`The string 'yellow' comes after the string '${value}'.`);
  } else {
    console.log(`The string 'yellow' is equal to the string '${value}'.`);
  }
}

determineOrder(&quot;brick&quot;);
determineOrder(&quot;yellow&quot;);
determineOrder(&quot;zoo&quot;);
</code></pre></div><p>这样一来，就可以保证在所有实现中都能正确判断字符串的顺序了。</p> <p><code>localeCompare()</code>的独特之处在于，实现所在的地区（国家和语言）决定了这个方法如何比较字符串。在美国，英语是 ECMAScript 实现的标准语言，<code>localeCompare()</code>区分大小写，大写字母排在小写字母前面。但其他地区未必是这种情况。</p></li></ol> <ol start="13"><li><p><strong>HTML 方法</strong></p> <p>早期的浏览器开发商认为使用 JavaScript 动态生成 HTML 标签是一个需求。因此，早期浏览器扩展了规范，增加了辅助生成 HTML 标签的方法。下表总结了这些 HTML 方法。不过，这些方法基本上已经没有人使用了，因为结果通常不是语义化的标记。</p> <table><thead><tr><th style="text-align:left;">方法</th> <th style="text-align:left;">输出</th></tr></thead> <tbody><tr><td style="text-align:left;"><code>anchor(*name*)</code></td> <td style="text-align:left;"><code>&lt;a name=&quot;*name*&quot;&gt;*string*&lt;/a&gt;</code></td></tr> <tr><td style="text-align:left;"><code>big()</code></td> <td style="text-align:left;"><code>&lt;big&gt;*string*&lt;/big&gt;</code></td></tr> <tr><td style="text-align:left;"><code>bold()</code></td> <td style="text-align:left;"><code>&lt;b&gt;*string*&lt;/b&gt;</code></td></tr> <tr><td style="text-align:left;"><code>fixed()</code></td> <td style="text-align:left;"><code>&lt;tt&gt;*string*&lt;/tt&gt;</code></td></tr> <tr><td style="text-align:left;"><code>fontcolor(*color*)</code></td> <td style="text-align:left;"><code>&lt;font color=&quot;*color*&quot;&gt;*string*&lt;/font&gt;</code></td></tr> <tr><td style="text-align:left;"><code>fontsize(*size*)</code></td> <td style="text-align:left;"><code>&lt;font size=&quot;*size*&quot;&gt;*string*&lt;/font&gt;</code></td></tr> <tr><td style="text-align:left;"><code>italics()</code></td> <td style="text-align:left;"><code>&lt;i&gt;*string*&lt;/i&gt;</code></td></tr> <tr><td style="text-align:left;"><code>link(url)</code></td> <td style="text-align:left;"><code>&lt;a href=&quot;*url*&quot;&gt;*string*&lt;/a&gt;</code></td></tr> <tr><td style="text-align:left;"><code>small()</code></td> <td style="text-align:left;"><code>&lt;small&gt;*string*&lt;/small&gt;</code></td></tr> <tr><td style="text-align:left;"><code>strike()</code></td> <td style="text-align:left;"><code>&lt;strike&gt;*string*&lt;/strike&gt;</code></td></tr> <tr><td style="text-align:left;"><code>sub()</code></td> <td style="text-align:left;"><code>&lt;sub&gt;*string*&lt;/sub&gt;</code></td></tr> <tr><td style="text-align:left;"><code>sup()</code></td> <td style="text-align:left;"><code>&lt;sup&gt;*string*&lt;/sup&gt;</code></td></tr></tbody></table></li></ol> <h2 id="_5-4-单例内置对象"><a href="#_5-4-单例内置对象" class="header-anchor">#</a> 5.4 　单例内置对象</h2> <p>ECMA-262 对内置对象的定义是“任何由 ECMAScript 实现提供、与宿主环境无关，并在 ECMAScript 程序开始执行时就存在的对象”。这就意味着，开发者不用显式地实例化内置对象，因为它们已经实例化好了。前面我们已经接触了大部分内置对象，包括<code>Object</code>、<code>Array</code>和<code>String</code>。本节介绍 ECMA-262 定义的另外两个单例内置对象：<code>Global</code>和<code>Math</code>。</p> <h3 id="_5-4-1-global"><a href="#_5-4-1-global" class="header-anchor">#</a> 5.4.1 　<code>Global</code></h3> <p><code>Global</code>对象是 ECMAScript 中最特别的对象，因为代码不会显式地访问它。ECMA-262 规定<code>Global</code>对象为一种兜底对象，它所针对的是不属于任何对象的属性和方法。事实上，不存在全局变量或全局函数这种东西。在全局作用域中定义的变量和函数都会变成<code>Global</code>对象的属性 。本书前面介绍的函数，包括<code>isNaN()</code>、<code>isFinite()</code>、<code>parseInt()</code>和<code>parseFloat()</code>，实际上都是<code>Global</code>对象的方法。除了这些，<code>Global</code>对象上还有另外一些方法。</p> <ol><li><p><strong>URL 编码方法</strong></p> <p><code>encodeURI()</code>和<code>encodeURIComponent()</code>方法用于编码统一资源标识符（URI），以便传给浏览器。有效的 URI 不能包含某些字符，比如空格。使用 URI 编码方法来编码 URI 可以让浏览器能够理解它们，同时又以特殊的 UTF-8 编码替换掉所有无效字符。</p> <p><code>ecnodeURI()</code>方法用于对整个 URI 进行编码，比如<code>&quot;www.wrox.com/illegal value.js&quot;</code>。而<code>encodeURIComponent()</code>方法用于编码 URI 中单独的组件，比如前面 URL 中的<code>&quot;illegal value.js&quot;</code>。这两个方法的主要区别是，<code>encodeURI()</code>不会编码属于 URL 组件的特殊字符，比如冒号、斜杠、问号、井号，而<code>encodeURIComponent()</code>会编码它发现的所有非标准字符。来看下面的例子：</p> <div class="language- extra-class"><pre class="language-text"><code>let uri = &quot;http:// www.wrox.com/illegal value.js#start&quot;;

// &quot;http:// www.wrox.com/illegal%20value.js#start&quot;
console.log(encodeURI(uri));

// &quot;http%3A%2F%2Fwww.wrox.com%2Fillegal%20value.js%23start&quot;
console.log(encodeURIComponent(uri));
</code></pre></div><p>这里使用<code>encodeURI()</code>编码后，除空格被替换为<code>%20</code>之外，没有任何变化。而<code>ecnodeURIComponent()</code>方法将所有非字母字符都替换成了相应的编码形式。这就是使用<code>encodeURI()</code>编码整个 URI，但只使用<code>encodeURIComponent()</code>编码那些会追加到已有 URI 后面的字符串的原因。</p> <blockquote><p><strong>注意</strong>　一般来说，使用<code>encodeURIComponent()</code>应该比使用<code>encodeURI()</code>的频率更高，这是因为编码查询字符串参数比编码基准 URI 的次数更多。</p></blockquote> <p>与<code>encodeURI()</code>和<code>encodeURIComponent()</code>相对的是<code>decodeURI()</code>和<code>decodeURIComponent()</code>。<code>decodeURI()</code>只对使用<code>encodeURI()</code>编码过的字符解码。例如，<code>%20</code>会被替换为空格，但<code>%23</code>不会被替换为井号（<code>#</code>），因为井号不是由<code>encodeURI()</code>替换的。类似地，<code>decodeURIComponent()</code>解码所有被<code>encodeURIComponent()</code>编码的字符，基本上就是解码所有特殊值。来看下面的例子：</p> <div class="language- extra-class"><pre class="language-text"><code>let uri = &quot;http%3A%2F%2Fwww.wrox.com%2Fillegal%20value.js%23start&quot;;

// http%3A%2F%2Fwww.wrox.com%2Fillegal value.js%23start
console.log(decodeURI(uri));

// http:// www.wrox.com/illegal value.js#start
console.log(decodeURIComponent(uri));
</code></pre></div><p>这里，<code>uri</code>变量中包含一个使用<code>encodeURIComponent()</code>编码过的字符串。首先输出的是使用<code>decodeURI()</code>解码的结果，可以看到只用空格替换了<code>%20</code>。然后是使用<code>decodeURIComponent()</code>解码的结果，其中替换了所有特殊字符，并输出了没有包含任何转义的字符串。（这个字符串不是有效的 URL。）</p> <blockquote><p><strong>注意</strong>　 URI 方法<code>encodeURI()</code>、<code>encodeURIComponent()</code>、<code>decodeURI()</code>和<code>decodeURIComponent()</code>取代了<code>escape()</code>和<code>unescape()</code>方法，后者在 ECMA-262 第 3 版中就已经废弃了。URI 方法始终是首选方法，因为它们对所有 Unicode 字符进行编码，而原来的方法只能正确编码 ASCII 字符。不要在生产环境中使用<code>escape()</code>和<code>unescape()</code>。</p></blockquote></li></ol> <ol start="2"><li><p><strong>eval()方法</strong></p> <p>最后一个方法可能是整个 ECMAScript 语言中最强大的了，它就是<code>eval()</code>。这个方法就是一个完整的 ECMAScript 解释器，它接收一个参数，即一个要执行的 ECMAScript（JavaScript）字符串。来看一个例子：</p> <div class="language- extra-class"><pre class="language-text"><code>eval(&quot;console.log('hi')&quot;);
</code></pre></div><p>上面这行代码的功能与下一行等价：</p> <div class="language- extra-class"><pre class="language-text"><code>console.log(&quot;hi&quot;);
</code></pre></div><p>当解释器发现<code>eval()</code>调用时，会将参数解释为实际的 ECMAScript 语句，然后将其插入到该位置。通过<code>eval()</code>执行的代码属于该调用所在上下文，被执行的代码与该上下文拥有相同的作用域链。这意味着定义在包含上下文中的变量可以在<code>eval()</code>调用内部被引用，比如下面这个例子：</p> <div class="language- extra-class"><pre class="language-text"><code>let msg = &quot;hello world&quot;;
eval(&quot;console.log(msg)&quot;);  // &quot;hello world&quot;
</code></pre></div><p>这里，变量<code>msg</code>是在<code>eval()</code>调用的外部上下文中定义的，而<code>console.log()</code>显示了文本<code>&quot;hello world&quot;</code>。这是因为第二行代码会被替换成一行真正的函数调用代码。类似地，可以在<code>eval()</code>内部定义一个函数或变量，然后在外部代码中引用，如下所示：</p> <div class="language- extra-class"><pre class="language-text"><code>eval(&quot;function sayHi() { console.log('hi'); }&quot;);
sayHi();
</code></pre></div><p>这里，函数<code>sayHi()</code>是在<code>eval()</code>内部定义的。因为该调用会被替换为真正的函数定义，所以才可能在下一行代码中调用<code>sayHi()</code>。对于变量也是一样的：</p> <div class="language- extra-class"><pre class="language-text"><code>eval(&quot;let msg = 'hello world';&quot;);
console.log(msg);  // Reference Error: msg is not defined
</code></pre></div><p>通过<code>eval()</code>定义的任何变量和函数都不会被提升，这是因为在解析代码的时候，它们是被包含在一个字符串中的。它们只是在<code>eval()</code>执行的时候才会被创建。</p> <p>在严格模式下，在<code>eval()</code>内部创建的变量和函数无法被外部访问。换句话说，最后两个例子会报错。同样，在严格模式下，赋值给<code>eval</code>也会导致错误：</p> <div class="language- extra-class"><pre class="language-text"><code>&quot;use strict&quot;;
eval = &quot;hi&quot;;  // 导致错误
</code></pre></div><blockquote><p><strong>注意</strong>　解释代码字符串的能力是非常强大的，但也非常危险。在使用<code>eval()</code>的时候必须极为慎重，特别是在解释用户输入的内容时。因为这个方法会对 XSS 利用暴露出很大的攻击面。恶意用户可能插入会导致你网站或应用崩溃的代码。</p></blockquote></li></ol> <ol start="3"><li><p><strong>Global 对象属性</strong></p> <p><code>Global</code>对象有很多属性，其中一些前面已经提到过了。像<code>undefined</code>、<code>NaN</code>和<code>Infinity</code>等特殊值都是<code>Global</code>对象的属性。此外，所有原生引用类型构造函数，比如<code>Object</code>和<code>Function</code>，也都是<code>Global</code>对象的属性。下表列出了所有这些属性。</p> <table><thead><tr><th style="text-align:left;">属性</th> <th style="text-align:left;">说明</th></tr></thead> <tbody><tr><td style="text-align:left;"><code>undefined</code></td> <td style="text-align:left;">特殊值<code>undefined</code></td></tr> <tr><td style="text-align:left;"><code>NaN</code></td> <td style="text-align:left;">特殊值<code>NaN</code></td></tr> <tr><td style="text-align:left;"><code>Infinity</code></td> <td style="text-align:left;">特殊值<code>Infinity</code></td></tr> <tr><td style="text-align:left;"><code>Object</code></td> <td style="text-align:left;"><code>Object</code>的构造函数</td></tr> <tr><td style="text-align:left;"><code>Array</code></td> <td style="text-align:left;"><code>Array</code>的构造函数</td></tr> <tr><td style="text-align:left;"><code>Function</code></td> <td style="text-align:left;"><code>Function</code>的构造函数</td></tr> <tr><td style="text-align:left;"><code>Boolean</code></td> <td style="text-align:left;"><code>Boolean</code>的构造函数</td></tr> <tr><td style="text-align:left;"><code>String</code></td> <td style="text-align:left;"><code>String</code>的构造函数</td></tr> <tr><td style="text-align:left;"><code>Number</code></td> <td style="text-align:left;"><code>Number</code>的构造函数</td></tr> <tr><td style="text-align:left;"><code>Date</code></td> <td style="text-align:left;"><code>Date</code>的构造函数</td></tr> <tr><td style="text-align:left;"><code>RegExp</code></td> <td style="text-align:left;"><code>RegExp</code>的构造函数</td></tr> <tr><td style="text-align:left;"><code>Symbol</code></td> <td style="text-align:left;"><code>Symbol</code>的伪构造函数</td></tr> <tr><td style="text-align:left;"><code>Error</code></td> <td style="text-align:left;"><code>Error</code>的构造函数</td></tr> <tr><td style="text-align:left;"><code>EvalError</code></td> <td style="text-align:left;"><code>EvalError</code>的构造函数</td></tr> <tr><td style="text-align:left;"><code>RangeError</code></td> <td style="text-align:left;"><code>RangeError</code>的构造函数</td></tr> <tr><td style="text-align:left;"><code>ReferenceError</code></td> <td style="text-align:left;"><code>ReferenceError</code>的构造函数</td></tr> <tr><td style="text-align:left;"><code>SyntaxError</code></td> <td style="text-align:left;"><code>SyntaxError</code>的构造函数</td></tr> <tr><td style="text-align:left;"><code>TypeError</code></td> <td style="text-align:left;"><code>TypeError</code>的构造函数</td></tr> <tr><td style="text-align:left;"><code>URIError</code></td> <td style="text-align:left;"><code>URIError</code>的构造函数</td></tr></tbody></table></li></ol> <ol start="4"><li><p><strong>window 对象</strong></p> <p>虽然 ECMA-262 没有规定直接访问<code>Global</code>对象的方式，但浏览器将<code>window</code>对象实现为<code>Global</code>对象的代理。因此，所有全局作用域中声明的变量和函数都变成了<code>window</code>的属性。来看下面的例子：</p> <div class="language- extra-class"><pre class="language-text"><code>var color = &quot;red&quot;;

function sayColor() {
  console.log(window.color);
}

window.sayColor(); // &quot;red&quot;
</code></pre></div><p>这里定义了一个名为<code>color</code>的全局变量和一个名为<code>sayColor()</code>的全局函数。在<code>sayColor()</code>内部，通过<code>window.color</code>访问了<code>color</code>变量，说明全局变量变成了<code>window</code>的属性。接着，又通过<code>window</code>对象直接调用了<code>window.sayColor()</code>函数，从而输出字符串。</p> <blockquote><p><strong>注意</strong> <code>window</code>对象在 JavaScript 中远不止实现了<code>ECMAScript</code>的<code>Global</code>对象那么简单。关于<code>window</code>对象的更多介绍，请参考第 12 章。</p></blockquote> <p>另一种获取<code>Global</code>对象的方式是使用如下的代码：</p> <div class="language- extra-class"><pre class="language-text"><code>let global = function() {
  return this;
}();
</code></pre></div><p>这段代码创建一个立即调用的函数表达式，返回了<code>this</code>的值。如前所述，当一个函数在没有明确（通过成为某个对象的方法，或者通过<code>call()</code>/<code>apply()</code>）指定<code>this</code>值的情况下执行时，<code>this</code>值等于<code>Global</code>对象。因此，调用一个简单返回<code>this</code>的函数是在任何执行上下文中获取<code>Global</code>对象的通用方式。</p></li></ol> <h3 id="_5-4-2-math"><a href="#_5-4-2-math" class="header-anchor">#</a> 5.4.2 　<code>Math</code></h3> <p>ECMAScript 提供了<code>Math</code>对象作为保存数学公式、信息和计算的地方。<code>Math</code>对象提供了一些辅助计算的属性和方法。</p> <blockquote><p><strong>注意</strong> <code>Math</code>对象上提供的计算要比直接在 JavaScript 实现的快得多，因为<code>Math</code>对象上的计算使用了 JavaScript 引擎中更高效的实现和处理器指令。但使用<code>Math</code>计算的问题是精度会因浏览器、操作系统、指令集和硬件而异。</p></blockquote> <ol><li><p><strong>Math 对象属性</strong></p> <p><code>Math</code>对象有一些属性，主要用于保存数学中的一些特殊值。下表列出了这些属性。</p> <table><thead><tr><th style="text-align:left;">属性</th> <th style="text-align:left;">说明</th></tr></thead> <tbody><tr><td style="text-align:left;"><code>Math.E</code></td> <td style="text-align:left;">自然对数的基数 e 的值</td></tr> <tr><td style="text-align:left;"><code>Math.LN10</code></td> <td style="text-align:left;">10 为底的自然对数</td></tr> <tr><td style="text-align:left;"><code>Math.LN2</code></td> <td style="text-align:left;">2 为底的自然对数</td></tr> <tr><td style="text-align:left;"><code>Math.LOG2E</code></td> <td style="text-align:left;">以 2 为底 e 的对数</td></tr> <tr><td style="text-align:left;"><code>Math.LOG10E</code></td> <td style="text-align:left;">以 10 为底 e 的对数</td></tr> <tr><td style="text-align:left;"><code>Math.PI</code></td> <td style="text-align:left;">π 的值</td></tr> <tr><td style="text-align:left;"><code>Math.SQRT1_2</code></td> <td style="text-align:left;">1/2 的平方根</td></tr> <tr><td style="text-align:left;"><code>Math.SQRT2</code></td> <td style="text-align:left;">2 的平方根</td></tr></tbody></table> <p>这些值的含义和用法超出了本书的范畴，但都是 ECMAScript 规范定义的，并可以在你需要时使用。</p></li></ol> <ol start="2"><li><p><strong>min()和 max()方法</strong></p> <p><code>Math</code>对象也提供了很多辅助执行简单或复杂数学计算的方法。</p> <p><code>min()</code>和<code>max()</code>方法用于确定一组数值中的最小值和最大值。这两个方法都接收任意多个参数，如下面的例子所示：</p> <div class="language- extra-class"><pre class="language-text"><code>let max = Math.max(3, 54, 32, 16);
console.log(max);  // 54

let min = Math.min(3, 54, 32, 16);
console.log(min);  // 3
</code></pre></div><p>在 3、54、32 和 16 中，<code>Math.max()</code>返回 54，<code>Math.min()</code>返回 3。使用这两个方法可以避免使用额外的循环和<code>if</code>语句来确定一组数值的最大最小值。</p> <p>要知道数组中的最大值和最小值，可以像下面这样使用扩展操作符：</p> <div class="language- extra-class"><pre class="language-text"><code>let values = [1, 2, 3, 4, 5, 6, 7, 8];
let max = Math.max(...values);
</code></pre></div></li></ol> <ol start="3"><li><p><strong>舍入方法</strong></p> <p>接下来是用于把小数值舍入为整数的 4 个方法：<code>Math.ceil()</code>、<code>Math.floor()</code>、<code>Math.round()</code>和<code>Math.fround()</code>。这几个方法处理舍入的方式如下所述。</p> <ul><li><code>Math.ceil()</code>方法始终向上舍入为最接近的整数。</li> <li><code>Math.floor()</code>方法始终向下舍入为最接近的整数。</li> <li><code>Math.round()</code>方法执行四舍五入。</li> <li><code>Math.fround()</code>方法返回数值最接近的单精度（32 位）浮点值表示。</li></ul> <p>以下示例展示了这些方法的用法：</p> <div class="language- extra-class"><pre class="language-text"><code>console.log(Math.ceil(25.9));   // 26
console.log(Math.ceil(25.5));   // 26
console.log(Math.ceil(25.1));   // 26

console.log(Math.round(25.9));  // 26
console.log(Math.round(25.5));  // 26
console.log(Math.round(25.1));  // 25

console.log(Math.fround(0.4));  // 0.4000000059604645
console.log(Math.fround(0.5));  // 0.5
console.log(Math.fround(25.9)); // 25.899999618530273

console.log(Math.floor(25.9));  // 25
console.log(Math.floor(25.5));  // 25
console.log(Math.floor(25.1));  // 25
</code></pre></div><p>对于 25 和 26（不包含）之间的所有值，<code>Math.ceil()</code>都会返回 26，因为它始终向上舍入。<code>Math.round()</code>只在数值大于等于<code>25.5</code>时返回 26，否则返回 25。最后，<code>Math.floor()</code>对所有 25 和 26（不包含）之间的值都返回 25。</p></li></ol> <ol start="4"><li><p><strong>random()方法</strong></p> <p><code>Math.random()</code>方法返回一个 0~1 范围内的随机数，其中包含 0 但不包含 1。对于希望显示随机名言或随机新闻的网页，这个方法是非常方便的。可以基于如下公式使用<code>Math.random()</code>从一组整数中随机选择一个数：</p> <div class="language- extra-class"><pre class="language-text"><code>number = Math.floor(Math.random() * total_number_of_choices + first_possible_value)
</code></pre></div><p>这里使用了<code>Math.floor()</code>方法，因为<code>Math.random()</code>始终返回小数，即便乘以一个数再加上一个数也是小数。因此，如果想从 1~10 范围内随机选择一个数，代码就是这样的：</p> <div class="language- extra-class"><pre class="language-text"><code>let num = Math.floor(Math.random() * 10 + 1);
</code></pre></div><p>这样就有 10 个可能的值（1~10），其中最小的值是 1。如果想选择一个 2~10 范围内的值，则代码就要写成这样：</p> <div class="language- extra-class"><pre class="language-text"><code>let num = Math.floor(Math.random() * 9 + 2);
</code></pre></div><p>2~10 只有 9 个数，所以可选总数（<code>total_number_of_choices</code>）是 9，而最小可能的值（<code>first_possible_value</code>）是 2。很多时候，通过函数来算出可选总数和最小可能的值可能更方便，比如：</p> <div class="language- extra-class"><pre class="language-text"><code>function selectFrom(lowerValue, upperValue) {
  let choices = upperValue - lowerValue + 1;
  return Math.floor(Math.random() * choices + lowerValue);
}

let num = selectFrom(2,10);
console.log(num);  // 2~10范围内的值，其中包含2和10
</code></pre></div><p>这里的函数<code>selectFrom()</code>接收两个参数：应该返回的最小值和最大值。通过将这两个值相减再加<code>1</code>得到可选总数，然后再套用上面的公式。于是，调用<code>selectFrom(2,10)</code>就可以从 2~10（包含）范围内选择一个值了。使用这个函数，从一个数组中随机选择一个元素就很容易，比如：</p> <div class="language- extra-class"><pre class="language-text"><code>let colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;yellow&quot;, &quot;black&quot;, &quot;purple&quot;, &quot;brown&quot;];
let color = colors[selectFrom(0, colors.length-1)];
</code></pre></div><p>在这个例子中，传给<code>selecFrom()</code>的第二个参数是数组长度减 1，即数组最大的索引值。</p> <blockquote><p><strong>注意</strong> <code>Math.random()</code>方法在这里出于演示目的是没有问题的。如果是为了加密而需要生成随机数（传给生成器的输入需要较高的不确定性），那么建议使用<code>window.crypto.getRandomValues()</code>。</p></blockquote></li></ol> <ol start="5"><li><p><strong>其他方法</strong></p> <p><code>Math</code>对象还有很多涉及各种简单或高阶数运算的方法。讨论每种方法的具体细节或者它们的适用场景超出了本书的范畴。不过，下表还是总结了<code>Math</code>对象的其他方法。</p> <table><thead><tr><th style="text-align:left;">方法</th> <th style="text-align:left;">说明</th></tr></thead> <tbody><tr><td style="text-align:left;"><code>Math.abs(*x*)</code></td> <td style="text-align:left;">返回<code>*x*</code>的绝对值</td></tr> <tr><td style="text-align:left;"><code>Math.e*x*p(*x*)</code></td> <td style="text-align:left;">返回<code>Math.E</code>的<code>*x*</code>次幂</td></tr> <tr><td style="text-align:left;"><code>Math.e*x*pm1(*x*)</code></td> <td style="text-align:left;">等于<code>Math.e*x*p(*x*) - 1</code></td></tr> <tr><td style="text-align:left;"><code>Math.log(*x*)</code></td> <td style="text-align:left;">返回<code>*x*</code>的自然对数</td></tr> <tr><td style="text-align:left;"><code>Math.log1p(*x*)</code></td> <td style="text-align:left;">等于<code>1 + Math.log(*x*)</code></td></tr> <tr><td style="text-align:left;"><code>Math.pow(*x*, *power*)</code></td> <td style="text-align:left;">返回<code>*x*</code>的<code>*power*</code>次幂</td></tr> <tr><td style="text-align:left;"><code>Math.pow(*...nums*)</code></td> <td style="text-align:left;">返回<code>*nums*</code>中每个数平方和的平方根</td></tr> <tr><td style="text-align:left;"><code>Math.clz32(*x*)</code></td> <td style="text-align:left;">返回 32 位整数<code>*x*</code>的前置零的数量</td></tr> <tr><td style="text-align:left;"><code>Math.sign(*x*)</code></td> <td style="text-align:left;">返回表示<code>*x*</code>符号的<code>1</code>、<code>0</code>、<code>-0</code>或<code>-1</code></td></tr> <tr><td style="text-align:left;"><code>Math.trunc(*x*)</code></td> <td style="text-align:left;">返回<code>*x*</code>的整数部分，删除所有小数</td></tr> <tr><td style="text-align:left;"><code>Math.sqrt(*x*)</code></td> <td style="text-align:left;">返回<code>*x*</code>的平方根</td></tr> <tr><td style="text-align:left;"><code>Math.cbrt(*x*)</code></td> <td style="text-align:left;">返回<code>*x*</code>的立方根</td></tr> <tr><td style="text-align:left;"><code>Math.acos(*x*)</code></td> <td style="text-align:left;">返回<code>*x*</code>的反余弦</td></tr> <tr><td style="text-align:left;"><code>Math.acosh(*x*)</code></td> <td style="text-align:left;">返回<code>*x*</code>的反双曲余弦</td></tr> <tr><td style="text-align:left;"><code>Math.asin(*x*)</code></td> <td style="text-align:left;">返回<code>*x*</code>的反正弦</td></tr> <tr><td style="text-align:left;"><code>Math.asinh(*x*)</code></td> <td style="text-align:left;">返回<code>*x*</code>的反双曲正弦</td></tr> <tr><td style="text-align:left;"><code>Math.atan(*x*)</code></td> <td style="text-align:left;">返回<code>*x*</code>的反正切</td></tr> <tr><td style="text-align:left;"><code>Math.atanh(*x*)</code></td> <td style="text-align:left;">返回<code>*x*</code>的反双曲正切</td></tr> <tr><td style="text-align:left;"><code>Math.atan2(*y*, *x*)</code></td> <td style="text-align:left;">返回<code>*y*/*x*</code>的反正切</td></tr> <tr><td style="text-align:left;"><code>Math.cos(*x*)</code></td> <td style="text-align:left;">返回<code>*x*</code>的余弦</td></tr> <tr><td style="text-align:left;"><code>Math.sin(*x*)</code></td> <td style="text-align:left;">返回<code>*x*</code>的正弦</td></tr> <tr><td style="text-align:left;"><code>Math.tan(*x*)</code></td> <td style="text-align:left;">返回<code>*x*</code>的正切</td></tr></tbody></table> <p>即便这些方法都是由 ECMA-262 定义的，对正弦、余弦、正切等计算的实现仍然取决于浏览器，因为计算这些值的方式有很多种。结果，这些方法的精度可能因实现而异。</p></li></ol> <h2 id="_5-5-小结"><a href="#_5-5-小结" class="header-anchor">#</a> 5.5 　小结</h2> <p>JavaScript 中的对象称为引用值，几种内置的引用类型可用于创建特定类型的对象。</p> <ul><li>引用值与传统面向对象编程语言中的类相似，但实现不同。</li> <li><code>Date</code>类型提供关于日期和时间的信息，包括当前日期、时间及相关计算。</li> <li><code>RegExp</code>类型是 ECMAScript 支持正则表达式的接口，提供了大多数基础的和部分高级的正则表达式功能。</li></ul> <p>JavaScript 比较独特的一点是，函数实际上是<code>Function</code>类型的实例，也就是说函数也是对象。因为函数也是对象，所以函数也有方法，可以用于增强其能力。</p> <p>由于原始值包装类型的存在，JavaScript 中的原始值可以被当成对象来使用。有 3 种原始值包装类型：<code>Boolean</code>、<code>Number</code>和<code>String</code>。它们都具备如下特点。</p> <ul><li>每种包装类型都映射到同名的原始类型。</li> <li>以读模式访问原始值时，后台会实例化一个原始值包装类型的对象，借助这个对象可以操作相应的数据。</li> <li>涉及原始值的语句执行完毕后，包装对象就会被销毁。</li></ul> <p>当代码开始执行时，全局上下文中会存在两个内置对象：<code>Global</code>和<code>Math</code>。其中，<code>Global</code>对象在大多数 ECMAScript 实现中无法直接访问。不过，浏览器将其实现为<code>window</code>对象。所有全局变量和函数都是<code>Global</code>对象的属性。<code>Math</code>对象包含辅助完成复杂计算的属性和方法。</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">11/16/2020, 3:12:43 AM</span></div></footer> <!----> </main></div><div class="global-ui"><!----><!----></div></div>
    <script src="/VuePressBlogHtml/assets/js/app.a22e24ce.js" defer></script><script src="/VuePressBlogHtml/assets/js/2.273354d5.js" defer></script><script src="/VuePressBlogHtml/assets/js/54.d2f28937.js" defer></script><script src="/VuePressBlogHtml/assets/js/17.398b5375.js" defer></script>
  </body>
</html>
