(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{427:function(e,n,a){e.exports=a.p+"assets/img/2.24754740.png"},428:function(e,n,a){e.exports=a.p+"assets/img/1.5990c1df.png"},521:function(e,n,a){"use strict";a.r(n);var t=a(27),s=Object(t.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"vue语法糖-以伪代码为例"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue语法糖-以伪代码为例"}},[e._v("#")]),e._v(" Vue语法糖(以伪代码为例)")]),e._v(" "),t("p",[e._v("Vue是一套用于构建用户界面的渐进式框架，只关注视图层MVVM(MVC).")]),e._v(" "),t("p",[e._v("1.文本插值")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("    <div id='app'>\n        {{ message }}\n    </div>\n    var app = new Vue({\n        el: '#app',\n        data: {\n            message: 'Hello Vue!'\n        }\n    })\n")])])]),t("p",[e._v("2.使用指令v-bind(:)绑定元素")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("    <div id='app'>\n         <span v-bind:title=\"message\">aa</span>\n    </div>\n    var app = new Vue({\n        el: '#app',\n        data: {\n            message: 'Hello Vue!'\n        }\n    })\n")])])]),t("p",[e._v("3.条件(v-if,v-else)与循环(v-for)")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("    <div id='app'>\n        <p v-if='seen'>现在你看到我了</p>\n    </div>\n    var app = new Vue({\n        el: '#app',\n        data: {\n            seen: true\n        }\n    })\n    \n    <div id=\"app\">\n        <ol>\n            <li v-for=\"(todo,index) in todos\">{{ todo.text }}</li>\n        </ol>\n    </div>\n    var app = new Vue({\n        el: '#app',\n        data: {\n            todos: [\n                {text: 'JavaScript'},\n                {text: 'Vue'}\n            ]\n        }\n    })\n")])])]),t("p",[e._v("4.事件监听v-on(@)")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("    <button v-on:click='sendMessage'>aa</button>\n    var app = new Vue({\n        el: '#app',\n        data: {\n            message: 'Hello Vue'\n        },\n        methods: {\n            sendMessage: function() {\n                this.message = 'aaaaa'\n            }\n        }\n    })\n")])])]),t("p",[e._v("5.表单输入与数据的双向绑定v-model")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("    <input v-model='message'>\n    var app = new Vue({\n        el: '#app'\n        data: {\n            message: 'Hello Vue'\n        }\n    })\n")])])]),t("p",[e._v("修饰符:")]),e._v(" "),t("ul",[t("li",[e._v(".lazy  在“change”时而非“input”时更新")]),e._v(" "),t("li",[e._v(".number  自动将用户的输入值转为数值类型")]),e._v(" "),t("li",[e._v(".trim  自动过滤用户输入的首尾空白字符")])]),e._v(" "),t("p",[e._v("6.组件化component,data必须是函数")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("    <div id=\"app\">\n        <ol>\n        \x3c!--现在我们为每个 todo-item 提供 todo 对象,todo 对象是变量，即其内容可以是动态的。\n        我们也需要为每个组件提供一个“key”--\x3e\n            <todo-item\n            v-for=\"item in groceryList\"\n            v-bind:todo=\"item\"\n            v-bind:key=\"item.id\">\n        </todo-item>\n        </ol>\n    </div>\n    Vue.component('todo-item', {\n        props: ['todo'],\n        template: '<li>{{ todo.text }}</li>',\n        data: function () {\n            return { message: 'hello' }\n        }\n    })\n    var app7 = new Vue({\n        el: '#app',\n        data: {\n            groceryList: [\n                { id: 0, text: '蔬菜' },\n                { id: 1, text: '奶酪' },\n                { id: 2, text: '随便其它什么人吃的东西' }\n            ]\n        }\n    })\n")])])]),t("p",[e._v("prop验证：为组件的 prop 指定验证规则。如果传入的数据不符合要求，Vue 会发出警告")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("    props: {\n        // 基础类型检测 (`null` 指允许任何类型)\n        propA: Number,\n        // 可能是多种类型\n        propB: [String, Number],\n        // 必传且是字符串\n        propC: {\n            type: String,\n            required: true\n        },\n        // 数值且有默认值\n        propD: {\n            type: Number,\n            default: 100\n        },\n        // 数组/对象的默认值应当由一个工厂函数返回\n        propE: {\n            type: Object,\n            default: function () {\n                return { message: 'hello' }\n            }\n        },\n        // 自定义验证函数\n        propF: {\n            validator: function (value) {\n            return value > 10\n            }\n        }\n    }\n")])])]),t("p",[e._v("7.Vue实例的生命周期")]),e._v(" "),t("p",[t("img",{attrs:{src:a(427),alt:"Vue生命周期"}})]),e._v(" "),t("p",[e._v("8.插入原始Html(v-html)")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('    var rawHtml = \'<span style="color: red">This should be red.</span>\'\n    <p>Using v-html directive: <span v-html="rawHtml"></span></p>\n')])])]),t("p",[e._v("9.指令后接收参数或修饰符(以半角句号.指明的特殊后缀)")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('    <a v-bind:href="url">...</a>\n    <a v-on:click="doSomething">...</a>\n    <form v-on:submit.prevent="onSubmit">...</form>\n')])])]),t("ul",[t("li",[e._v(".prevent 修饰符告诉 v-on 指令对于触发的事件调用 event.preventDefault()")]),e._v(" "),t("li",[e._v(".stop  阻止单击事件继续传播")]),e._v(" "),t("li",[e._v(".capture 添加事件监听器时使用事件捕获模式,即元素自身触发的事件先在此处处理，然后才交由内部元素进行处理")]),e._v(" "),t("li",[e._v(".self 只当在 event.target 是当前元素自身时触发处理函数,即事件不是从内部元素触发的")]),e._v(" "),t("li",[e._v(".once 事件将只会触发一次")])]),e._v(" "),t("p",[e._v("10.计算属性computed VS 方法methods VS 侦听属性watch")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("    var vm = new Vue({\n        el: '#example',\n        data: {\n            message: 'Hello'\n        },\n        computed: {\n            // 计算属性的 getter\n            reversedMessage: function () {\n                // `this` 指向 vm 实例\n                return this.message.split('').reverse().join('')\n            }\n        },\n        methods: {\n            reversedMessage: function () {\n                return this.message.split('').reverse().join('')\n            }\n        },\n         watch: {\n            message: function (val) {\n                this.message = val.split('').reverse().join('')\n            }\n        }\n    })\n")])])]),t("ul",[t("li",[e._v("计算属性：基于依赖进行缓存，只在相关依赖改变时才会重新求值")]),e._v(" "),t("li",[e._v("方法： 总是会重新执行函数")]),e._v(" "),t("li",[e._v("侦听属性：当一些数据需要随着其他数据改变而改变时使用")])]),e._v(" "),t("p",[e._v("11.将v-bind用于class和style时,表达式除字符串外，还可以是对象或数组")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("    <div class=\"static\"\n        v-bind:class=\"{ active: isActive, 'text-danger': hasError }\">\n    </div>\n    data: {isActive: true, hasError: false}\n    \n    <div v-bind:class=\"[activeClass, errorClass]\"></div>\n    data: {activeClass: 'active', errorClass: 'text-danger'}\n    \n    <div v-bind:style=\"styleObject\"></div>\n    data: {\n        styleObject: {color: 'red',fontSize: '13px'}\n    }\n")])])]),t("p",[e._v("12.v-show VS v-if")]),e._v(" "),t("p",[e._v("v-show 的元素始终会被渲染并保留在 DOM 中,v-show 只是简单地切换元素的 CSS 属性 display")]),e._v(" "),t("p",[e._v("13.按键修饰符")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('    <input v-on:keyup.enter="submit">\n.enter </br>\n.tab </br>\n.delete (捕获“删除”和“退格”键) </br>\n.esc </br>\n.space </br>\n.up </br>\n.down </br>\n.left </br>\n.right </br>\n')])])]),t("p",[e._v("14.简单的非父子组件通信")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("    var bus = new Vue()\n    // 触发组件 A 中的事件\n    bus.$emit('id-selected', 1)\n    // 在组件 B 创建的钩子中监听事件\n    bus.$on('id-selected', function (id) {\n        // ...\n    })\n")])])]),t("p",[e._v("15.插槽( slot )\n单个插槽：当子组件模板只有一个没有属性的插槽时，父组件传入的整个内容片段将插入到插槽所在的 DOM 位置，并替换掉插槽标签本身，最初在slot标签中的任何内容都被视为备用内容。")]),e._v(" "),t("p",[e._v("具名插槽：slot元素可以用一个特殊的特性 name 来进一步配置如何分发内容")]),e._v(" "),t("p",[e._v("16.动态组件")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("    var vm = new Vue({\n        el: '#example',\n        data: {\n            currentView: 'home'\n        },\n        components: {\n            home: { /* ... */ },\n            posts: { /* ... */ },\n            archive: { /* ... */ }\n        }\n    })\n    <component v-bind:is=\"currentView\">\n        \x3c!-- 组件在 vm.currentview 变化时改变！ --\x3e\n    </component>\n")])])]),t("p",[e._v("keep-alive：如果把切换出去的组件保留在内存中，可以保留它的状态或避免重新渲染")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('    <keep-alive>\n        <component :is="currentView">\n        \x3c!-- 非活动组件将被缓存！ --\x3e\n        </component>\n    </keep-alive>\n')])])]),t("p",[e._v("17.过渡动画(css动画/js动画)")]),e._v(" "),t("p",[e._v("单元素/组件过渡(transition)")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('    <transition name="fade">\n        <p v-if="show">hello</p>\n    </transition>\n    .fade-enter-active, .fade-leave-active {\n        transition: opacity .5s;\n    }\n    .fade-enter, .fade-leave-to {\n        opacity: 0;\n    }\n')])])]),t("p",[e._v("过渡过程中的类名(6个)")]),e._v(" "),t("ol",[t("li",[e._v("v-enter : 定义进入过渡的开始状态")]),e._v(" "),t("li",[e._v("v-enter-active : 定义过渡的状态，可以用来定义过渡过程时间，延迟和曲线函数")]),e._v(" "),t("li",[e._v("v-enter-to : 定义进入过渡的结束状态")]),e._v(" "),t("li",[e._v("v-leave ：定义离开过渡的开始状态")]),e._v(" "),t("li",[e._v("v-leave-active ：定义离开过渡的状态")]),e._v(" "),t("li",[e._v("v-leave-to ：定义离开过渡的结束状态")])]),e._v(" "),t("p",[e._v("对于这些在 enter/leave 过渡中切换的类名，v- 是这些类名的前缀。\n使用"),t("code",[e._v('<transition name="my-transition">')]),e._v("可以重置前缀，比如 v-enter 替换为 my-transition-enter")]),e._v(" "),t("p",[t("img",{attrs:{src:a(428),alt:"Vue过渡类名示意"}})]),e._v(" "),t("p",[e._v("自定义过渡类名：enter-class , enter-active-class , enter-to-class ,\nleave-class , leave-active-class , leave-to-class")]),e._v(" "),t("p",[e._v("js钩子：before-enter,enter,after-enter,enter-cancelled,\nbefore-leave,leave,after-leave,leave-cancelled")]),e._v(" "),t("p",[e._v("! 当只用 JavaScript 过渡的时候,在 enter 和 leave 中,回调函数 done 是必须的")]),e._v(" "),t("p",[e._v("过渡模式(mode)：")]),e._v(" "),t("ul",[t("li",[e._v("in-out : 新元素先进行过渡，完成之后当前元素过渡离开")]),e._v(" "),t("li",[e._v("out-in : 当前元素先进行过渡，完成之后新元素过渡进入")])]),e._v(" "),t("p",[e._v("列表过渡(transition-group):")]),e._v(" "),t("ul",[t("li",[e._v("不同于 "),t("code",[e._v("<transition>")]),e._v("，它会以一个真实元素呈现：默认为一个 "),t("code",[e._v("<span>")]),e._v("。你也可以通过 tag 特性更换为其他元素。")]),e._v(" "),t("li",[e._v("内部元素 总是需要 提供唯一的 key 属性值")])]),e._v(" "),t("p",[e._v("18.混入(mixins)")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("var Component = Vue.extend({mixins: [myMixin]})\nvar vm = new Vue({mixins: [mixin]})`\n")])])]),t("p",[e._v("选项合并原则：")]),e._v(" "),t("ul",[t("li",[e._v("数据对象在内部会进行浅合并(一层属性深度),在和组件的数据发生冲突时以组件数据优先")]),e._v(" "),t("li",[e._v("同名钩子函数将混合为一个数组，因此都将被调用。另外，混入对象的钩子将在组件自身钩子之前调用")]),e._v(" "),t("li",[e._v("值为对象的选项，例如 methods, components 和 directives，将被混合为同一个对象。两个对象键名冲突时，取组件对象的键值对")])]),e._v(" "),t("p",[e._v("19.自定义指令")]),e._v(" "),t("p",[e._v("注册全局指令：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("    Vue.directive('focus', {\n        // 当被绑定的元素插入到 DOM 中时……\n        inserted: function (el) {\n            // 聚焦元素\n            el.focus()\n        }\n    })\n")])])]),t("p",[e._v("注册局部指令,组件可接收directives选项：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("    directives: {\n        focus: {\n            // 指令的定义\n            inserted: function (el) {\n                el.focus()\n            }\n        }\n    }\n")])])]),t("p",[e._v("使用：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("    <input v-focus>\n")])])]),t("p",[e._v("钩子函数：")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。")])]),e._v(" "),t("li",[t("p",[e._v("inserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。")])]),e._v(" "),t("li",[t("p",[e._v("update：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。")])]),e._v(" "),t("li",[t("p",[e._v("componentUpdated：指令所在组件的 VNode 及其子 VNode 全部更新后调用。")])]),e._v(" "),t("li",[t("p",[e._v("unbind：只调用一次，指令与元素解绑时调用。")])])]),e._v(" "),t("p",[e._v("钩子函数参数：")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("el ： 指令所绑定的元素，可以用来直接操作DOM")])]),e._v(" "),t("li",[t("p",[e._v("binding : 一个对象，包含以下属性：")]),e._v(" "),t("ul",[t("li",[e._v("name : 指令名称，不包括v-前缀")]),e._v(" "),t("li",[e._v("value : 指令绑定值")]),e._v(" "),t("li",[e._v("oldValue ：指令绑定的前一个值")]),e._v(" "),t("li",[e._v("expression : 字符串形式的指令表达式")]),e._v(" "),t("li",[e._v("arg ：传给指令的参数")]),e._v(" "),t("li",[e._v("modifiers : 一个包含修饰符的对象")])])]),e._v(" "),t("li",[t("p",[e._v("vnode ： Vue编译生成的虚拟节点")])]),e._v(" "),t("li",[t("p",[e._v("oldVnode ：上一个虚拟节点")])])])])}),[],!1,null,null,null);n.default=s.exports}}]);