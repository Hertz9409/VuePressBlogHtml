(window.webpackJsonp=window.webpackJsonp||[]).push([[51],{511:function(t,a,e){"use strict";e.r(a);var v=e(27),c=Object(v.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"第-2-章-html-中的-javascript"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第-2-章-html-中的-javascript"}},[t._v("#")]),t._v(" 第 2 章　 HTML 中的 JavaScript")]),t._v(" "),e("blockquote",[e("p",[e("strong",[t._v("本章内容")])]),t._v(" "),e("ul",[e("li",[t._v("使用"),e("code",[t._v("<script>")]),t._v("元素")]),t._v(" "),e("li",[t._v("行内脚本与外部脚本的比较")]),t._v(" "),e("li",[t._v("文档模式对 JavaScript 有什么影响")]),t._v(" "),e("li",[t._v("确保 JavaScript 不可用时的用户体验")])])]),t._v(" "),e("p",[t._v("将 JavaScript 引入网页，首先要解决它与网页的主导语言 HTML 的关系问题。在 JavaScript 早期，网景公司的工作人员希望在将 JavaScript 引入 HTML 页面的同时，不会导致页面在其他浏览器中渲染出问题。通过反复试错和讨论，他们最终做出了一些决定，并达成了向网页中引入通用脚本能力的共识。当初他们的很多工作得到了保留，并且最终形成了 HTML 规范。")]),t._v(" "),e("h2",{attrs:{id:"_2-1-script-元素"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-script-元素"}},[t._v("#")]),t._v(" 2.1 　"),e("code",[t._v("<script>")]),t._v("元素")]),t._v(" "),e("p",[t._v("将 JavaScript 插入 HTML 的主要方法是使用"),e("code",[t._v("<script>")]),t._v("元素。这个元素是由网景公司创造出来，并最早在 Netscape Navigator 2 中实现的。后来，这个元素被正式加入到 HTML 规范。"),e("code",[t._v("<script>")]),t._v("元素有下列 8 个属性。")]),t._v(" "),e("ul",[e("li",[e("code",[t._v("async")]),t._v("：可选。表示应该立即开始下载脚本，但不能阻止其他页面动作，比如下载资源或等待其他脚本加载。只对外部脚本文件有效。")]),t._v(" "),e("li",[e("code",[t._v("charset")]),t._v("：可选。使用"),e("code",[t._v("src")]),t._v("属性指定的代码字符集。这个属性很少使用，因为大多数浏览器不在乎它的值。")]),t._v(" "),e("li",[e("code",[t._v("crossorigin")]),t._v("：可选。配置相关请求的 CORS（跨源资源共享）设置。默认不使用 CORS。"),e("code",[t._v('crossorigin="anonymous"')]),t._v("配置文件请求不必设置凭据标志。"),e("code",[t._v('crossorigin="use-credentials"')]),t._v("设置凭据标志，意味着出站请求会包含凭据。")]),t._v(" "),e("li",[e("code",[t._v("defer")]),t._v("：可选。表示在文档解析和显示完成后再执行脚本是没有问题的。只对外部脚本文件有效。在 IE7 及更早的版本中，对行内脚本也可以指定这个属性。")]),t._v(" "),e("li",[e("code",[t._v("integrity")]),t._v("：可选。允许比对接收到的资源和指定的加密签名以验证子资源完整性（SRI，Subresource Intergrity）。如果接收到的资源的签名与这个属性指定的签名不匹配，则页面会报错，脚本不会执行。这个属性可以用于确保内容分发网络（CDN，Content Delivery Network）不会提供恶意内容。")]),t._v(" "),e("li",[e("code",[t._v("language")]),t._v("：废弃。最初用于表示代码块中的脚本语言（如"),e("code",[t._v('"JavaScript"')]),t._v("、"),e("code",[t._v('"JavaScript 1.2"')]),t._v("或"),e("code",[t._v('"VBScript"')]),t._v("）。大多数浏览器都会忽略这个属性，不应该再使用它。")]),t._v(" "),e("li",[e("code",[t._v("src")]),t._v("：可选。表示包含要执行的代码的外部文件。")]),t._v(" "),e("li",[e("code",[t._v("type")]),t._v("：可选。代替"),e("code",[t._v("language")]),t._v("，表示代码块中脚本语言的内容类型（也称 MIME 类型）。按照惯例，这个值始终都是"),e("code",[t._v('"text/javascript"')]),t._v("，尽管"),e("code",[t._v('"text/javascript"')]),t._v("和"),e("code",[t._v('"text/ecmascript"')]),t._v("都已经废弃了。JavaScript 文件的 MIME 类型通常是"),e("code",[t._v('"application/x-javascript"')]),t._v("，不过给 type 属性这个值有可能导致脚本被忽略。在非 IE 的浏览器中有效的其他值还有"),e("code",[t._v('"application/javascript"')]),t._v("和"),e("code",[t._v('"application/ecmascript"')]),t._v("。如果这个值是"),e("code",[t._v("module")]),t._v("，则代码会被当成 ES6 模块，而且只有这时候代码中才能出现"),e("code",[t._v("import")]),t._v("和"),e("code",[t._v("export")]),t._v("关键字。")])]),t._v(" "),e("p",[t._v("使用"),e("code",[t._v("<script>")]),t._v("的方式有两种：通过它直接在网页中嵌入 JavaScript 代码，以及通过它在网页中包含外部 JavaScript 文件。")]),t._v(" "),e("p",[t._v("要嵌入行内 JavaScript 代码，直接把代码放在"),e("code",[t._v("<script>")]),t._v("元素中就行：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('<script>\n  function sayHi() {\n    console.log("Hi!");\n  }\n<\/script>\n')])])]),e("p",[t._v("包含在"),e("code",[t._v("<script>")]),t._v("内的代码会被从上到下解释。在上面的例子中，被解释的是一个函数定义，并且该函数会被保存在解释器环境中。在"),e("code",[t._v("<script>")]),t._v("元素中的代码被计算完成之前，页面的其余内容不会被加载，也不会被显示。")]),t._v(" "),e("p",[t._v("在使用行内 JavaScript 代码时，要注意代码中不能出现字符串"),e("code",[t._v("<\/script>")]),t._v("。比如，下面的代码会导致浏览器报错：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('<script>\n  function sayScript() {\n    console.log("<\/script>");\n  }\n<\/script>\n')])])]),e("p",[t._v("浏览器解析行内脚本的方式决定了它在看到字符串"),e("code",[t._v("<\/script>")]),t._v("时，会将其当成结束的"),e("code",[t._v("<\/script>")]),t._v("标签。想避免这个问题，只需要转义字符“\\”"),e("strong",[t._v("1")]),t._v("即可：")]),t._v(" "),e("p",[e("strong",[t._v("1")]),t._v("此处的转义字符指在 JavaScript 中使用反斜杠“"),e("code",[t._v("\\")]),t._v("”来向文本字符串添加特殊字符。——编者注")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('<script>\n  function sayScript() {\n    console.log("<\\/script>");\n  }\n<\/script>\n')])])]),e("p",[t._v("这样修改之后，代码就可以被浏览器完全解释，不会导致任何错误。")]),t._v(" "),e("p",[t._v("要包含外部文件中的 JavaScript，就必须使用"),e("code",[t._v("src")]),t._v("属性。这个属性的值是一个 URL，指向包含 JavaScript 代码的文件，比如：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('<script src="example.js"><\/script>\n')])])]),e("p",[t._v("这个例子在页面中加载了一个名为 example.js 的外部文件。文件本身只需包含要放在"),e("code",[t._v("<script>")]),t._v("的起始及结束标签中间的 JavaScript 代码。与解释行内 JavaScript 一样，在解释外部 JavaScript 文件时，页面也会阻塞。（阻塞时间也包含下载文件的时间。）在 XHTML 文档中，可以忽略结束标签，比如：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('<script src="example.js"/>\n')])])]),e("p",[t._v("以上语法不能在 HTML 文件中使用，因为它是无效的 HTML，有些浏览器不能正常处理，比如 IE。")]),t._v(" "),e("blockquote",[e("p",[e("strong",[t._v("注意")]),t._v("　按照惯例，外部 JavaScript 文件的扩展名是.js。这不是必需的，因为浏览器不会检查所包含 JavaScript 文件的扩展名。这就为使用服务器端脚本语言动态生成 JavaScript 代码，或者在浏览器中将 JavaScript 扩展语言（如 TypeScript，或 React 的 JSX）转译为 JavaScript 提供了可能性。不过要注意，服务器经常会根据文件扩展来确定响应的正确 MIME 类型。如果不打算使用.js 扩展名，一定要确保服务器能返回正确的 MIME 类型。")])]),t._v(" "),e("p",[t._v("另外，使用了"),e("code",[t._v("src")]),t._v("属性的"),e("code",[t._v("<script>")]),t._v("元素不应该再在"),e("code",[t._v("<script>")]),t._v("和"),e("code",[t._v("<\/script>")]),t._v("标签中再包含其他 JavaScript 代码。如果两者都提供的话，则浏览器只会下载并执行脚本文件，从而忽略行内代码。")]),t._v(" "),e("p",[e("code",[t._v("<script>")]),t._v("元素的一个最为强大、同时也备受争议的特性是，它可以包含来自外部域的 JavaScript 文件。跟"),e("code",[t._v("<img>")]),t._v("元素很像，"),e("code",[t._v("<script>")]),t._v("元素的 src 属性可以是一个完整的 URL，而且这个 URL 指向的资源可以跟包含它的 HTML 页面不在同一个域中，比如这个例子：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('<script src="http://www.somewhere.com/afile.js"><\/script>\n')])])]),e("p",[t._v("浏览器在解析这个资源时，会向"),e("code",[t._v("src")]),t._v("属性指定的路径发送一个"),e("code",[t._v("GET")]),t._v("请求，以取得相应资源，假定是一个 JavaScript 文件。这个初始的请求不受浏览器同源策略限制，但返回并被执行的 JavaScript 则受限制。当然，这个请求仍然受父页面 HTTP/HTTPS 协议的限制。")]),t._v(" "),e("p",[t._v("来自外部域的代码会被当成加载它的页面的一部分来加载和解释。这个能力可以让我们通过不同的域分发 JavaScript。不过，引用了放在别人服务器上的 JavaScript 文件时要格外小心，因为恶意的程序员随时可能替换这个文件。在包含外部域的 JavaScript 文件时，要确保该域是自己所有的，或者该域是一个可信的来源。"),e("code",[t._v("<script>")]),t._v("标签的"),e("code",[t._v("integrity")]),t._v("属性是防范这种问题的一个武器，但这个属性也不是所有浏览器都支持。")]),t._v(" "),e("p",[t._v("不管包含的是什么代码，浏览器都会按照"),e("code",[t._v("<script>")]),t._v("在页面中出现的顺序依次解释它们，前提是它们没有使用"),e("code",[t._v("defer")]),t._v("和"),e("code",[t._v("async")]),t._v("属性。第二个"),e("code",[t._v("<script>")]),t._v("元素的代码必须在第一个"),e("code",[t._v("<script>")]),t._v("元素的代码解释完毕才能开始解释，第三个则必须等第二个解释完，以此类推。")]),t._v(" "),e("h3",{attrs:{id:"_2-1-1-标签占位符"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-1-标签占位符"}},[t._v("#")]),t._v(" 2.1.1 　标签占位符")]),t._v(" "),e("p",[t._v("过去，所有"),e("code",[t._v("<script>")]),t._v("元素都被放在页面的"),e("code",[t._v("<head>")]),t._v("标签内，如下面的例子所示：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('<!DOCTYPE html>\n<html>\n  <head>\n  <title>Example HTML Page</title>\n  <script src="example1.js"><\/script>\n  <script src="example2.js"><\/script>\n  </head>\n  <body>\n  \x3c!-- 这里是页面内容 --\x3e\n  </body>\n</html>\n')])])]),e("p",[t._v("这种做法的主要目的是把外部的 CSS 和 JavaScript 文件都集中放到一起。不过，把所有 JavaScript 文件都放在"),e("code",[t._v("<head>")]),t._v("里，也就意味着必须把所有 JavaScript 代码都下载、解析和解释完成后，才能开始渲染页面（页面在浏览器解析到"),e("code",[t._v("<body>")]),t._v("的起始标签时开始渲染）。对于需要很多 JavaScript 的页面，这会导致页面渲染的明显延迟，在此期间浏览器窗口完全空白。为解决这个问题，现代 Web 应用程序通常将所有 JavaScript 引用放在"),e("code",[t._v("<body>")]),t._v("元素中的页面内容后面，如下面的例子所示：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('<!DOCTYPE html>\n<html>\n  <head>\n  <title>Example HTML Page</title>\n  </head>\n  <body>\n  \x3c!-- 这里是页面内容 --\x3e\n  <script src="example1.js"><\/script>\n  <script src="example2.js"><\/script>\n  </body>\n</html>\n')])])]),e("p",[t._v("这样一来，页面会在处理 JavaScript 代码之前完全渲染页面。用户会感觉页面加载更快了，因为浏览器显示空白页面的时间短了。")]),t._v(" "),e("h3",{attrs:{id:"_2-1-2-推迟执行脚本"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-2-推迟执行脚本"}},[t._v("#")]),t._v(" 2.1.2 　推迟执行脚本")]),t._v(" "),e("p",[t._v("HTML 4.01 为"),e("code",[t._v("<script>")]),t._v("元素定义了一个叫"),e("code",[t._v("defer")]),t._v("的属性。这个属性表示脚本在执行的时候不会改变页面的结构。因此，这个脚本完全可以在整个页面解析完之后再运行。在"),e("code",[t._v("<script>")]),t._v("元素上设置"),e("code",[t._v("defer")]),t._v("属性，会告诉浏览器应该立即开始下载，但执行应该推迟：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('<!DOCTYPE html>\n<html>\n  <head>\n  <title>Example HTML Page</title>\n  <script defer src="example1.js"><\/script>\n  <script defer src="example2.js"><\/script>\n  </head>\n  <body>\n  \x3c!-- 这里是页面内容 --\x3e\n  </body>\n</html>\n')])])]),e("p",[t._v("虽然这个例子中的"),e("code",[t._v("<script>")]),t._v("元素包含在页面的"),e("code",[t._v("<head>")]),t._v("中，但它们会在浏览器解析到结束的"),e("code",[t._v("</html>")]),t._v("标签后才会执行。HTML5 规范要求脚本应该按照它们出现的顺序执行，因此第一个推迟的脚本会在第二个推迟的脚本之前执行，而且两者都会在"),e("code",[t._v("DOMContentLoaded")]),t._v("事件之前执行（关于事件，请参考第 17 章）。不过在实际当中，推迟执行的脚本不一定总会按顺序执行或者在"),e("code",[t._v("DOMContentLoaded")]),t._v("事件之前执行，因此最好只包含一个这样的脚本。")]),t._v(" "),e("p",[t._v("如前所述，"),e("code",[t._v("defer")]),t._v("属性只对外部脚本文件才有效。这是 HTML5 中明确规定的，因此支持 HTML5 的浏览器会忽略行内脚本的"),e("code",[t._v("defer")]),t._v("属性。IE4~7 展示出的都是旧的行为，IE8 及更高版本则支持 HTML5 定义的行为。")]),t._v(" "),e("p",[t._v("对"),e("code",[t._v("defer")]),t._v("属性的支持是从 IE4、Firefox 3.5、Safari 5 和 Chrome 7 开始的。其他所有浏览器则会忽略这个属性，按照通常的做法来处理脚本。考虑到这一点，还是把要推迟执行的脚本放在页面底部比较好。")]),t._v(" "),e("blockquote",[e("p",[e("strong",[t._v("注意")]),t._v("　对于 XHTML 文档，指定"),e("code",[t._v("defer")]),t._v("属性时应该写成"),e("code",[t._v('defer="defer"')]),t._v("。")])]),t._v(" "),e("h3",{attrs:{id:"_2-1-3-异步执行脚本"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-3-异步执行脚本"}},[t._v("#")]),t._v(" 2.1.3 　异步执行脚本")]),t._v(" "),e("p",[t._v("HTML5 为"),e("code",[t._v("<script>")]),t._v("元素定义了"),e("code",[t._v("async")]),t._v("属性。从改变脚本处理方式上看，"),e("code",[t._v("async")]),t._v("属性与"),e("code",[t._v("defer")]),t._v("类似。当然，它们两者也都只适用于外部脚本，都会告诉浏览器立即开始下载。不过，与"),e("code",[t._v("defer")]),t._v("不同的是，标记为"),e("code",[t._v("async")]),t._v("的脚本并不保证能按照它们出现的次序执行，比如：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('<!DOCTYPE html>\n<html>\n  <head>\n  <title>Example HTML Page</title>\n  <script async src="example1.js"><\/script>\n  <script async src="example2.js"><\/script>\n  </head>\n  <body>\n  \x3c!-- 这里是页面内容 --\x3e\n  </body>\n</html>\n')])])]),e("p",[t._v("在这个例子中，第二个脚本可能先于第一个脚本执行。因此，重点在于它们之间没有依赖关系。给脚本添加"),e("code",[t._v("async")]),t._v("属性的目的是告诉浏览器，不必等脚本下载和执行完后再加载页面，同样也不必等到该异步脚本下载和执行后再加载其他脚本。正因为如此，异步脚本不应该在加载期间修改 DOM。")]),t._v(" "),e("p",[t._v("异步脚本保证会在页面的"),e("code",[t._v("load")]),t._v("事件前执行，但可能会在"),e("code",[t._v("DOMContentLoaded")]),t._v("（参见第 17 章）之前或之后。Firefox 3.6、Safari 5 和 Chrome 7 支持异步脚本。使用"),e("code",[t._v("async")]),t._v("也会告诉页面你不会使用"),e("code",[t._v("document.write")]),t._v("，不过好的 Web 开发实践根本就不推荐使用这个方法。")]),t._v(" "),e("blockquote",[e("p",[e("strong",[t._v("注意")]),t._v("　对于 XHTML 文档，指定"),e("code",[t._v("async")]),t._v("属性时应该写成"),e("code",[t._v('async="async"')]),t._v("。")])]),t._v(" "),e("h3",{attrs:{id:"_2-1-4-动态加载脚本"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-4-动态加载脚本"}},[t._v("#")]),t._v(" 2.1.4 　动态加载脚本")]),t._v(" "),e("p",[t._v("除了"),e("code",[t._v("<script>")]),t._v("标签，还有其他方式可以加载脚本。因为 JavaScript 可以使用 DOM API，所以通过向 DOM 中动态添加"),e("code",[t._v("script")]),t._v("元素同样可以加载指定的脚本。只要创建一个"),e("code",[t._v("script")]),t._v("元素并将其添加到 DOM 即可。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("let script = document.createElement('script');\nscript.src = 'gibberish.js';\ndocument.head.appendChild(script);\n")])])]),e("p",[t._v("当然，在把"),e("code",[t._v("HTMLElement")]),t._v("元素添加到 DOM 且执行到这段代码之前不会发送请求。默认情况下，以这种方式创建的"),e("code",[t._v("<script>")]),t._v("元素是以异步方式加载的，相当于添加了"),e("code",[t._v("async")]),t._v("属性。不过这样做可能会有问题，因为所有浏览器都支持"),e("code",[t._v("createElement()")]),t._v("方法，但不是所有浏览器都支持"),e("code",[t._v("async")]),t._v("属性。因此，如果要统一动态脚本的加载行为，可以明确将其设置为同步加载：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("let script = document.createElement('script');\nscript.src = 'gibberish.js';\nscript.async = false;\ndocument.head.appendChild(script);\n")])])]),e("p",[t._v("以这种方式获取的资源对浏览器预加载器是不可见的。这会严重影响它们在资源获取队列中的优先级。根据应用程序的工作方式以及怎么使用，这种方式可能会严重影响性能。要想让预加载器知道这些动态请求文件的存在，可以在文档头部显式声明它们：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('<link rel="preload" href="gibberish.js">\n')])])]),e("h3",{attrs:{id:"_2-1-5-xhtml-中的变化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-5-xhtml-中的变化"}},[t._v("#")]),t._v(" 2.1.5 　 XHTML 中的变化")]),t._v(" "),e("p",[t._v("可扩展超文本标记语言（XHTML，Extensible HyperText Markup Language）是将 HTML 作为 XML 的应用重新包装的结果。与 HTML 不同，在 XHTML 中使用 JavaScript 必须指定"),e("code",[t._v("type")]),t._v("属性且值为"),e("code",[t._v("text/javascript")]),t._v("，HTML 中则可以没有这个属性。XHTML 虽然已经退出历史舞台，但实践中偶尔可能也会遇到遗留代码，为此本节稍作介绍。")]),t._v(" "),e("p",[t._v("在 XHTML 中编写代码的规则比 HTML 中严格，这会影响使用"),e("code",[t._v("<script>")]),t._v("元素嵌入 JavaScript 代码。下面的代码块虽然在 HTML 中有效，但在 XHML 中是无效的。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('<script type="text/javascript">\n  function compare(a, b) {\n    if (a < b) {\n      console.log("A is less than B");\n    } else if (a > b) {\n      console.log("A is greater than B");\n    } else {\n      console.log("A is equal to B");\n    }\n  }\n<\/script>\n')])])]),e("p",[t._v("在 HTML 中，解析"),e("code",[t._v("<script>")]),t._v("元素会应用特殊规则。XHTML 中则没有这些规则。这意味着"),e("code",[t._v("a < b")]),t._v("语句中的小于号（"),e("code",[t._v("<")]),t._v("）会被解释成一个标签的开始，并且由于作为标签开始的小于号后面不能有空格，这会导致语法错误。")]),t._v(" "),e("p",[t._v("避免 XHTML 中这种语法错误的方法有两种。第一种是把所有小于号（"),e("code",[t._v("<")]),t._v("）都替换成对应的 HTML 实体形式（"),e("code",[t._v("&lt;")]),t._v("）。结果代码就是这样的：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('<script type="text/javascript">\n  function compare(a, b) {\n    if (a &lt; b) {\n      console.log("A is less than B");\n    } else if (a > b) {\n      console.log("A is greater than B");\n    } else {\n      console.log("A is equal to B");\n    }\n  }\n<\/script>\n')])])]),e("p",[t._v("这样代码就可以在 XHTML 页面中运行了。不过，缺点是会影响阅读。好在还有另一种方法。")]),t._v(" "),e("p",[t._v("第二种方法是把所有代码都包含到一个 CDATA 块中。在 XHTML（及 XML）中，CDATA 块表示文档中可以包含任意文本的区块，其内容不作为标签来解析，因此可以在其中包含任意字符，包括小于号，并且不会引发语法错误。使用 CDATA 的格式如下：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('<script type="text/javascript"><![CDATA[\n  function compare(a, b) {\n    if (a < b) {\n      console.log("A is less than B");\n    } else if (a > b) {\n      console.log("A is greater than B");\n    } else {\n      console.log("A is equal to B");\n    }\n  }\n]]><\/script>\n')])])]),e("p",[t._v("在兼容 XHTML 的浏览器中，这样能解决问题。但在不支持 CDATA 块的非 XHTML 兼容浏览器中则不行。为此，CDATA 标记必须使用 JavaScript 注释来抵消：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('<script type="text/javascript">\n//<![CDATA[\n  function compare(a, b) {\n    if (a < b) {\n      console.log("A is less than B");\n    } else if (a > b) {\n      console.log("A is greater than B");\n    } else {\n      console.log("A is equal to B");\n    }\n  }\n//]]>\n<\/script>\n')])])]),e("p",[t._v("这种格式适用于所有现代浏览器。虽然有点黑科技的味道，但它可以通过 XHTML 验证，而且对 XHTML 之前的浏览器也能优雅地降级。")]),t._v(" "),e("blockquote",[e("p",[e("strong",[t._v("注意")]),t._v("　 XHTML 模式会在页面的 MIME 类型被指定为"),e("code",[t._v('"application/xhtml+xml"')]),t._v("时触发。并不是所有浏览器都支持以这种方式送达的 XHTML。")])]),t._v(" "),e("h3",{attrs:{id:"_2-1-6-废弃的语法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-6-废弃的语法"}},[t._v("#")]),t._v(" 2.1.6 　废弃的语法")]),t._v(" "),e("p",[t._v("自 1995 年 Netscape 2 发布以来，所有浏览器都将 JavaScript 作为默认的编程语言。"),e("code",[t._v("type")]),t._v("属性使用一个 MIME 类型字符串来标识"),e("code",[t._v("<script>")]),t._v("的内容，但 MIME 类型并没有跨浏览器标准化。即使浏览器默认使用 JavaScript，在某些情况下某个无效或无法识别的 MIME 类型也可能导致浏览器跳过（不执行）相关代码。因此，除非你使用 XHML 或"),e("code",[t._v("<script>")]),t._v("标签要求或包含非 JavaScript 代码，最佳做法是不指定"),e("code",[t._v("type")]),t._v("属性。")]),t._v(" "),e("p",[t._v("在最初采用"),e("code",[t._v("script")]),t._v("元素时，它标志着开始走向与传统 HTML 解析不同的流程。对这个元素需要应用特殊的解析规则，而这在不支持 JavaScript 的浏览器（特别是 Mosaic）中会导致问题。不支持的浏览器会把"),e("code",[t._v("<script>")]),t._v("元素的内容输出到页面上，从而破坏页面的外观。")]),t._v(" "),e("p",[t._v("Netscape 联合 Mosaic 拿出了一个解决方案，对不支持 JavaScript 的浏览器隐藏嵌入的 JavaScript 代码。最终方案是把脚本代码包含在一个 HTML 注释中，像这样：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('<script>\x3c!--\n  function sayHi(){\n    console.log("Hi!");\n  }\n//--\x3e<\/script>\n')])])]),e("p",[t._v("使用这种格式，Mosaic 等浏览器就可以忽略"),e("code",[t._v("<script>")]),t._v("标签中的内容，而支持 JavaScript 的浏览器则必须识别这种模式，将其中的内容作为 JavaScript 来解析。")]),t._v(" "),e("p",[t._v("虽然这种格式仍然可以被所有浏览器识别和解析，但已经不再必要，而且不应该再使用了。在 XHTML 模式下，这种格式也会导致脚本被忽略，因为代码处于有效的 XML 注释当中。")]),t._v(" "),e("h2",{attrs:{id:"_2-2-行内代码与外部文件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-行内代码与外部文件"}},[t._v("#")]),t._v(" 2.2 　行内代码与外部文件")]),t._v(" "),e("p",[t._v("虽然可以直接在 HTML 文件中嵌入 JavaScript 代码，但通常认为最佳实践是尽可能将 JavaScript 代码放在外部文件中。不过这个最佳实践并不是明确的强制性规则。推荐使用外部文件的理由如下。")]),t._v(" "),e("ul",[e("li",[e("strong",[t._v("可维护性")]),t._v("。JavaScript 代码如果分散到很多 HTML 页面，会导致维护困难。而用一个目录保存所有 JavaScript 文件，则更容易维护，这样开发者就可以独立于使用它们的 HTML 页面来编辑代码。")]),t._v(" "),e("li",[e("strong",[t._v("缓存")]),t._v("。浏览器会根据特定的设置缓存所有外部链接的 JavaScript 文件，这意味着如果两个页面都用到同一个文件，则该文件只需下载一次。这最终意味着页面加载更快。")]),t._v(" "),e("li",[e("strong",[t._v("适应未来")]),t._v("。通过把 JavaScript 放到外部文件中，就不必考虑用 XHTML 或前面提到的注释黑科技。包含外部 JavaScript 文件的语法在 HTML 和 XHTML 中是一样的。")])]),t._v(" "),e("p",[t._v("在配置浏览器请求外部文件时，要重点考虑的一点是它们会占用多少带宽。在 SPDY/HTTP2 中，预请求的消耗已显著降低，以轻量、独立 JavaScript 组件形式向客户端送达脚本更具优势。")]),t._v(" "),e("p",[t._v("比如，第一个页面包含如下脚本：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('<script src="mainA.js"><\/script>\n<script src="component1.js"><\/script>\n<script src="component2.js"><\/script>\n<script src="component3.js"><\/script>\n...\n')])])]),e("p",[t._v("后续页面可能包含如下脚本：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('<script src="mainB.js"><\/script>\n<script src="component3.js"><\/script>\n<script src="component4.js"><\/script>\n<script src="component5.js"><\/script>\n...\n')])])]),e("p",[t._v("在初次请求时，如果浏览器支持 SPDY/HTTP2，就可以从同一个地方取得一批文件，并将它们逐个放到浏览器缓存中。从浏览器角度看，通过 SPDY/HTTP2 获取所有这些独立的资源与获取一个大 JavaScript 文件的延迟差不多。")]),t._v(" "),e("p",[t._v("在第二个页面请求时，由于你已经把应用程序切割成了轻量可缓存的文件，第二个页面也依赖的某些组件此时已经存在于浏览器缓存中了。")]),t._v(" "),e("p",[t._v("当然，这里假设浏览器支持 SPDY/HTTP2，只有比较新的浏览器才满足。如果你还想支持那些比较老的浏览器，可能还是用一个大文件更合适。")]),t._v(" "),e("h2",{attrs:{id:"_2-3-文档模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-文档模式"}},[t._v("#")]),t._v(" 2.3 　文档模式")]),t._v(" "),e("p",[t._v("IE5.5 发明了文档模式的概念，即可以使用"),e("code",[t._v("doctype")]),t._v("切换文档模式。最初的文档模式有两种："),e("strong",[t._v("混杂模式")]),t._v("（quirks mode）和"),e("strong",[t._v("标准模式")]),t._v("（standards mode）。前者让 IE 像 IE5 一样（支持一些非标准的特性），后者让 IE 具有兼容标准的行为。虽然这两种模式的主要区别只体现在通过 CSS 渲染的内容方面，但对 JavaScript 也有一些关联影响，或称为副作用。本书会经常提到这些副作用。")]),t._v(" "),e("p",[t._v("IE 初次支持文档模式切换以后，其他浏览器也跟着实现了。随着浏览器的普遍实现，又出现了第三种文档模式："),e("strong",[t._v("准标准模式")]),t._v("（almost standards mode）。这种模式下的浏览器支持很多标准的特性，但是没有标准规定得那么严格。主要区别在于如何对待图片元素周围的空白（在表格中使用图片时最明显）。")]),t._v(" "),e("p",[t._v("混杂模式在所有浏览器中都以省略文档开头的"),e("code",[t._v("doctype")]),t._v("声明作为开关。这种约定并不合理，因为混杂模式在不同浏览器中的差异非常大，不使用黑科技基本上就没有浏览器一致性可言。")]),t._v(" "),e("p",[t._v("标准模式通过下列几种文档类型声明开启：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('\x3c!-- HTML 4.01 Strict --\x3e\n<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"\n"http://www.w3.org/TR/html4/strict.dtd">\n\n\x3c!-- XHTML 1.0 Strict --\x3e\n<!DOCTYPE html PUBLIC\n"-//W3C//DTD XHTML 1.0 Strict//EN"\n"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">\n\x3c!-- HTML5 --\x3e\n<!DOCTYPE html>\n')])])]),e("p",[t._v("准标准模式通过过渡性文档类型（"),e("code",[t._v("Transitional")]),t._v("）和框架集文档类型（"),e("code",[t._v("Frameset")]),t._v("）来触发：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('\x3c!-- HTML 4.01 Transitional --\x3e\n<!DOCTYPE HTML PUBLIC\n"-//W3C//DTD HTML 4.01 Transitional//EN"\n"http://www.w3.org/TR/html4/loose.dtd">\n\n\x3c!-- HTML 4.01 Frameset --\x3e\n<!DOCTYPE HTML PUBLIC\n"-//W3C//DTD HTML 4.01 Frameset//EN"\n"http://www.w3.org/TR/html4/frameset.dtd">\n\n\x3c!-- XHTML 1.0 Transitional --\x3e\n<!DOCTYPE html PUBLIC\n"-//W3C//DTD XHTML 1.0 Transitional//EN"\n"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">\n\n\x3c!-- XHTML 1.0 Frameset --\x3e\n<!DOCTYPE html PUBLIC\n"-//W3C//DTD XHTML 1.0 Frameset//EN"\n"http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd">\n')])])]),e("p",[t._v("准标准模式与标准模式非常接近，很少需要区分。人们在说到“标准模式”时，可能指其中任何一个。而对文档模式的检测（本书后面会讨论）也不会区分它们。本书后面所说的"),e("strong",[t._v("标准模式")]),t._v("，指的就是除混杂模式以外的模式。")]),t._v(" "),e("h2",{attrs:{id:"_2-4-noscript-元素"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-4-noscript-元素"}},[t._v("#")]),t._v(" 2.4 　"),e("code",[t._v("<noscript>")]),t._v("元素")]),t._v(" "),e("p",[t._v("针对早期浏览器不支持 JavaScript 的问题，需要一个页面优雅降级的处理方案。最终，"),e("code",[t._v("<noscript>")]),t._v("元素出现，被用于给不支持 JavaScript 的浏览器提供替代内容。虽然如今的浏览器已经 100%支持 JavaScript，但对于禁用 JavaScript 的浏览器来说，这个元素仍然有它的用处。")]),t._v(" "),e("p",[e("code",[t._v("<noscript>")]),t._v("元素可以包含任何可以出现在"),e("code",[t._v("<body>")]),t._v("中的 HTML 元素，"),e("code",[t._v("<script>")]),t._v("除外。在下列两种情况下，浏览器将显示包含在"),e("code",[t._v("<noscript>")]),t._v("中的内容：")]),t._v(" "),e("ul",[e("li",[t._v("浏览器不支持脚本；")]),t._v(" "),e("li",[t._v("浏览器对脚本的支持被关闭。")])]),t._v(" "),e("p",[t._v("任何一个条件被满足，包含在"),e("code",[t._v("<noscript>")]),t._v("中的内容就会被渲染。否则，浏览器不会渲染"),e("code",[t._v("<noscript>")]),t._v("中的内容。")]),t._v(" "),e("p",[t._v("下面是一个例子：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('<!DOCTYPE html>\n<html>\n  <head>\n  <title>Example HTML Page</title>\n  <script ""defer="defer" src="example1.js"><\/script>\n  <script ""defer="defer" src="example2.js"><\/script>\n  </head>\n  <body>\n  <noscript>\n    <p>This page requires a JavaScript-enabled browser.</p>\n  </noscript>\n  </body>\n</html>\n')])])]),e("p",[t._v("这个例子是在脚本不可用时让浏览器显示一段话。如果浏览器支持脚本，则用户永远不会看到它。")]),t._v(" "),e("h2",{attrs:{id:"_2-5-小结"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-5-小结"}},[t._v("#")]),t._v(" 2.5 　小结")]),t._v(" "),e("p",[t._v("JavaScript 是通过"),e("code",[t._v("<script>")]),t._v("元素插入到 HTML 页面中的。这个元素可用于把 JavaScript 代码嵌入到 HTML 页面中，跟其他标记混合在一起，也可用于引入保存在外部文件中的 JavaScript。本章的重点可以总结如下。")]),t._v(" "),e("ul",[e("li",[t._v("要包含外部 JavaScript 文件，必须将"),e("code",[t._v("src")]),t._v("属性设置为要包含文件的 URL。文件可以跟网页在同一台服务器上，也可以位于完全不同的域。")]),t._v(" "),e("li",[t._v("所有"),e("code",[t._v("<script>")]),t._v("元素会依照它们在网页中出现的次序被解释。在不使用"),e("code",[t._v("defer")]),t._v("和"),e("code",[t._v("async")]),t._v("属性的情况下，包含在"),e("code",[t._v("<script>")]),t._v("元素中的代码必须严格按次序解释。")]),t._v(" "),e("li",[t._v("对不推迟执行的脚本，浏览器必须解释完位于"),e("code",[t._v("<script>")]),t._v("元素中的代码，然后才能继续渲染页面的剩余部分。为此，通常应该把"),e("code",[t._v("<script>")]),t._v("元素放到页面末尾，介于主内容之后及"),e("code",[t._v("</body>")]),t._v("标签之前。")]),t._v(" "),e("li",[t._v("可以使用"),e("code",[t._v("defer")]),t._v("属性把脚本推迟到文档渲染完毕后再执行。推迟的脚本总是按照它们被列出的次序执行。")]),t._v(" "),e("li",[t._v("可以使用"),e("code",[t._v("async")]),t._v("属性表示脚本不需要等待其他脚本，同时也不阻塞文档渲染，即异步加载。异步脚本不能保证按照它们在页面中出现的次序执行。")]),t._v(" "),e("li",[t._v("通过使用"),e("code",[t._v("<noscript>")]),t._v("元素，可以指定在浏览器不支持脚本时显示的内容。如果浏览器支持并启用脚本，则"),e("code",[t._v("<noscript>")]),t._v("元素中的任何内容都不会被渲染。")])])])}),[],!1,null,null,null);a.default=c.exports}}]);