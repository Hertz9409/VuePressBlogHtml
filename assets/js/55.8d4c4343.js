(window.webpackJsonp=window.webpackJsonp||[]).push([[55],{515:function(e,t,a){"use strict";a.r(t);var n=a(27),v=Object(n.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h2",{attrs:{id:"第-6-章-集合引用类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#第-6-章-集合引用类型"}},[e._v("#")]),e._v(" 第 6 章　集合引用类型")]),e._v(" "),a("blockquote",[a("p",[a("strong",[e._v("本章内容")])]),e._v(" "),a("ul",[a("li",[e._v("对象")]),e._v(" "),a("li",[e._v("数组与定型数组")]),e._v(" "),a("li",[a("code",[e._v("Map")]),e._v("、"),a("code",[e._v("WeakMap")]),e._v("、"),a("code",[e._v("Set")]),e._v("以及"),a("code",[e._v("WeakSet")]),e._v("类型")])])]),e._v(" "),a("h2",{attrs:{id:"_6-1-object"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-1-object"}},[e._v("#")]),e._v(" 6.1 　 Object")]),e._v(" "),a("p",[e._v("到目前为止，大多数引用值的示例使用的是"),a("code",[e._v("Object")]),e._v("类型。"),a("code",[e._v("Object")]),e._v("是 ECMAScript 中最常用的类型之一。虽然"),a("code",[e._v("Object")]),e._v("的实例没有多少功能，但很适合存储和在应用程序间交换数据。")]),e._v(" "),a("p",[e._v("显式地创建"),a("code",[e._v("Object")]),e._v("的实例有两种方式。第一种是使用"),a("code",[e._v("new")]),e._v("操作符和"),a("code",[e._v("Object")]),e._v("构造函数，如下所示：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('let person = new Object();\nperson.name = "Nicholas";\nperson.age = 29;\n')])])]),a("p",[e._v("另一种方式是使用"),a("strong",[e._v("对象字面量")]),e._v("（object literal）表示法。对象字面量是对象定义的简写形式，目的是为了简化包含大量属性的对象的创建。比如，下面的代码定义了与前面示例相同的"),a("code",[e._v("person")]),e._v("对象，但使用的是对象字面量表示法：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('let person = {\n  name: "Nicholas",\n  age: 29\n};\n')])])]),a("p",[e._v("在这个例子中，左大括号（"),a("code",[e._v("{")]),e._v("）表示对象字面量开始，因为它出现在一个"),a("strong",[e._v("表达式上下文")]),e._v("（expression context）中。在 ECMAScript 中，表达式上下文指的是期待返回值的上下文。赋值操作符表示后面要期待一个值，因此左大括号表示一个表达式的开始。同样是左大括号，如果出现在"),a("strong",[e._v("语句上下文")]),e._v("（statement context）中，比如"),a("code",[e._v("if")]),e._v("语句的条件后面，则表示一个语句块的开始。")]),e._v(" "),a("p",[e._v("接下来指定了"),a("code",[e._v("name")]),e._v("属性，后跟一个冒号，然后是属性的值。逗号用于在对象字面量中分隔属性，因此字符串"),a("code",[e._v('"Nicholas"')]),e._v("后面有一个逗号，而"),a("code",[e._v("29")]),e._v("后面没有，因为"),a("code",[e._v("age")]),e._v("是这个对象的最后一个属性。在最后一个属性后面加上逗号在非常老的浏览器中会导致报错，但所有现代浏览器都支持这种写法。")]),e._v(" "),a("p",[e._v("在对象字面量表示法中，属性名可以是字符串或数值，比如：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('let person = {\n  "name": "Nicholas",\n  "age": 29,\n  5: true\n};\n')])])]),a("p",[e._v("这个例子会得到一个带有属性"),a("code",[e._v("name")]),e._v("、"),a("code",[e._v("age")]),e._v("和"),a("code",[e._v("5")]),e._v("的对象。注意，数值属性会自动转换为字符串。")]),e._v(" "),a("p",[e._v("当然也可以用对象字面量表示法来定义一个只有默认属性和方法的对象，只要使用一对大括号，中间留空就行了：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('let person = {}; // 与new Object()相同\nperson.name = "Nicholas";\nperson.age = 29;\n')])])]),a("p",[e._v("这个例子跟本节开始的第一个例子是等效的，虽然看起来有点怪。对象字面量表示法通常只在为了让属性一目了然时才使用。")]),e._v(" "),a("blockquote",[a("p",[a("strong",[e._v("注意")]),e._v("　在使用对象字面量表示法定义对象时，并不会实际调用"),a("code",[e._v("Object")]),e._v("构造函数。")])]),e._v(" "),a("p",[e._v("虽然使用哪种方式创建"),a("code",[e._v("Object")]),e._v("实例都可以，但实际上开发者更倾向于使用对象字面量表示法。这是因为对象字面量代码更少，看起来也更有封装所有相关数据的感觉。事实上，对象字面量已经成为给函数传递大量可选参数的主要方式，比如：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('function displayInfo(args) {\n  let output = "";\n\n  if (typeof args.name == "string"){\n    output += "Name: " + args.name + "\\n";\n  }\n\n  if (typeof args.age == "number") {\n    output += "Age: " + args.age + "\\n";\n  }\n\n  alert(output);\n}\n\ndisplayInfo({\n  name: "Nicholas",\n  age: 29\n});\n\ndisplayInfo({\n  name: "Greg"\n});\n')])])]),a("p",[e._v("这里，函数"),a("code",[e._v("displayInfo()")]),e._v("接收一个名为"),a("code",[e._v("args")]),e._v("的参数。这个参数可能有属性"),a("code",[e._v("name")]),e._v("或"),a("code",[e._v("age")]),e._v("，也可能两个属性都有或者都没有。函数内部会使用"),a("code",[e._v("typeof")]),e._v("操作符测试每个属性是否存在，然后根据属性有无构造并显示一条消息。然后，这个函数被调用了两次，每次都通过一个对象字面量传入了不同的数据。两种情况下，函数都正常运行。")]),e._v(" "),a("blockquote",[a("p",[a("strong",[e._v("注意")]),e._v("　这种模式非常适合函数有大量可选参数的情况。一般来说，命名参数更直观，但在可选参数过多的时候就显得笨拙了。最好的方式是对必选参数使用命名参数，再通过一个对象字面量来封装多个可选参数。")])]),e._v(" "),a("p",[e._v("虽然属性一般是通过"),a("strong",[e._v("点语法")]),e._v("来存取的，这也是面向对象语言的惯例，但也可以使用中括号来存取属性。在使用中括号时，要在括号内使用属性名的字符串形式，比如：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('console.log(person["name"]); // "Nicholas"\nconsole.log(person.name);    // "Nicholas"\n')])])]),a("p",[e._v("从功能上讲，这两种存取属性的方式没有区别。使用中括号的主要优势就是可以通过变量访问属性，就像下面这个例子中一样：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('let propertyName = "name";\nconsole.log(person[propertyName]); // "Nicholas"\n')])])]),a("p",[e._v("另外，如果属性名中包含可能会导致语法错误的字符，或者包含关键字/保留字时，也可以使用中括号语法。比如：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('person["first name"] = "Nicholas";\n')])])]),a("p",[e._v("因为"),a("code",[e._v('"first name"')]),e._v("中包含一个空格，所以不能使用点语法来访问。不过，属性名中是可以包含非字母数字字符的，这时候只要用中括号语法存取它们就行了。")]),e._v(" "),a("p",[e._v("通常，点语法是首选的属性存取方式，除非访问属性时必须使用变量。")]),e._v(" "),a("blockquote",[a("p",[a("strong",[e._v("注意")]),e._v("　第 8 章将更全面、深入地介绍"),a("code",[e._v("Object")]),e._v("类型。")])]),e._v(" "),a("h2",{attrs:{id:"_6-2-array"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-2-array"}},[e._v("#")]),e._v(" 6.2 　"),a("code",[e._v("Array")])]),e._v(" "),a("p",[e._v("除了"),a("code",[e._v("Object")]),e._v("，"),a("code",[e._v("Array")]),e._v("应该就是 ECMAScript 中最常用的类型了。ECMAScript 数组跟其他编程语言的数组有很大区别。跟其他语言中的数组一样，ECMAScript 数组也是一组有序的数据，但跟其他语言不同的是，数组中每个槽位可以存储任意类型的数据。这意味着可以创建一个数组，它的第一个元素是字符串，第二个元素是数值，第三个是对象。ECMAScript 数组也是动态大小的，会随着数据添加而自动增长。")]),e._v(" "),a("h3",{attrs:{id:"_6-2-1-创建数组"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-2-1-创建数组"}},[e._v("#")]),e._v(" 6.2.1 　创建数组")]),e._v(" "),a("p",[e._v("有几种基本的方式可以创建数组。一种是使用"),a("code",[e._v("Array")]),e._v("构造函数，比如：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("let colors = new Array();\n")])])]),a("p",[e._v("如果知道数组中元素的数量，那么可以给构造函数传入一个数值，然后"),a("code",[e._v("length")]),e._v("属性就会被自动创建并设置为这个值。比如，下面的代码会创建一个初始"),a("code",[e._v("length")]),e._v("为 20 的数组：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("let colors = new Array(20);\n")])])]),a("p",[e._v("也可以给"),a("code",[e._v("Array")]),e._v("构造函数传入要保存的元素。比如，下面的代码会创建一个包含 3 个字符串值的数组：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('let colors = new Array("red", "blue", "green");\n')])])]),a("p",[e._v("创建数组时可以给构造函数传一个值。这时候就有点问题了，因为如果这个值是数值，则会创建一个长度为指定数值的数组；而如果这个值是其他类型的，则会创建一个只包含该特定值的数组。下面看一个例子：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('let colors = new Array(3);     // 创建一个包含3个元素的数组\nlet names = new Array("Greg"); // 创建一个只包含一个元素，即字符串"Greg"的数组\n')])])]),a("p",[e._v("在使用"),a("code",[e._v("Array")]),e._v("构造函数时，也可以省略"),a("code",[e._v("new")]),e._v("操作符。结果是一样的，比如：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('let colors = Array(3);     // 创建一个包含3个元素的数组\nlet names = Array("Greg"); // 创建一个只包含一个元素，即字符串"Greg"的数组\n')])])]),a("p",[e._v("另一种创建数组的方式是使用"),a("strong",[e._v("数组字面量")]),e._v("（array literal）表示法。数组字面量是在中括号中包含以逗号分隔的元素列表，如下面的例子所示：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('let colors = ["red", "blue", "green"];  // 创建一个包含3个元素的数组\nlet names = [];                         // 创建一个空数组\nlet values = [1,2,];                    // 创建一个包含2个元素的数组\n')])])]),a("p",[e._v("在这个例子中，第一行创建一个包含 3 个字符串的数组。第二行用一对空中括号创建了一个空数组。第三行展示了在数组最后一个值后面加逗号的效果："),a("code",[e._v("values")]),e._v("是一个包含两个值（1 和 2）的数组。")]),e._v(" "),a("blockquote",[a("p",[a("strong",[e._v("注意")]),e._v("　与对象一样，在使用数组字面量表示法创建数组不会调用"),a("code",[e._v("Array")]),e._v("构造函数。")])]),e._v(" "),a("p",[a("code",[e._v("Array")]),e._v("构造函数还有两个 ES6 新增的用于创建数组的静态方法："),a("code",[e._v("from()")]),e._v("和"),a("code",[e._v("of()")]),e._v("。"),a("code",[e._v("from()")]),e._v("用于将类数组结构转换为数组实例，而"),a("code",[e._v("of()")]),e._v("用于将一组参数转换为数组实例。")]),e._v(" "),a("p",[a("code",[e._v("Array.from()")]),e._v("的第一个参数是一个类数组对象，即任何可迭代的结构，或者有一个"),a("code",[e._v("length")]),e._v("属性和可索引元素的结构。这种方式可用于很多场合：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('// 字符串会被拆分为单字符数组\nconsole.log(Array.from("Matt")); // ["M", "a", "t", "t"]\n\n// 可以使用from()将集合和映射转换为一个新数组\nconst m = new Map().set(1, 2)\n                   .set(3, 4);\nconst s = new Set().add(1)\n                   .add(2)\n                   .add(3)\n                   .add(4);\n\nconsole.log(Array.from(m)); // [[1, 2], [3, 4]]\nconsole.log(Array.from(s)); // [1, 2, 3, 4]\n\n// Array.from()对现有数组执行浅复制\nconst a1 = [1, 2, 3, 4];\nconst a2 = Array.from(a1);\n\nconsole.log(a1);        // [1, 2, 3, 4]\nalert(a1 === a2); // false\n\n\n// 可以使用任何可迭代对象\nconst iter = {\n  *[Symbol.iterator]() {\n    yield 1;\n    yield 2;\n    yield 3;\n    yield 4;\n\n  }\n};\nconsole.log(Array.from(iter)); // [1, 2, 3, 4]\n\n// arguments对象可以被轻松地转换为数组\nfunction getArgsArray() {\n  return Array.from(arguments);\n}\nconsole.log(getArgsArray(1, 2, 3, 4)); // [1, 2, 3, 4]\n\n// from()也能转换带有必要属性的自定义对象\nconst arrayLikeObject = {\n  0: 1,\n  1: 2,\n  2: 3,\n  3: 4,\n  length: 4\n};\nconsole.log(Array.from(arrayLikeObject)); // [1, 2, 3, 4]\n')])])]),a("p",[a("code",[e._v("Array.from()")]),e._v("还接收第二个可选的映射函数参数。这个函数可以直接增强新数组的值，而无须像调用"),a("code",[e._v("Array.from().map()")]),e._v("那样先创建一个中间数组。还可以接收第三个可选参数，用于指定映射函数中"),a("code",[e._v("this")]),e._v("的值。但这个重写的"),a("code",[e._v("this")]),e._v("值在箭头函数中不适用。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("const a1 = [1, 2, 3, 4];\nconst a2 = Array.from(a1, x => x**2);\nconst a3 = Array.from(a1, function(x) {return x**this.exponent}, {exponent: 2});\nconsole.log(a2);  // [1, 4, 9, 16]\nconsole.log(a3);  // [1, 4, 9, 16]\n")])])]),a("p",[a("code",[e._v("Array.of()")]),e._v("可以把一组参数转换为数组。这个方法用于替代在 ES6 之前常用的"),a("code",[e._v("Array.prototype.slice.call(arguments)")]),e._v("，一种异常笨拙的将"),a("code",[e._v("arguments")]),e._v("对象转换为数组的写法：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("console.log(Array.of(1, 2, 3, 4)); // [1, 2, 3, 4]\nconsole.log(Array.of(undefined));  // [undefined]\n")])])]),a("h3",{attrs:{id:"_6-2-2-数组空位"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-2-2-数组空位"}},[e._v("#")]),e._v(" 6.2.2 　数组空位")]),e._v(" "),a("p",[e._v("使用数组字面量初始化数组时，可以使用一串逗号来创建空位（hole）。ECMAScript 会将逗号之间相应索引位置的值当成空位，ES6 规范重新定义了该如何处理这些空位。")]),e._v(" "),a("p",[e._v("可以像下面这样创建一个空位数组：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("const options = [,,,,,]; // 创建包含5个元素的数组\nconsole.log(options.length);   // 5\nconsole.log(options);          // [,,,,,]\n")])])]),a("p",[e._v("ES6 新增的方法和迭代器与早期 ECMAScript 版本中存在的方法行为不同。ES6 新增方法普遍将这些空位当成存在的元素，只不过值为"),a("code",[e._v("undefined")]),e._v("：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("const options = [1,,,,5];\n\nfor (const option of options) {\n  console.log(option === undefined);\n}\n// false\n// true\n// true\n// true\n// false\n\nconst a = Array.from([,,,]); // 使用ES6的Array.from()创建的包含3个空位的数组\nfor (const val of a) {\n  alert(val === undefined);\n}\n// true\n// true\n// true\n\nalert(Array.of(...[,,,])); // [undefined, undefined, undefined]\n\nfor (const [index, value] of options.entries()) {\n  alert(value);\n}\n// 1\n// undefined\n// undefined\n// undefined\n// 5\n")])])]),a("p",[e._v("ES6 之前的方法则会忽略这个空位，但具体的行为也会因方法而异：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("const options = [1,,,,5];\n\n// map()会跳过空位置\nconsole.log(options.map(() => 6));  // [6, undefined, undefined, undefined, 6]\n\n// join()视空位置为空字符串\nconsole.log(options.join('-'));     // \"1----5\"\n")])])]),a("blockquote",[a("p",[a("strong",[e._v("注意")]),e._v("　由于行为不一致和存在性能隐患，因此实践中要避免使用数组空位。如果确实需要空位，则可以显式地用"),a("code",[e._v("undefined")]),e._v("值代替。")])]),e._v(" "),a("h3",{attrs:{id:"_6-2-3-数组索引"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-2-3-数组索引"}},[e._v("#")]),e._v(" 6.2.3 　数组索引")]),e._v(" "),a("p",[e._v("要取得或设置数组的值，需要使用中括号并提供相应值的数字索引，如下所示：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('let colors = ["red", "blue", "green"];  // 定义一个字符串数组\nalert(colors[0]);                       // 显示第一项\ncolors[2] = "black";                    // 修改第三项\ncolors[3] = "brown";                    // 添加第四项\n')])])]),a("p",[e._v("在中括号中提供的索引表示要访问的值。如果索引小于数组包含的元素数，则返回存储在相应位置的元素，就像示例中"),a("code",[e._v("colors[0]")]),e._v("显示"),a("code",[e._v('"red"')]),e._v("一样。设置数组的值方法也是一样的，就是替换指定位置的值。如果把一个值设置给超过数组最大索引的索引，就像示例中的"),a("code",[e._v("colors[3]")]),e._v("，则数组长度会自动扩展到该索引值加 1（示例中设置的索引 3，所以数组长度变成了 4）。")]),e._v(" "),a("p",[e._v("数组中元素的数量保存在"),a("code",[e._v("length")]),e._v("属性中，这个属性始终返回 0 或大于 0 的值，如下例所示：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('let colors = ["red", "blue", "green"];  // 创建一个包含3个字符串的数组\nlet names = [];                         // 创建一个空数组\n\nalert(colors.length); // 3\nalert(names.length);  // 0\n')])])]),a("p",[e._v("数组"),a("code",[e._v("length")]),e._v("属性的独特之处在于，它不是只读的。通过修改"),a("code",[e._v("length")]),e._v("属性，可以从数组末尾删除或添加元素。来看下面的例子：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('let colors = ["red", "blue", "green"]; // 创建一个包含3个字符串的数组\ncolors.length = 2;\nalert(colors[2]);  // undefined\n')])])]),a("p",[e._v("这里，数组"),a("code",[e._v("colors")]),e._v("一开始有 3 个值。将"),a("code",[e._v("length")]),e._v("设置为 2，就删除了最后一个（位置 2 的）值，因此"),a("code",[e._v("colors[2]")]),e._v("就没有值了。如果将"),a("code",[e._v("length")]),e._v("设置为大于数组元素数的值，则新添加的元素都将以"),a("code",[e._v("undefined")]),e._v("填充，如下例所示：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('let colors = ["red", "blue", "green"];  // 创建一个包含3个字符串的数组\ncolors.length = 4;\nalert(colors[3]);  // undefined\n')])])]),a("p",[e._v("这里将数组"),a("code",[e._v("colors")]),e._v("的"),a("code",[e._v("length")]),e._v("设置为 4，虽然数组只包含 3 个元素。位置 3 在数组中不存在，因此访问其值会返回特殊值"),a("code",[e._v("undefined")]),e._v("。")]),e._v(" "),a("p",[e._v("使用"),a("code",[e._v("length")]),e._v("属性可以方便地向数组末尾添加元素，如下例所示：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('let colors = ["red", "blue", "green"];  // 创建一个包含3个字符串的数组\ncolors[colors.length] = "black";        // 添加一种颜色（位置3）\ncolors[colors.length] = "brown";        // 再添加一种颜色（位置4）\n')])])]),a("p",[e._v("数组中最后一个元素的索引始终是"),a("code",[e._v("length - 1")]),e._v("，因此下一个新增槽位的索引就是"),a("code",[e._v("length")]),e._v("。每次在数组最后一个元素后面新增一项，数组的"),a("code",[e._v("length")]),e._v("属性都会自动更新，以反映变化。这意味着第二行的"),a("code",[e._v("colors[colors.length]")]),e._v("会在位置 3 添加一个新元素，下一行则会在位置 4 添加一个新元素。新的长度会在新增元素被添加到当前数组外部的位置上时自动更新。换句话说，就是"),a("code",[e._v("length")]),e._v("属性会更新为位置加上 1，如下例所示：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('let colors = ["red", "blue", "green"];  // 创建一个包含3个字符串的数组\ncolors[99] = "black";                   // 添加一种颜色（位置99）\nalert(colors.length);                   // 100\n')])])]),a("p",[e._v("这里，"),a("code",[e._v("colors")]),e._v("数组有一个值被插入到位置 99，结果新"),a("code",[e._v("length")]),e._v("就变成了 100（99 + 1）。这中间的所有元素，即位置 3~98，实际上并不存在，因此在访问时会返回"),a("code",[e._v("undefined")]),e._v("。")]),e._v(" "),a("blockquote",[a("p",[a("strong",[e._v("注意")]),e._v("　数组最多可以包含 4 294 967 295 个元素，这对于大多数编程任务应该足够了。如果尝试添加更多项，则会导致抛出错误。以这个最大值作为初始值创建数组，可能导致脚本运行时间过长的错误。")])]),e._v(" "),a("h3",{attrs:{id:"_6-2-4-检测数组"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-2-4-检测数组"}},[e._v("#")]),e._v(" 6.2.4 　检测数组")]),e._v(" "),a("p",[e._v("一个经典的 ECMAScript 问题是判断一个对象是不是数组。在只有一个网页（因而只有一个全局作用域）的情况下，使用"),a("code",[e._v("instanceof")]),e._v("操作符就足矣：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("if (value instanceof Array){\n  // 操作数组\n}\n")])])]),a("p",[e._v("使用"),a("code",[e._v("instanceof")]),e._v("的问题是假定只有一个全局执行上下文。如果网页里有多个框架，则可能涉及两个不同的全局执行上下文，因此就会有两个不同版本的"),a("code",[e._v("Array")]),e._v("构造函数。如果要把数组从一个框架传给另一个框架，则这个数组的构造函数将有别于在第二个框架内本地创建的数组。")]),e._v(" "),a("p",[e._v("为解决这个问题，ECMAScript 提供了"),a("code",[e._v("Array.isArray()")]),e._v("方法。这个方法的目的就是确定一个值是否为数组，而不用管它是在哪个全局执行上下文中创建的。来看下面的例子：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("if (Array.isArray(value)){\n  // 操作数组\n}\n")])])]),a("h3",{attrs:{id:"_6-2-5-迭代器方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-2-5-迭代器方法"}},[e._v("#")]),e._v(" 6.2.5 　迭代器方法")]),e._v(" "),a("p",[e._v("在 ES6 中，"),a("code",[e._v("Array")]),e._v("的原型上暴露了 3 个用于检索数组内容的方法："),a("code",[e._v("keys()")]),e._v("、"),a("code",[e._v("values()")]),e._v("和"),a("code",[e._v("entries()")]),e._v("。"),a("code",[e._v("keys()")]),e._v("返回数组索引的迭代器，"),a("code",[e._v("values()")]),e._v("返回数组元素的迭代器，而"),a("code",[e._v("entries()")]),e._v("返回索引/值对的迭代器：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('const a = ["foo", "bar", "baz", "qux"];\n\n// 因为这些方法都返回迭代器，所以可以将它们的内容\n// 通过Array.from()直接转换为数组实例\nconst aKeys = Array.from(a.keys());\nconst aValues = Array.from(a.values());\nconst aEntries = Array.from(a.entries());\n\nconsole.log(aKeys);     // [0, 1, 2, 3]\nconsole.log(aValues);   // ["foo", "bar", "baz", "qux"]\nconsole.log(aEntries);  // [[0, "foo"], [1, "bar"], [2, "baz"], [3, "qux"]]\n')])])]),a("p",[e._v("使用 ES6 的解构可以非常容易地在循环中拆分键/值对：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('const a = ["foo", "bar", "baz", "qux"];\n\nfor (const [idx, element] of a.entries()) [\n  alert(idx);\n  alert(element);\n}\n// 0\n// foo\n// 1\n// bar\n// 2\n// baz\n// 3\n// qux\n')])])]),a("blockquote",[a("p",[a("strong",[e._v("注意")]),e._v("　虽然这些方法是 ES6 规范定义的，但在 2017 年底的时候仍有浏览器没有实现它们。")])]),e._v(" "),a("h3",{attrs:{id:"_6-2-6-复制和填充方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-2-6-复制和填充方法"}},[e._v("#")]),e._v(" 6.2.6 　复制和填充方法")]),e._v(" "),a("p",[e._v("ES6 新增了两个方法：批量复制方法"),a("code",[e._v("fill()")]),e._v("，以及填充数组方法"),a("code",[e._v("copyWithin()")]),e._v("。这两个方法的函数签名类似，都需要指定既有数组实例上的一个范围，包含开始索引，不包含结束索引。使用这个方法创建的数组不能缩放。")]),e._v(" "),a("p",[e._v("使用"),a("code",[e._v("fill()")]),e._v("方法可以向一个已有的数组中插入全部或部分相同的值。开始索引用于指定开始填充的位置，它是可选的。如果不提供结束索引，则一直填充到数组末尾。负值索引从数组末尾开始计算。也可以将负索引想象成数组长度加上它得到的一个正索引：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("const zeroes = [0, 0, 0, 0, 0];\n\n// 用5填充整个数组\nzeroes.fill(5);\nconsole.log(zeroes);  // [5, 5, 5, 5, 5]\nzeroes.fill(0);       // 重置\n\n// 用6填充索引大于等于3的元素\nzeroes.fill(6, 3);\nconsole.log(zeroes);  // [0, 0, 0, 6, 6]\nzeroes.fill(0);       // 重置\n\n// 用7填充索引大于等于1且小于3的元素\nzeroes.fill(7, 1, 3);\nconsole.log(zeroes);  // [0, 7, 7, 0, 0];\nzeroes.fill(0);       // 重置\n\n// 用8填充索引大于等于1且小于4的元素\n// (-4 + zeroes.length = 1)\n// (-1 + zeroes.length = 4)\nzeroes.fill(8, -4, -1);\nconsole.log(zeroes);  // [0, 8, 8, 8, 0];\n")])])]),a("p",[a("code",[e._v("fill()")]),e._v("静默忽略超出数组边界、零长度及方向相反的索引范围：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("const zeroes = [0, 0, 0, 0, 0];\n\n// 索引过低，忽略\nzeroes.fill(1, -10, -6);\nconsole.log(zeroes);  // [0, 0, 0, 0, 0]\n\n// 索引过高，忽略\nzeroes.fill(1, 10, 15);\nconsole.log(zeroes);  // [0, 0, 0, 0, 0]\n\n// 索引反向，忽略\nzeroes.fill(2, 4, 2);\nconsole.log(zeroes);  // [0, 0, 0, 0, 0]\n\n// 索引部分可用，填充可用部分\nzeroes.fill(4, 3, 10)\nconsole.log(zeroes);  // [0, 0, 0, 4, 4]\n")])])]),a("p",[e._v("与"),a("code",[e._v("fill()")]),e._v("不同，"),a("code",[e._v("copyWithin()")]),e._v("会按照指定范围浅复制数组中的部分内容，然后将它们插入到指定索引开始的位置。开始索引和结束索引则与"),a("code",[e._v("fill()")]),e._v("使用同样的计算方法：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("let ints,\n    reset = () => ints = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\nreset();\n\n// 从ints中复制索引0开始的内容，插入到索引5开始的位置\n// 在源索引或目标索引到达数组边界时停止\nints.copyWithin(5);\nconsole.log(ints);  // [0, 1, 2, 3, 4, 0, 1, 2, 3, 4]\nreset();\n\n// 从ints中复制索引5开始的内容，插入到索引0开始的位置\nints.copyWithin(0, 5);\nconsole.log(ints);  // [5, 6, 7, 8, 9, 5, 6, 7, 8, 9]\nreset();\n\n// 从ints中复制索引0开始到索引3结束的内容\n// 插入到索引4开始的位置\nints.copyWithin(4, 0, 3);\nalert(ints);  // [0, 1, 2, 3, 0, 1, 2, 7, 8, 9]\nreset();\n\n// JavaScript引擎在插值前会完整复制范围内的值\n// 因此复制期间不存在重写的风险\nints.copyWithin(2, 0, 6);\nalert(ints);  // [0, 1, 0, 1, 2, 3, 4, 5, 8, 9]\nreset();\n\n// 支持负索引值，与fill()相对于数组末尾计算正向索引的过程是一样的\nints.copyWithin(-4, -7, -3);\nalert(ints);  // [0, 1, 2, 3, 4, 5, 3, 4, 5, 6]\n")])])]),a("p",[a("code",[e._v("copyWithin()")]),e._v("静默忽略超出数组边界、零长度及方向相反的索引范围：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("let ints,\n    reset = () => ints = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\nreset();\n\n// 索引过低，忽略\nints.copyWithin(1, -15, -12);\nalert(ints);  // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\nreset()\n\n// 索引过高，忽略\nints.copyWithin(1, 12, 15);\nalert(ints);  // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\nreset();\n\n// 索引反向，忽略\nints.copyWithin(2, 4, 2);\nalert(ints);  // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\nreset();\n\n// 索引部分可用，复制、填充可用部分\nints.copyWithin(4, 7, 10)\nalert(ints);  // [0, 1, 2, 3, 7, 8, 9, 7, 8, 9];\n")])])]),a("h3",{attrs:{id:"_6-2-7-转换方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-2-7-转换方法"}},[e._v("#")]),e._v(" 6.2.7 　转换方法")]),e._v(" "),a("p",[e._v("前面提到过，所有对象都有"),a("code",[e._v("toLocaleString()")]),e._v("、"),a("code",[e._v("toString()")]),e._v("和"),a("code",[e._v("valueOf()")]),e._v("方法。其中，"),a("code",[e._v("valueOf()")]),e._v("返回的还是数组本身。而"),a("code",[e._v("toString()")]),e._v("返回由数组中每个值的等效字符串拼接而成的一个逗号分隔的字符串。也就是说，对数组的每个值都会调用其"),a("code",[e._v("toString()")]),e._v("方法，以得到最终的字符串。来看下面的例子：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('let colors = ["red", "blue", "green"]; // 创建一个包含3个字符串的数组\nalert(colors.toString());   // red,blue,green\nalert(colors.valueOf());    // red,blue,green\nalert(colors);              // red,blue,green\n')])])]),a("p",[e._v("首先是被显式调用的"),a("code",[e._v("toString()")]),e._v("和"),a("code",[e._v("valueOf()")]),e._v("方法，它们分别返回了数组的字符串表示，即将所有字符串组合起来，以逗号分隔。最后一行代码直接用"),a("code",[e._v("alert()")]),e._v("显示数组，因为"),a("code",[e._v("alert()")]),e._v("期待字符串，所以会在后台调用数组的"),a("code",[e._v("toString()")]),e._v("方法，从而得到跟前面一样的结果。")]),e._v(" "),a("p",[a("code",[e._v("toLocaleString()")]),e._v("方法也可能返回跟"),a("code",[e._v("toString()")]),e._v("和"),a("code",[e._v("valueOf()")]),e._v("相同的结果，但也不一定。在调用数组的"),a("code",[e._v("toLocaleString()")]),e._v("方法时，会得到一个逗号分隔的数组值的字符串。它与另外两个方法唯一的区别是，为了得到最终的字符串，会调用数组每个值的"),a("code",[e._v("toLocaleString()")]),e._v("方法，而不是"),a("code",[e._v("toString()")]),e._v("方法。看下面的例子：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('let person1 = {\n  toLocaleString() {\n    return "Nikolaos";\n  },\n\n  toString() {\n    return "Nicholas";\n  }\n};\n\nlet person2 = {\n  toLocaleString() {\n    return "Grigorios";\n  },\n\n  toString() {\n    return "Greg";\n  }\n};\n\nlet people = [person1, person2];\nalert(people);                   // Nicholas,Greg\nalert(people.toString());        // Nicholas,Greg\nalert(people.toLocaleString());  // Nikolaos,Grigorios\n')])])]),a("p",[e._v("这里定义了两个对象"),a("code",[e._v("person1")]),e._v("和"),a("code",[e._v("person2")]),e._v("，它们都定义了"),a("code",[e._v("toString()")]),e._v("和"),a("code",[e._v("toLocaleString()")]),e._v("方法，而且返回不同的值。然后又创建了一个包含这两个对象的数组"),a("code",[e._v("people")]),e._v("。在将数组传给"),a("code",[e._v("alert()")]),e._v("时，输出的是"),a("code",[e._v('"Nicholas,Greg"')]),e._v("，这是因为会在数组每一项上调用"),a("code",[e._v("toString()")]),e._v("方法（与下一行显式调用"),a("code",[e._v("toString()")]),e._v("方法结果一样）。而在调用数组的"),a("code",[e._v("toLocaleString()")]),e._v("方法时，结果变成了"),a("code",[e._v('"Nikolaos, Grigorios"')]),e._v("，这是因为调用了数组每一项的"),a("code",[e._v("toLocaleString()")]),e._v("方法。")]),e._v(" "),a("p",[e._v("继承的方法"),a("code",[e._v("toLocaleString()")]),e._v("以及"),a("code",[e._v("toString()")]),e._v("都返回数组值的逗号分隔的字符串。如果想使用不同的分隔符，则可以使用"),a("code",[e._v("join()")]),e._v("方法。"),a("code",[e._v("join()")]),e._v("方法接收一个参数，即字符串分隔符，返回包含所有项的字符串。来看下面的例子：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('let colors = ["red", "green", "blue"];\nalert(colors.join(","));     // red,green,blue\nalert(colors.join("||"));    // red||green||blue\n')])])]),a("p",[e._v("这里在"),a("code",[e._v("colors")]),e._v("数组上调用了"),a("code",[e._v("join()")]),e._v("方法，得到了与调用"),a("code",[e._v("toString()")]),e._v("方法相同的结果。传入逗号，结果就是逗号分隔的字符串。最后一行给"),a("code",[e._v("join()")]),e._v("传入了双竖线，得到了字符串"),a("code",[e._v('"red||green||blue"')]),e._v("。如果不给"),a("code",[e._v("join()")]),e._v("传入任何参数，或者传入"),a("code",[e._v("undefined")]),e._v("，则仍然使用逗号作为分隔符。")]),e._v(" "),a("blockquote",[a("p",[a("strong",[e._v("注意")]),e._v("　如果数组中某一项是"),a("code",[e._v("null")]),e._v("或"),a("code",[e._v("undefined")]),e._v("，则在"),a("code",[e._v("join()")]),e._v("、"),a("code",[e._v("toLocaleString()")]),e._v("、"),a("code",[e._v("toString()")]),e._v("和"),a("code",[e._v("valueOf()")]),e._v("返回的结果中会以空字符串表示。")])]),e._v(" "),a("h3",{attrs:{id:"_6-2-8-栈方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-2-8-栈方法"}},[e._v("#")]),e._v(" 6.2.8 　栈方法")]),e._v(" "),a("p",[e._v("ECMAScript 给数组提供几个方法，让它看起来像是另外一种数据结构。数组对象可以像栈一样，也就是一种限制插入和删除项的数据结构。栈是一种后进先出（LIFO，Last-In-First-Out）的结构，也就是最近添加的项先被删除。数据项的插入（称为"),a("strong",[e._v("推入")]),e._v("，push）和删除（称为"),a("strong",[e._v("弹出")]),e._v("，pop）只在栈的一个地方发生，即栈顶。ECMAScript 数组提供了"),a("code",[e._v("push()")]),e._v("和"),a("code",[e._v("pop()")]),e._v("方法，以实现类似栈的行为。")]),e._v(" "),a("p",[a("code",[e._v("push()")]),e._v("方法接收任意数量的参数，并将它们添加到数组末尾，返回数组的最新长度。"),a("code",[e._v("pop()")]),e._v("方法则用于删除数组的最后一项，同时减少数组的"),a("code",[e._v("length")]),e._v("值，返回被删除的项。来看下面的例子：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('let colors = new Array();                 // 创建一个数组\nlet count = colors.push("red", "green");  // 推入两项\nalert(count);                             // 2\n\ncount = colors.push("black");  // 再推入一项\nalert(count);                  // 3\n\nlet item = colors.pop();       // 取得最后一项\nalert(item);                   // black\nalert(colors.length);          // 2\n')])])]),a("p",[e._v("这里创建了一个当作栈来使用的数组（注意不需要任何额外的代码，"),a("code",[e._v("push()")]),e._v("和"),a("code",[e._v("pop()")]),e._v("都是数组的默认方法）。首先，使用"),a("code",[e._v("push()")]),e._v("方法把两个字符串推入数组末尾，将结果保存在变量"),a("code",[e._v("count")]),e._v("中（结果为"),a("code",[e._v("2")]),e._v("）。")]),e._v(" "),a("p",[e._v("然后，再推入另一个值，再把结果保存在"),a("code",[e._v("count")]),e._v("中。因为现在数组中有 3 个元素，所以"),a("code",[e._v("push()")]),e._v("返回"),a("code",[e._v("3")]),e._v("。在调用"),a("code",[e._v("pop()")]),e._v("时，会返回数组的最后一项，即字符串"),a("code",[e._v('"black"')]),e._v("。此时数组还有两个元素。")]),e._v(" "),a("p",[e._v("栈方法可以与数组的其他任何方法一起使用，如下例所示：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('let colors = ["red", "blue"];\ncolors.push("brown");        // 再添加一项\ncolors[3] = "black";         // 添加一项\nalert(colors.length);        // 4\n\nlet item = colors.pop();     // 取得最后一项\nalert(item);                 // black\n')])])]),a("p",[e._v("这里先初始化了包含两个字符串的数组，然后通过"),a("code",[e._v("push()")]),e._v("添加了第三个值，第四个值是通过直接在位置 3 上赋值添加的。调用"),a("code",[e._v("pop()")]),e._v("时，返回了字符串"),a("code",[e._v('"black"')]),e._v("，也就是最后添加到数组的字符串。")]),e._v(" "),a("h3",{attrs:{id:"_6-2-9-队列方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-2-9-队列方法"}},[e._v("#")]),e._v(" 6.2.9 　队列方法")]),e._v(" "),a("p",[e._v("就像栈是以 LIFO 形式限制访问的数据结构一样，队列以先进先出（FIFO，First-In-First-Out）形式限制访问。队列在列表末尾添加数据，但从列表开头获取数据。因为有了在数据末尾添加数据的"),a("code",[e._v("push()")]),e._v("方法，所以要模拟队列就差一个从数组开头取得数据的方法了。这个数组方法叫"),a("code",[e._v("shift()")]),e._v("，它会删除数组的第一项并返回它，然后数组长度减 1。使用"),a("code",[e._v("shift()")]),e._v("和"),a("code",[e._v("push()")]),e._v("，可以把数组当成队列来使用：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('let colors = new Array();                 // 创建一个数组\nlet count = colors.push("red", "green");  // 推入两项\nalert(count);                             // 2\n\ncount = colors.push("black"); // 再推入一项\nalert(count);                 // 3\n\nlet item = colors.shift();  // 取得第一项\nalert(item);                // red\nalert(colors.length);       // 2\n')])])]),a("p",[e._v("这个例子创建了一个数组并用"),a("code",[e._v("push()")]),e._v("方法推入三个值。加粗的那行代码使用"),a("code",[e._v("shift()")]),e._v("方法取得了数组的第一项，即"),a("code",[e._v('"red"')]),e._v("。删除这一项之后，"),a("code",[e._v('"green"')]),e._v("成为第一个元素，"),a("code",[e._v('"black"')]),e._v("成为第二个元素，数组此时就包含两项。")]),e._v(" "),a("p",[e._v("ECMAScript 也为数组提供了"),a("code",[e._v("unshift()")]),e._v("方法。顾名思义，"),a("code",[e._v("unshift()")]),e._v("就是执行跟"),a("code",[e._v("shift()")]),e._v("相反的操作：在数组开头添加任意多个值，然后返回新的数组长度。通过使用"),a("code",[e._v("unshift()")]),e._v("和"),a("code",[e._v("pop()")]),e._v("，可以在相反方向上模拟队列，即在数组开头添加新数据，在数组末尾取得数据，如下例所示：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('let colors = new Array();                    // 创建一个数组\nlet count = colors.unshift("red", "green");  // 从数组开头推入两项\nalert(count);                                // 2\n\ncount = colors.unshift("black");  // 再推入一项\nalert(count);                     // 3\n\nlet item = colors.pop();  // 取得最后一项\nalert(item);              // green\nalert(colors.length);     // 2\n')])])]),a("p",[e._v("这里，先创建一个数组，再通过"),a("code",[e._v("unshift()")]),e._v("填充数组。首先，给数组添加"),a("code",[e._v('"red"')]),e._v("和"),a("code",[e._v('"green"')]),e._v("，再添加"),a("code",[e._v('"black"')]),e._v("，得到"),a("code",[e._v('["black","red","green"]')]),e._v("。调用"),a("code",[e._v("pop()")]),e._v("时，删除最后一项"),a("code",[e._v('"green"')]),e._v("并返回它。")]),e._v(" "),a("h3",{attrs:{id:"_6-2-10-排序方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-2-10-排序方法"}},[e._v("#")]),e._v(" 6.2.10 　排序方法")]),e._v(" "),a("p",[e._v("数组有两个方法可以用来对元素重新排序："),a("code",[e._v("reverse()")]),e._v("和"),a("code",[e._v("sort()")]),e._v("。顾名思义，"),a("code",[e._v("reverse()")]),e._v("方法就是将数组元素反向排列。比如：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("let values = [1, 2, 3, 4, 5];\nvalues.reverse();\nalert(values);  // 5,4,3,2,1\n")])])]),a("p",[e._v("这里，数组"),a("code",[e._v("values")]),e._v("的初始状态为"),a("code",[e._v("[1,2,3,4,5]")]),e._v("。通过调用"),a("code",[e._v("reverse()")]),e._v("反向排序，得到了"),a("code",[e._v("[5,4,3,2,1]")]),e._v("。这个方法很直观，但不够灵活，所以才有了"),a("code",[e._v("sort()")]),e._v("方法。")]),e._v(" "),a("p",[e._v("默认情况下，"),a("code",[e._v("sort()")]),e._v("会按照升序重新排列数组元素，即最小的值在前面，最大的值在后面。为此，"),a("code",[e._v("sort()")]),e._v("会在每一项上调用"),a("code",[e._v("String()")]),e._v("转型函数，然后比较字符串来决定顺序。即使数组的元素都是数值，也会先把数组转换为字符串再比较、排序。比如：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("let values = [0, 1, 5, 10, 15];\nvalues.sort();\nalert(values);  // 0,1,10,15,5\n")])])]),a("p",[e._v("一开始数组中数值的顺序是正确的，但调用"),a("code",[e._v("sort()")]),e._v("会按照这些数值的字符串形式重新排序。因此，即使 5 小于 10，但字符串"),a("code",[e._v('"10"')]),e._v("在字符串"),a("code",[e._v('"5"')]),e._v("的前头，所以 10 还是会排到 5 前面。很明显，这在多数情况下都不是最合适的。为此，"),a("code",[e._v("sort()")]),e._v("方法可以接收一个"),a("strong",[e._v("比较函数")]),e._v("，用于判断哪个值应该排在前面。")]),e._v(" "),a("p",[e._v("比较函数接收两个参数，如果第一个参数应该排在第二个参数前面，就返回负值；如果两个参数相等，就返回 0；如果第一个参数应该排在第二个参数后面，就返回正值。下面是使用简单比较函数的一个例子：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function compare(value1, value2) {\n  if (value1 < value2) {\n    return -1;\n  } else if (value1 > value2) {\n    return 1;\n  } else {\n    return 0;\n  }\n}\n")])])]),a("p",[e._v("这个比较函数可以适用于大多数数据类型，可以把它当作参数传给"),a("code",[e._v("sort()")]),e._v("方法，如下所示：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("let values = [0, 1, 5, 10, 15];\nvalues.sort(compare);\nalert(values);  // 0,1,5,10,15\n")])])]),a("p",[e._v("在给"),a("code",[e._v("sort()")]),e._v("方法传入比较函数后，数组中的数值在排序后保持了正确的顺序。当然，比较函数也可以产生降序效果，只要把返回值交换一下即可：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function compare(value1, value2) {\n  if (value1 < value2) {\n    return 1;\n  } else if (value1 > value2) {\n    return -1;\n  } else {\n    return 0;\n  }\n}\n\nlet values = [0, 1, 5, 10, 15];\nvalues.sort(compare);\nalert(values);  // 15,10,5,1,0\n")])])]),a("p",[e._v("此外，这个比较函数还可简写为一个箭头函数：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("let values = [0, 1, 5, 10, 15];\nvalues.sort((a, b) => a < b ? 1 : a > b ? -1 : 0);\nalert(values); // 15,10,5,1,0\n")])])]),a("p",[e._v("在这个修改版函数中，如果第一个值应该排在第二个值后面则返回 1，如果第一个值应该排在第二个值前面则返回-1。交换这两个返回值之后，较大的值就会排在前头，数组就会按照降序排序。当然，如果只是想反转数组的顺序，"),a("code",[e._v("reverse()")]),e._v("更简单也更快。")]),e._v(" "),a("blockquote",[a("p",[a("strong",[e._v("注意")]),e._v(" "),a("code",[e._v("reverse()")]),e._v("和"),a("code",[e._v("sort()")]),e._v("都返回调用它们的数组的引用。")])]),e._v(" "),a("p",[e._v("如果数组的元素是数值，或者是其"),a("code",[e._v("valueOf()")]),e._v("方法返回数值的对象（如"),a("code",[e._v("Date")]),e._v("对象），这个比较函数还可以写得更简单，因为这时可以直接用第二个值减去第一个值：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function compare(value1, value2){\n  return value2 - value1;\n}\n")])])]),a("p",[e._v("比较函数就是要返回小于 0、0 和大于 0 的数值，因此减法操作完全可以满足要求。")]),e._v(" "),a("h3",{attrs:{id:"_6-2-11-操作方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-2-11-操作方法"}},[e._v("#")]),e._v(" 6.2.11 　操作方法")]),e._v(" "),a("p",[e._v("对于数组中的元素，我们有很多操作方法。比如，"),a("code",[e._v("concat()")]),e._v("方法可以在现有数组全部元素基础上创建一个新数组。它首先会创建一个当前数组的副本，然后再把它的参数添加到副本末尾，最后返回这个新构建的数组。如果传入一个或多个数组，则"),a("code",[e._v("concat()")]),e._v("会把这些数组的每一项都添加到结果数组。如果参数不是数组，则直接把它们添加到结果数组末尾。来看下面的例子：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('let colors = ["red", "green", "blue"];\nlet colors2 = colors.concat("yellow", ["black", "brown"]);\n\nconsole.log(colors);   // ["red", "green","blue"]\nconsole.log(colors2);  // ["red", "green", "blue", "yellow", "black", "brown"]\n')])])]),a("p",[e._v("这里先创建一个包含 3 个值的数组"),a("code",[e._v("colors")]),e._v("。然后"),a("code",[e._v("colors")]),e._v("调用"),a("code",[e._v("concat()")]),e._v("方法，传入字符串"),a("code",[e._v('"yellow"')]),e._v("和一个包含"),a("code",[e._v('"black"')]),e._v("和"),a("code",[e._v('"brown"')]),e._v("的数组。保存在"),a("code",[e._v("colors2")]),e._v("中的结果就是"),a("code",[e._v('["red", "green", "blue", "yellow", "black", "brown"]')]),e._v("。原始数组"),a("code",[e._v("colors")]),e._v("保持不变。")]),e._v(" "),a("p",[e._v("打平数组参数的行为可以重写，方法是在参数数组上指定一个特殊的符号："),a("code",[e._v("Symbol.isConcatSpreadable")]),e._v("。这个符号能够阻止"),a("code",[e._v("concat()")]),e._v("打平参数数组。相反，把这个值设置为"),a("code",[e._v("true")]),e._v("可以强制打平类数组对象：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('let colors = ["red", "green", "blue"];\nlet newColors = ["black", "brown"];\nlet moreNewColors = {\n  [Symbol.isConcatSpreadable]: true,\n  length: 2,\n  0: "pink",\n  1: "cyan"\n};\n\nnewColors[Symbol.isConcatSpreadable] = false;\n\n// 强制不打平数组\nlet colors2 = colors.concat("yellow", newColors);\n\n// 强制打平类数组对象\nlet colors3 = colors.concat(moreNewColors);\n\nconsole.log(colors);   // ["red", "green", "blue"]\nconsole.log(colors2);  // ["red", "green", "blue", "yellow", ["black", "brown"]]\nconsole.log(colors3);  // ["red", "green", "blue", "pink", "cyan"]\n')])])]),a("p",[e._v("接下来，方法"),a("code",[e._v("slice()")]),e._v("用于创建一个包含原有数组中一个或多个元素的新数组。"),a("code",[e._v("slice()")]),e._v("方法可以接收一个或两个参数：返回元素的开始索引和结束索引。如果只有一个参数，则"),a("code",[e._v("slice()")]),e._v("会返回该索引到数组末尾的所有元素。如果有两个参数，则"),a("code",[e._v("slice()")]),e._v("返回从开始索引到结束索引对应的所有元素，其中不包含结束索引对应的元素。记住，这个操作不影响原始数组。来看下面的例子：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('let colors = ["red", "green", "blue", "yellow", "purple"];\nlet colors2 = colors.slice(1);\nlet colors3 = colors.slice(1, 4);\n\nalert(colors2);  // green,blue,yellow,purple\nalert(colors3);  // green,blue,yellow\n')])])]),a("p",[e._v("这里，"),a("code",[e._v("colors")]),e._v("数组一开始有 5 个元素。调用"),a("code",[e._v("slice()")]),e._v("传入 1 会得到包含 4 个元素的新数组。其中不包括"),a("code",[e._v('"red"')]),e._v("，这是因为拆分操作要从位置 1 开始，即从"),a("code",[e._v('"green"')]),e._v("开始。得到的"),a("code",[e._v("colors2")]),e._v("数组包含"),a("code",[e._v('"green"')]),e._v("、"),a("code",[e._v('"blue"')]),e._v("、"),a("code",[e._v('"yellow"')]),e._v("和"),a("code",[e._v('"purple"')]),e._v("。"),a("code",[e._v("colors3")]),e._v("数组是通过调用"),a("code",[e._v("slice()")]),e._v("并传入 1 和 4 得到的，即从位置 1 开始复制到位置 3。因此"),a("code",[e._v("colors3")]),e._v("包含"),a("code",[e._v('"green"')]),e._v("、"),a("code",[e._v('"blue"')]),e._v("和"),a("code",[e._v('"yellow"')]),e._v("。")]),e._v(" "),a("blockquote",[a("p",[a("strong",[e._v("注意")]),e._v("　如果"),a("code",[e._v("slice()")]),e._v("的参数有负值，那么就以数值长度加上这个负值的结果确定位置。比如，在包含 5 个元素的数组上调用"),a("code",[e._v("slice(-2,-1)")]),e._v("，就相当于调用"),a("code",[e._v("slice(3,4)")]),e._v("。如果结束位置小于开始位置，则返回空数组。")])]),e._v(" "),a("p",[e._v("或许最强大的数组方法就属"),a("code",[e._v("splice()")]),e._v("了，使用它的方式可以有很多种。"),a("code",[e._v("splice()")]),e._v("的主要目的是在数组中间插入元素，但有"),a("code",[e._v("3")]),e._v("种不同的方式使用这个方法。")]),e._v(" "),a("ul",[a("li",[a("strong",[e._v("删除")]),e._v("。需要给"),a("code",[e._v("splice()")]),e._v("传 2 个参数：要删除的第一个元素的位置和要删除的元素数量。可以从数组中删除任意多个元素，比如"),a("code",[e._v("splice(0, 2)")]),e._v("会删除前两个元素。")]),e._v(" "),a("li",[a("strong",[e._v("插入")]),e._v("。需要给"),a("code",[e._v("splice()")]),e._v("传 3 个参数：开始位置、0（要删除的元素数量）和要插入的元素，可以在数组中指定的位置插入元素。第三个参数之后还可以传第四个、第五个参数，乃至任意多个要插入的元素。比如，"),a("code",[e._v('splice(2, 0, "red", "green")')]),e._v("会从数组位置 2 开始插入字符串"),a("code",[e._v('"red"')]),e._v("和"),a("code",[e._v('"green"')]),e._v("。")]),e._v(" "),a("li",[a("strong",[e._v("替换")]),e._v("。"),a("code",[e._v("splice()")]),e._v("在删除元素的同时可以在指定位置插入新元素，同样要传入 3 个参数：开始位置、要删除元素的数量和要插入的任意多个元素。要插入的元素数量不一定跟删除的元素数量一致。比如，"),a("code",[e._v('splice(2, 1, "red", "green")')]),e._v("会在位置 2 删除一个元素，然后从该位置开始向数组中插入"),a("code",[e._v('"red"')]),e._v("和"),a("code",[e._v('"green"')]),e._v("。")])]),e._v(" "),a("p",[a("code",[e._v("splice()")]),e._v("方法始终返回这样一个数组，它包含从数组中被删除的元素（如果没有删除元素，则返回空数组）。以下示例展示了上述 3 种使用方式。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('let colors = ["red", "green", "blue"];\nlet removed = colors.splice(0,1);  // 删除第一项\nalert(colors);                     // green,blue\nalert(removed);                    // red，只有一个元素的数组\n\nremoved = colors.splice(1, 0, "yellow", "orange");   // 在位置1插入两个元素\nalert(colors);                                       // green,yellow,orange,blue\nalert(removed);                                      // 空数组\n\nremoved = colors.splice(1, 1, "red", "purple");  // 插入两个值，删除一个元素\nalert(colors);                                   // green,red,purple,orange,blue\nalert(removed);                                  // yellow，只有一个元素的数组\n')])])]),a("p",[e._v("这个例子中，"),a("code",[e._v("colors")]),e._v("数组一开始包含 3 个元素。第一次调用"),a("code",[e._v("splice()")]),e._v("时，只删除了第一项，"),a("code",[e._v("colors")]),e._v("中还有"),a("code",[e._v('"green"')]),e._v("和"),a("code",[e._v('"blue"')]),e._v("。第二次调用"),a("code",[e._v("slice()")]),e._v("时，在位置 1 插入两项，然后"),a("code",[e._v("colors")]),e._v("包含"),a("code",[e._v('"green"')]),e._v("、"),a("code",[e._v('"yellow"')]),e._v("、"),a("code",[e._v('"orange"')]),e._v("和"),a("code",[e._v('"blue"')]),e._v("。这次没删除任何项，因此返回空数组。最后一次调用"),a("code",[e._v("splice()")]),e._v("时删除了位置 1 上的一项，同时又插入了"),a("code",[e._v('"red"')]),e._v("和"),a("code",[e._v('"purple"')]),e._v("。最后，"),a("code",[e._v("colors")]),e._v("数组包含"),a("code",[e._v('"green"')]),e._v("、"),a("code",[e._v('"red"')]),e._v("、"),a("code",[e._v('"purple"')]),e._v("、"),a("code",[e._v('"orange"')]),e._v("和"),a("code",[e._v('"blue"')]),e._v("。")]),e._v(" "),a("h3",{attrs:{id:"_6-2-12-搜索和位置方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-2-12-搜索和位置方法"}},[e._v("#")]),e._v(" 6.2.12 　搜索和位置方法")]),e._v(" "),a("p",[e._v("ECMAScript 提供两类搜索数组的方法：按严格相等搜索和按断言函数搜索。")]),e._v(" "),a("ol",[a("li",[a("p",[a("strong",[e._v("严格相等")])]),e._v(" "),a("p",[e._v("ECMAScript 提供了 3 个严格相等的搜索方法："),a("code",[e._v("indexOf()")]),e._v("、"),a("code",[e._v("lastIndexOf()")]),e._v("和"),a("code",[e._v("includes()")]),e._v("。其中，前两个方法在所有版本中都可用，而第三个方法是 ECMAScript 7 新增的。这些方法都接收两个参数：要查找的元素和一个可选的起始搜索位置。"),a("code",[e._v("indexOf()")]),e._v("和"),a("code",[e._v("includes()")]),e._v("方法从数组前头（第一项）开始向后搜索，而"),a("code",[e._v("lastIndexOf()")]),e._v("从数组末尾（最后一项）开始向前搜索。")]),e._v(" "),a("p",[a("code",[e._v("indexOf()")]),e._v("和"),a("code",[e._v("lastIndexOf()")]),e._v("都返回要查找的元素在数组中的位置，如果没找到则返回-1。"),a("code",[e._v("includes()")]),e._v("返回布尔值，表示是否至少找到一个与指定元素匹配的项。在比较第一个参数跟数组每一项时，会使用全等（"),a("code",[e._v("===")]),e._v("）比较，也就是说两项必须严格相等。下面来看一些例子：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];\n\nalert(numbers.indexOf(4));          // 3\nalert(numbers.lastIndexOf(4));      // 5\nalert(numbers.includes(4));         // true\n\nalert(numbers.indexOf(4, 4));       // 5\nalert(numbers.lastIndexOf(4, 4));   // 3\nalert(numbers.includes(4, 7));      // false\n\nlet person = { name: "Nicholas" };\nlet people = [{ name: "Nicholas" }];\nlet morePeople = [person];\n\nalert(people.indexOf(person));      // -1\nalert(morePeople.indexOf(person));  // 0\nalert(people.includes(person));     // false\nalert(morePeople.includes(person)); // true\n')])])])])]),e._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[a("p",[a("strong",[e._v("断言函数")])]),e._v(" "),a("p",[e._v("ECMAScript 也允许按照定义的断言函数搜索数组，每个索引都会调用这个函数。断言函数的返回值决定了相应索引的元素是否被认为匹配。")]),e._v(" "),a("p",[e._v("断言函数接收 3 个参数：元素、索引和数组本身。其中元素是数组中当前搜索的元素，索引是当前元素的索引，而数组就是正在搜索的数组。断言函数返回真值，表示是否匹配。")]),e._v(" "),a("p",[a("code",[e._v("find()")]),e._v("和"),a("code",[e._v("findIndex()")]),e._v("方法使用了断言函数。这两个方法都从数组的最小索引开始。"),a("code",[e._v("find()")]),e._v("返回第一个匹配的元素，"),a("code",[e._v("findIndex()")]),e._v("返回第一个匹配元素的索引。这两个方法也都接收第二个可选的参数，用于指定断言函数内部"),a("code",[e._v("this")]),e._v("的值。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('const people = [\n  {\n    name: "Matt",\n    age: 27\n  },\n  {\n    name: "Nicholas",\n    age: 29\n  }\n];\n\nalert(people.find((element, index, array) => element.age < 28));\n// {name: "Matt", age: 27}\n\nalert(people.findIndex((element, index, array) => element.age < 28));\n// 0\n')])])]),a("p",[e._v("找到匹配项后，这两个方法都不再继续搜索。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("const evens = [2, 4, 6];\n\n// 找到匹配后，永远不会检查数组的最后一个元素\nevens.find((element, index, array) => {\n  console.log(element);\n  console.log(index);\n  console.log(array);\n  return element === 4;\n});\n// 2\n// 0\n// [2, 4, 6]\n// 4\n// 1\n// [2, 4, 6]\n")])])])])]),e._v(" "),a("h3",{attrs:{id:"_6-2-13-迭代方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-2-13-迭代方法"}},[e._v("#")]),e._v(" 6.2.13 　迭代方法")]),e._v(" "),a("p",[e._v("ECMAScript 为数组定义了 5 个迭代方法。每个方法接收两个参数：以每一项为参数运行的函数，以及可选的作为函数运行上下文的作用域对象（影响函数中"),a("code",[e._v("this")]),e._v("的值）。传给每个方法的函数接收 3 个参数：数组元素、元素索引和数组本身。因具体方法而异，这个函数的执行结果可能会也可能不会影响方法的返回值。数组的 5 个迭代方法如下。")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("every()")]),e._v("：对数组每一项都运行传入的函数，如果对每一项函数都返回"),a("code",[e._v("true")]),e._v("，则这个方法返回"),a("code",[e._v("true")]),e._v("。")]),e._v(" "),a("li",[a("code",[e._v("filter()")]),e._v("：对数组每一项都运行传入的函数，函数返回"),a("code",[e._v("true")]),e._v("的项会组成数组之后返回。")]),e._v(" "),a("li",[a("code",[e._v("forEach()")]),e._v("：对数组每一项都运行传入的函数，没有返回值。")]),e._v(" "),a("li",[a("code",[e._v("map()")]),e._v("：对数组每一项都运行传入的函数，返回由每次函数调用的结果构成的数组。")]),e._v(" "),a("li",[a("code",[e._v("some()")]),e._v("：对数组每一项都运行传入的函数，如果有一项函数返回"),a("code",[e._v("true")]),e._v("，则这个方法返回"),a("code",[e._v("true")]),e._v("。")])]),e._v(" "),a("p",[e._v("这些方法都不改变调用它们的数组。")]),e._v(" "),a("p",[e._v("在这些方法中，"),a("code",[e._v("every()")]),e._v("和"),a("code",[e._v("some()")]),e._v("是最相似的，都是从数组中搜索符合某个条件的元素。对"),a("code",[e._v("every()")]),e._v("来说，传入的函数必须对每一项都返回"),a("code",[e._v("true")]),e._v("，它才会返回"),a("code",[e._v("true")]),e._v("；否则，它就返回"),a("code",[e._v("false")]),e._v("。而对"),a("code",[e._v("some()")]),e._v("来说，只要有一项让传入的函数返回"),a("code",[e._v("true")]),e._v("，它就会返回"),a("code",[e._v("true")]),e._v("。下面是一个例子：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];\n\nlet everyResult = numbers.every((item, index, array) => item > 2);\nalert(everyResult);  // false\n\nlet someResult = numbers.some((item, index, array) => item > 2);\nalert(someResult);   // true\n")])])]),a("p",[e._v("以上代码调用了"),a("code",[e._v("every()")]),e._v("和"),a("code",[e._v("some()")]),e._v("，传入的函数都是在给定项大于 2 时返回"),a("code",[e._v("true")]),e._v("。"),a("code",[e._v("every()")]),e._v("返回"),a("code",[e._v("false")]),e._v("是因为并不是每一项都能达到要求。而"),a("code",[e._v("some()")]),e._v("返回"),a("code",[e._v("true")]),e._v("是因为至少有一项满足条件。")]),e._v(" "),a("p",[e._v("下面再看一看"),a("code",[e._v("filter()")]),e._v("方法。这个方法基于给定的函数来决定某一项是否应该包含在它返回的数组中。比如，要返回一个所有数值都大于 2 的数组，可以使用如下代码：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];\n\nlet filterResult = numbers.filter((item, index, array) => item > 2);\nalert(filterResult);  // 3,4,5,4,3\n")])])]),a("p",[e._v("这里，调用"),a("code",[e._v("filter()")]),e._v("返回的数组包含"),a("code",[e._v("3")]),e._v("、"),a("code",[e._v("4")]),e._v("、"),a("code",[e._v("5")]),e._v("、"),a("code",[e._v("4")]),e._v("、"),a("code",[e._v("3")]),e._v("，因为只有对这些项传入的函数才返回"),a("code",[e._v("true")]),e._v("。这个方法非常适合从数组中筛选满足给定条件的元素。")]),e._v(" "),a("p",[e._v("接下来"),a("code",[e._v("map()")]),e._v("方法也会返回一个数组。这个数组的每一项都是对原始数组中同样位置的元素运行传入函数而返回的结果。例如，可以将一个数组中的每一项都乘以 2，并返回包含所有结果的数组，如下所示：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];\n\nlet mapResult = numbers.map((item, index, array) => item * 2);\n\nalert(mapResult);  // 2,4,6,8,10,8,6,4,2\n")])])]),a("p",[e._v("以上代码返回了一个数组，包含原始数组中每个值乘以 2 的结果。这个方法非常适合创建一个与原始数组元素一一对应的新数组。")]),e._v(" "),a("p",[e._v("最后，再来看一看"),a("code",[e._v("forEach()")]),e._v("方法。这个方法只会对每一项运行传入的函数，没有返回值。本质上，"),a("code",[e._v("forEach()")]),e._v("方法相当于使用"),a("code",[e._v("for")]),e._v("循环遍历数组。比如：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];\n\nnumbers.forEach((item, index, array) => {\n  // 执行某些操作\n});\n")])])]),a("p",[e._v("数组的这些迭代方法通过执行不同操作方便了对数组的处理。")]),e._v(" "),a("h3",{attrs:{id:"_6-2-14-归并方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-2-14-归并方法"}},[e._v("#")]),e._v(" 6.2.14 　归并方法")]),e._v(" "),a("p",[e._v("ECMAScript 为数组提供了两个归并方法："),a("code",[e._v("reduce()")]),e._v("和"),a("code",[e._v("reduceRight()")]),e._v("。这两个方法都会迭代数组的所有项，并在此基础上构建一个最终返回值。"),a("code",[e._v("reduce()")]),e._v("方法从数组第一项开始遍历到最后一项。而"),a("code",[e._v("reduceRight()")]),e._v("从最后一项开始遍历至第一项。")]),e._v(" "),a("p",[e._v("这两个方法都接收两个参数：对每一项都会运行的归并函数，以及可选的以之为归并起点的初始值。传给"),a("code",[e._v("reduce()")]),e._v("和"),a("code",[e._v("reduceRight()")]),e._v("的函数接收 4 个参数：上一个归并值、当前项、当前项的索引和数组本身。这个函数返回的任何值都会作为下一次调用同一个函数的第一个参数。如果没有给这两个方法传入可选的第二个参数（作为归并起点值），则第一次迭代将从数组的第二项开始，因此传给归并函数的第一个参数是数组的第一项，第二个参数是数组的第二项。")]),e._v(" "),a("p",[e._v("可以使用"),a("code",[e._v("reduce()")]),e._v("函数执行累加数组中所有数值的操作，比如：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("let values = [1, 2, 3, 4, 5];\nlet sum = values.reduce((prev, cur, index, array) => prev + cur);\n\nalert(sum);  // 15\n")])])]),a("p",[e._v("第一次执行归并函数时，"),a("code",[e._v("prev")]),e._v("是 1，"),a("code",[e._v("cur")]),e._v("是 2。第二次执行时，"),a("code",[e._v("prev")]),e._v("是 3（1 + 2），"),a("code",[e._v("cur")]),e._v("是 3（数组第三项）。如此递进，直到把所有项都遍历一次，最后返回归并结果。")]),e._v(" "),a("p",[a("code",[e._v("reduceRight()")]),e._v("方法与之类似，只是方向相反。来看下面的例子：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("let values = [1, 2, 3, 4, 5];\nlet sum = values.reduceRight(function(prev, cur, index, array){\n  return prev + cur;\n});\nalert(sum); // 15\n")])])]),a("p",[e._v("在这里，第一次调用归并函数时"),a("code",[e._v("prev")]),e._v("是 5，而"),a("code",[e._v("cur")]),e._v("是 4。当然，最终结果相同，因为归并操作都是简单的加法。")]),e._v(" "),a("p",[e._v("究竟是使用"),a("code",[e._v("reduce()")]),e._v("还是"),a("code",[e._v("reduceRight()")]),e._v("，只取决于遍历数组元素的方向。除此之外，这两个方法没什么区别。")]),e._v(" "),a("h2",{attrs:{id:"_6-3-定型数组"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-3-定型数组"}},[e._v("#")]),e._v(" 6.3 　定型数组")]),e._v(" "),a("p",[e._v("定型数组（typed array）是 ECMAScript 新增的结构，目的是提升向原生库传输数据的效率。实际上，JavaScript 并没有“TypedArray”类型，它所指的其实是一种特殊的包含数值类型的数组。为理解如何使用定型数组，有必要先了解一下它的用途。")]),e._v(" "),a("h3",{attrs:{id:"_6-3-1-历史"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-3-1-历史"}},[e._v("#")]),e._v(" 6.3.1 　历史")]),e._v(" "),a("p",[e._v("随着浏览器的流行，不难想象人们会满怀期待地通过它来运行复杂的 3D 应用程序。早在 2006 年，Mozilla、Opera 等浏览器提供商就实验性地在浏览器中增加了用于渲染复杂图形应用程序的编程平台，无须安装任何插件。其目标是开发一套 JavaScript API，从而充分利用 3D 图形 API 和 GPU 加速，以便在"),a("code",[e._v("<canvas>")]),e._v("元素上渲染复杂的图形。")]),e._v(" "),a("ol",[a("li",[a("p",[a("strong",[e._v("WebGL")])]),e._v(" "),a("p",[e._v("最后的 JavaScript API 是基于 OpenGL ES（OpenGL for Embedded Systems）2.0 规范的。OpenGL ES 是 OpenGL 专注于 2D 和 3D 计算机图形的子集。这个新 API 被命名为 WebGL（Web Grapics Library），于 2011 年发布 1.0 版。有了它，开发者就能够编写涉及复杂图形的应用程序，它会被兼容 WebGL 的浏览器原生解释执行。")]),e._v(" "),a("p",[e._v("在 WebGL 的早期版本中，因为 JavaScript 数组与原生数组之间不匹配，所以出现了性能问题。图形驱动程序 API 通常不需要以 JavaScript 默认双精度浮点格式传递给它们的数值，而这恰恰是 JavaScript 数组在内存中的格式。因此，每次 WebGL 与 JavaScript 运行时之间传递数组时，WebGL 绑定都需要在目标环境分配新数组，以其当前格式迭代数组，然后将数值转型为新数组中的适当格式，而这些要花费很多时间。")])])]),e._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[a("p",[a("strong",[e._v("定型数组")])]),e._v(" "),a("p",[e._v("这当然是难以接受的，Mozilla 为解决这个问题而实现了"),a("code",[e._v("CanvasFloatArray")]),e._v("。这是一个提供 JavaScript 接口的、C 语言风格的浮点值数组。JavaScript 运行时使用这个类型可以分配、读取和写入数组。这个数组可以直接传给底层图形驱动程序 API，也可以直接从底层获取到。最终，"),a("code",[e._v("CanvasFloatArray")]),e._v("变成了"),a("code",[e._v("Float32Array")]),e._v("，也就是今天定型数组中可用的第一个“类型”。")])])]),e._v(" "),a("h3",{attrs:{id:"_6-3-2-arraybuffer"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-3-2-arraybuffer"}},[e._v("#")]),e._v(" 6.3.2 　"),a("code",[e._v("ArrayBuffer")])]),e._v(" "),a("p",[a("code",[e._v("Float32Array")]),e._v("实际上是一种“视图”，可以允许 JavaScript 运行时访问一块名为"),a("code",[e._v("ArrayBuffer")]),e._v("的预分配内存。"),a("code",[e._v("ArrayBuffer")]),e._v("是所有定型数组及视图引用的基本单位。")]),e._v(" "),a("blockquote",[a("p",[a("strong",[e._v("注意")]),e._v(" "),a("code",[e._v("SharedArrayBuffer")]),e._v("是"),a("code",[e._v("ArrayBuffer")]),e._v("的一个变体，可以无须复制就在执行上下文间传递它。关于这种类型，请参考第 27 章。")])]),e._v(" "),a("p",[a("code",[e._v("ArrayBuffer()")]),e._v("是一个普通的 JavaScript 构造函数，可用于在内存中分配特定数量的字节空间。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("const buf = new ArrayBuffer(16);  // 在内存中分配16字节\nalert(buf.byteLength);            // 16\n")])])]),a("p",[a("code",[e._v("ArrayBuffer")]),e._v("一经创建就不能再调整大小。不过，可以使用"),a("code",[e._v("slice()")]),e._v("复制其全部或部分到一个新实例中：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("const buf1 = new ArrayBuffer(16);\nconst buf2 = buf1.slice(4, 12);\nalert(buf2.byteLength);  // 8\n")])])]),a("p",[a("code",[e._v("ArrayBuffer")]),e._v("某种程度上类似于 C++的"),a("code",[e._v("malloc()")]),e._v("，但也有几个明显的区别。")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("malloc()")]),e._v("在分配失败时会返回一个"),a("code",[e._v("null")]),e._v("指针。"),a("code",[e._v("ArrayBuffer")]),e._v("在分配失败时会抛出错误。")]),e._v(" "),a("li",[a("code",[e._v("malloc()")]),e._v("可以利用虚拟内存，因此最大可分配尺寸只受可寻址系统内存限制。"),a("code",[e._v("ArrayBuffer")]),e._v("分配的内存不能超过"),a("code",[e._v("Number.MAX_SAFE_INTEGER")]),e._v("（"),a("img",{attrs:{src:"https://private.codecogs.com/gif.latex?2%5E%7B53%7D-1",alt:"2^{53}-1"}}),e._v("）字节。")]),e._v(" "),a("li",[a("code",[e._v("malloc()")]),e._v("调用成功不会初始化实际的地址。声明"),a("code",[e._v("ArrayBuffer")]),e._v("则会将所有二进制位初始化为 0。")]),e._v(" "),a("li",[e._v("通过"),a("code",[e._v("malloc()")]),e._v("分配的堆内存除非调用"),a("code",[e._v("free()")]),e._v("或程序退出，否则系统不能再使用。而通过声明"),a("code",[e._v("ArrayBuffer")]),e._v("分配的堆内存可以被当成垃圾回收，不用手动释放。")])]),e._v(" "),a("p",[e._v("不能仅通过对"),a("code",[e._v("ArrayBuffer")]),e._v("的引用就读取或写入其内容。要读取或写入"),a("code",[e._v("ArrayBuffer")]),e._v("，就必须通过视图。视图有不同的类型，但引用的都是"),a("code",[e._v("ArrayBuffer")]),e._v("中存储的二进制数据。")]),e._v(" "),a("h3",{attrs:{id:"_6-3-3-dataview"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-3-3-dataview"}},[e._v("#")]),e._v(" 6.3.3 　"),a("code",[e._v("DataView")])]),e._v(" "),a("p",[e._v("第一种允许你读写"),a("code",[e._v("ArrayBuffer")]),e._v("的视图是"),a("code",[e._v("DataView")]),e._v("。这个视图专为文件 I/O 和网络 I/O 设计，其 API 支持对缓冲数据的高度控制，但相比于其他类型的视图性能也差一些。"),a("code",[e._v("DataView")]),e._v("对缓冲内容没有任何预设，也不能迭代。")]),e._v(" "),a("p",[e._v("必须在对已有的"),a("code",[e._v("ArrayBuffer")]),e._v("读取或写入时才能创建"),a("code",[e._v("DataView")]),e._v("实例。这个实例可以使用全部或部分"),a("code",[e._v("ArrayBuffer")]),e._v("，且维护着对该缓冲实例的引用，以及视图在缓冲中开始的位置。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("const buf = new ArrayBuffer(16);\n\n// DataView默认使用整个ArrayBuffer\nconst fullDataView = new DataView(buf);\nalert(fullDataView.byteOffset);      // 0\nalert(fullDataView.byteLength);      // 16\nalert(fullDataView.buffer === buf);  // true\n\n// 构造函数接收一个可选的字节偏移量和字节长度\n//   byteOffset=0表示视图从缓冲起点开始\n//   byteLength=8限制视图为前8个字节\nconst firstHalfDataView = new DataView(buf, 0, 8);\nalert(firstHalfDataView.byteOffset);      // 0\nalert(firstHalfDataView.byteLength);      // 8\nalert(firstHalfDataView.buffer === buf);  // true\n\n// 如果不指定，则DataView会使用剩余的缓冲\n//   byteOffset=8表示视图从缓冲的第9个字节开始\n//   byteLength未指定，默认为剩余缓冲\nconst secondHalfDataView = new DataView(buf, 8);\nalert(secondHalfDataView.byteOffset);      // 8\nalert(secondHalfDataView.byteLength);      // 8\nalert(secondHalfDataView.buffer === buf);  // true\n")])])]),a("p",[e._v("要通过"),a("code",[e._v("DataView")]),e._v("读取缓冲，还需要几个组件。")]),e._v(" "),a("p",[e._v("• 首先是要读或写的字节偏移量。可以看成"),a("code",[e._v("DataView")]),e._v("中的某种“地址”。")]),e._v(" "),a("p",[e._v("• "),a("code",[e._v("DataView")]),e._v("应该使用"),a("code",[e._v("ElementType")]),e._v("来实现 JavaScript 的"),a("code",[e._v("Number")]),e._v("类型到缓冲内二进制格式的转换。")]),e._v(" "),a("p",[e._v("• 最后是内存中值的字节序。默认为大端字节序。")]),e._v(" "),a("ol",[a("li",[a("p",[a("strong",[e._v("ElementType")])]),e._v(" "),a("p",[a("code",[e._v("DataView")]),e._v("对存储在缓冲内的数据类型没有预设。它暴露的 API 强制开发者在读、写时指定一个"),a("code",[e._v("ElementType")]),e._v("，然后"),a("code",[e._v("DataView")]),e._v("就会忠实地为读、写而完成相应的转换。")]),e._v(" "),a("p",[e._v("ECMAScript 6 支持 8 种不同的"),a("code",[e._v("ElementType")]),e._v("（见下表）。")]),e._v(" "),a("table",[a("thead",[a("tr",[a("th",{staticStyle:{"text-align":"left"}},[a("code",[e._v("ElementType")])]),e._v(" "),a("th",{staticStyle:{"text-align":"left"}},[e._v("字节")]),e._v(" "),a("th",{staticStyle:{"text-align":"left"}},[e._v("说明")]),e._v(" "),a("th",{staticStyle:{"text-align":"left"}},[e._v("等价的 C 类型")]),e._v(" "),a("th",{staticStyle:{"text-align":"left"}},[e._v("值的范围")])])]),e._v(" "),a("tbody",[a("tr",[a("td",{staticStyle:{"text-align":"left"}},[a("code",[e._v("Int8")])]),e._v(" "),a("td",{staticStyle:{"text-align":"left"}},[e._v("1")]),e._v(" "),a("td",{staticStyle:{"text-align":"left"}},[e._v("8 位有符号整数")]),e._v(" "),a("td",{staticStyle:{"text-align":"left"}},[a("code",[e._v("signed char")])]),e._v(" "),a("td",{staticStyle:{"text-align":"left"}},[e._v("-128~127")])]),e._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[a("code",[e._v("Uint8")])]),e._v(" "),a("td",{staticStyle:{"text-align":"left"}},[e._v("1")]),e._v(" "),a("td",{staticStyle:{"text-align":"left"}},[e._v("8 位无符号整数")]),e._v(" "),a("td",{staticStyle:{"text-align":"left"}},[a("code",[e._v("unsigned char")])]),e._v(" "),a("td",{staticStyle:{"text-align":"left"}},[e._v("0~255")])]),e._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[a("code",[e._v("Int16")])]),e._v(" "),a("td",{staticStyle:{"text-align":"left"}},[e._v("2")]),e._v(" "),a("td",{staticStyle:{"text-align":"left"}},[e._v("16 位有符号整数")]),e._v(" "),a("td",{staticStyle:{"text-align":"left"}},[a("code",[e._v("short")])]),e._v(" "),a("td",{staticStyle:{"text-align":"left"}},[e._v("-32 768~32 767")])]),e._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[a("code",[e._v("Uint16")])]),e._v(" "),a("td",{staticStyle:{"text-align":"left"}},[e._v("2")]),e._v(" "),a("td",{staticStyle:{"text-align":"left"}},[e._v("16 位无符号整数")]),e._v(" "),a("td",{staticStyle:{"text-align":"left"}},[a("code",[e._v("unsigned short")])]),e._v(" "),a("td",{staticStyle:{"text-align":"left"}},[e._v("0~65 535")])]),e._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[a("code",[e._v("Int32")])]),e._v(" "),a("td",{staticStyle:{"text-align":"left"}},[e._v("4")]),e._v(" "),a("td",{staticStyle:{"text-align":"left"}},[e._v("32 位有符号整数")]),e._v(" "),a("td",{staticStyle:{"text-align":"left"}},[a("code",[e._v("int")])]),e._v(" "),a("td",{staticStyle:{"text-align":"left"}},[e._v("-2 147 483 648~2 147 483 647")])]),e._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[a("code",[e._v("Uint32")])]),e._v(" "),a("td",{staticStyle:{"text-align":"left"}},[e._v("4")]),e._v(" "),a("td",{staticStyle:{"text-align":"left"}},[e._v("32 位无符号整数")]),e._v(" "),a("td",{staticStyle:{"text-align":"left"}},[a("code",[e._v("unsigned int")])]),e._v(" "),a("td",{staticStyle:{"text-align":"left"}},[e._v("0~4 294 967 295")])]),e._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[a("code",[e._v("Float32")])]),e._v(" "),a("td",{staticStyle:{"text-align":"left"}},[e._v("4")]),e._v(" "),a("td",{staticStyle:{"text-align":"left"}},[e._v("32 位 IEEE-754 浮点数")]),e._v(" "),a("td",{staticStyle:{"text-align":"left"}},[a("code",[e._v("float")])]),e._v(" "),a("td",{staticStyle:{"text-align":"left"}},[e._v("-3.4e+38~+3.4e+38")])]),e._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[a("code",[e._v("Float64")])]),e._v(" "),a("td",{staticStyle:{"text-align":"left"}},[e._v("8")]),e._v(" "),a("td",{staticStyle:{"text-align":"left"}},[e._v("64 位 IEEE-754 浮点数")]),e._v(" "),a("td",{staticStyle:{"text-align":"left"}},[a("code",[e._v("double")])]),e._v(" "),a("td",{staticStyle:{"text-align":"left"}},[e._v("-1.7e+308~+1.7e+308")])])])]),e._v(" "),a("p",[a("code",[e._v("DataView")]),e._v("为上表中的每种类型都暴露了"),a("code",[e._v("get")]),e._v("和"),a("code",[e._v("set")]),e._v("方法，这些方法使用"),a("code",[e._v("byteOffset")]),e._v("（字节偏移量）定位要读取或写入值的位置。类型是可以互换使用的，如下例所示：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// 在内存中分配两个字节并声明一个DataView\nconst buf = new ArrayBuffer(2);\nconst view = new DataView(buf);\n\n// 说明整个缓冲确实所有二进制位都是0\n// 检查第一个和第二个字符\nalert(view.getInt8(0));  // 0\nalert(view.getInt8(1));  // 0\n// 检查整个缓冲\nalert(view.getInt16(0)); // 0\n\n// 将整个缓冲都设置为1\n// 255的二进制表示是11111111（2^8 - 1）\nview.setUint8(0, 255);\n\n// DataView会自动将数据转换为特定的ElementType\n// 255的十六进制表示是0xFF\nview.setUint8(1, 0xFF);\n\n// 现在，缓冲里都是1了\n// 如果把它当成二补数的有符号整数，则应该是-1\nalert(view.getInt16(0)); // -1\n")])])])])]),e._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[a("p",[a("strong",[e._v("字节序")])]),e._v(" "),a("p",[e._v("前面例子中的缓冲有意回避了字节序的问题。“字节序”指的是计算系统维护的一种字节顺序的约定。"),a("code",[e._v("DataView")]),e._v("只支持两种约定：大端字节序和小端字节序。大端字节序也称为“网络字节序”，意思是最高有效位保存在第一个字节，而最低有效位保存在最后一个字节。小端字节序正好相反，即最低有效位保存在第一个字节，最高有效位保存在最后一个字节。")]),e._v(" "),a("p",[e._v("JavaScript 运行时所在系统的原生字节序决定了如何读取或写入字节，但"),a("code",[e._v("DataView")]),e._v("并不遵守这个约定。对一段内存而言，"),a("code",[e._v("DataView")]),e._v("是一个中立接口，它会遵循你指定的字节序。"),a("code",[e._v("DataView")]),e._v("的所有 API 方法都以大端字节序作为默认值，但接收一个可选的布尔值参数，设置为"),a("code",[e._v("true")]),e._v("即可启用小端字节序。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// 在内存中分配两个字节并声明一个DataView\nconst buf = new ArrayBuffer(2);\nconst view = new DataView(buf);\n\n// 填充缓冲，让第一位和最后一位都是1\nview.setUint8(0, 0x80); // 设置最左边的位等于1\nview.setUint8(1, 0x01); // 设置最右边的位等于1\n\n// 缓冲内容（为方便阅读，人为加了空格）\n// 0x8  0x0  0x0  0x1\n// 1000 0000 0000 0001\n\n// 按大端字节序读取Uint16\n// 0x80是高字节，0x01是低字节\n// 0x8001 = 2^15 + 2^0 = 32768 + 1 = 32769\nalert(view.getUint16(0)); // 32769\n\n// 按小端字节序读取Uint16\n// 0x01是高字节，0x80是低字节\n// 0x0180 = 2^8 + 2^7 = 256 + 128 = 384\nalert(view.getUint16(0, true)); // 384\n\n// 按大端字节序写入Uint16\nview.setUint16(0, 0x0004);\n\n// 缓冲内容（为方便阅读，人为加了空格）\n// 0x0  0x0  0x0  0x4\n// 0000 0000 0000 0100\n\nalert(view.getUint8(0)); // 0\nalert(view.getUint8(1)); // 4\n\n// 按小端字节序写入Uint16\nview.setUint16(0, 0x0002, true);\n\n// 缓冲内容（为方便阅读，人为加了空格）\n// 0x0  0x2  0x0  0x0\n// 0000 0010 0000 0000\n\nalert(view.getUint8(0)); // 2\nalert(view.getUint8(1)); // 0\n")])])])])]),e._v(" "),a("ol",{attrs:{start:"3"}},[a("li",[a("p",[a("strong",[e._v("边界情形")])]),e._v(" "),a("p",[a("code",[e._v("DataView")]),e._v("完成读、写操作的前提是必须有充足的缓冲区，否则就会抛出"),a("code",[e._v("RangeError")]),e._v("：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("const buf = new ArrayBuffer(6);\nconst view = new DataView(buf);\n\n// 尝试读取部分超出缓冲范围的值\nview.getInt32(4);\n// RangeError\n\n// 尝试读取超出缓冲范围的值\nview.getInt32(8);\n// RangeError\n\n// 尝试读取超出缓冲范围的值\nview.getInt32(-1);\n// RangeError\n\n// 尝试写入超出缓冲范围的值\nview.setInt32(4, 123);\n// RangeError\n")])])]),a("p",[a("code",[e._v("DataView")]),e._v("在写入缓冲里会尽最大努力把一个值转换为适当的类型，后备为 0。如果无法转换，则抛出错误：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("const buf = new ArrayBuffer(1);\nconst view = new DataView(buf);\n\nview.setInt8(0, 1.5);\nalert(view.getInt8(0)); // 1\n\nview.setInt8(0, [4]);\nalert(view.getInt8(0)); // 4\n\nview.setInt8(0, 'f');\nalert(view.getInt8(0)); // 0\n\nview.setInt8(0, Symbol());\n// TypeError\n")])])])])]),e._v(" "),a("h3",{attrs:{id:"_6-3-4-定型数组"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-3-4-定型数组"}},[e._v("#")]),e._v(" 6.3.4 　定型数组")]),e._v(" "),a("p",[e._v("定型数组是另一种形式的"),a("code",[e._v("ArrayBuffer")]),e._v("视图。虽然概念上与"),a("code",[e._v("DataView")]),e._v("接近，但定型数组的区别在于，它特定于一种"),a("code",[e._v("ElementType")]),e._v("且遵循系统原生的字节序。相应地，定型数组提供了适用面更广的 API 和更高的性能。设计定型数组的目的就是提高与 WebGL 等原生库交换二进制数据的效率。由于定型数组的二进制表示对操作系统而言是一种容易使用的格式，JavaScript 引擎可以重度优化算术运算、按位运算和其他对定型数组的常见操作，因此使用它们速度极快。")]),e._v(" "),a("p",[e._v("创建定型数组的方式包括读取已有的缓冲、使用自有缓冲、填充可迭代结构，以及填充基于任意类型的定型数组。另外，通过"),a("code",[e._v("<ElementType>.from()")]),e._v("和"),a("code",[e._v("<ElementType>.of()")]),e._v("也可以创建定型数组：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// 创建一个12字节的缓冲\nconst buf = new ArrayBuffer(12);\n// 创建一个引用该缓冲的Int32Array\nconst ints = new Int32Array(buf);\n// 这个定型数组知道自己的每个元素需要4字节\n// 因此长度为3\nalert(ints.length); // 3\n\n// 创建一个长度为6的Int32Array\nconst ints2 = new Int32Array(6);\n// 每个数值使用4字节，因此ArrayBuffer是24字节\nalert(ints2.length);             // 6\n// 类似DataView，定型数组也有一个指向关联缓冲的引用\nalert(ints2.buffer.byteLength);  // 24\n\n// 创建一个包含[2, 4, 6, 8]的Int32Array\nconst ints3 = new Int32Array([2, 4, 6, 8]);\nalert(ints3.length);            // 4\nalert(ints3.buffer.byteLength); // 16\nalert(ints3[2]);                // 6\n\n// 通过复制ints3的值创建一个Int16Array\nconst ints4 = new Int16Array(ints3);\n// 这个新类型数组会分配自己的缓冲\n// 对应索引的每个值会相应地转换为新格式\nalert(ints4.length);            // 4\nalert(ints4.buffer.byteLength); // 8\nalert(ints4[2]);                // 6\n\n// 基于普通数组来创建一个Int16Array\nconst ints5 = Int16Array.from([3, 5, 7, 9]);\nalert(ints5.length);            // 4\nalert(ints5.buffer.byteLength); // 8\nalert(ints5[2]);                // 7\n\n// 基于传入的参数创建一个Float32Array\nconst floats = Float32Array.of(3.14, 2.718, 1.618);\nalert(floats.length);            // 3\nalert(floats.buffer.byteLength); // 12\nalert(floats[2]);                // 1.6180000305175781\n")])])]),a("p",[e._v("定型数组的构造函数和实例都有一个"),a("code",[e._v("BYTES_PER_ELEMENT")]),e._v("属性，返回该类型数组中每个元素的大小：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("alert(Int16Array.BYTES_PER_ELEMENT);  // 2\nalert(Int32Array.BYTES_PER_ELEMENT);  // 4\n\nconst ints = new Int32Array(1),\n      floats = new Float64Array(1);\n\nalert(ints.BYTES_PER_ELEMENT);        // 4\nalert(floats.BYTES_PER_ELEMENT);      // 8\n")])])]),a("p",[e._v("如果定型数组没有用任何值初始化，则其关联的缓冲会以 0 填充：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("const ints = new Int32Array(4);\nalert(ints[0]);  // 0\nalert(ints[1]);  // 0\nalert(ints[2]);  // 0\nalert(ints[3]);  // 0\n")])])]),a("ol",[a("li",[a("p",[a("strong",[e._v("定型数组行为")])]),e._v(" "),a("p",[e._v("从很多方面看，定型数组与普通数组都很相似。定型数组支持如下操作符、方法和属性：")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("[]")])]),e._v(" "),a("li",[a("code",[e._v("copyWithin()")])]),e._v(" "),a("li",[a("code",[e._v("entries()")])]),e._v(" "),a("li",[a("code",[e._v("every()")])]),e._v(" "),a("li",[a("code",[e._v("fill()")])]),e._v(" "),a("li",[a("code",[e._v("filter()")])]),e._v(" "),a("li",[a("code",[e._v("find()")])]),e._v(" "),a("li",[a("code",[e._v("findIndex()")])]),e._v(" "),a("li",[a("code",[e._v("forEach()")])]),e._v(" "),a("li",[a("code",[e._v("indexOf()")])]),e._v(" "),a("li",[a("code",[e._v("join()")])]),e._v(" "),a("li",[a("code",[e._v("keys()")])]),e._v(" "),a("li",[a("code",[e._v("lastIndexOf()")])]),e._v(" "),a("li",[a("code",[e._v("length")])]),e._v(" "),a("li",[a("code",[e._v("map()")])]),e._v(" "),a("li",[a("code",[e._v("reduce()")])]),e._v(" "),a("li",[a("code",[e._v("reduceRight()")])]),e._v(" "),a("li",[a("code",[e._v("reverse()")])]),e._v(" "),a("li",[a("code",[e._v("slice()")])]),e._v(" "),a("li",[a("code",[e._v("some()")])]),e._v(" "),a("li",[a("code",[e._v("sort()")])]),e._v(" "),a("li",[a("code",[e._v("toLocaleString()")])]),e._v(" "),a("li",[a("code",[e._v("toString()")])]),e._v(" "),a("li",[a("code",[e._v("values()")])])]),e._v(" "),a("p",[e._v("其中，返回新数组的方法也会返回包含同样元素类型（element type）的新定型数组：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("const ints = new Int16Array([1, 2, 3]);\nconst doubleints = ints.map(x => 2*x);\nalert(doubleints instanceof Int16Array); // true\n")])])]),a("p",[e._v("定型数组有一个"),a("code",[e._v("Symbol.iterator")]),e._v("符号属性，因此可以通过"),a("code",[e._v("for..of")]),e._v("循环和扩展操作符来操作：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("const ints = new Int16Array([1, 2, 3]);\nfor (const int of ints) {\n  alert(int);\n}\n// 1\n// 2\n// 3\n\nalert(Math.max(...ints)); // 3\n")])])])])]),e._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[a("p",[a("strong",[e._v("合并、复制和修改定型数组")])]),e._v(" "),a("p",[e._v("定型数组同样使用数组缓冲来存储数据，而数组缓冲无法调整大小。因此，下列方法不适用于定型数组：")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("concat()")])]),e._v(" "),a("li",[a("code",[e._v("pop()")])]),e._v(" "),a("li",[a("code",[e._v("push()")])]),e._v(" "),a("li",[a("code",[e._v("shift()")])]),e._v(" "),a("li",[a("code",[e._v("splice()")])]),e._v(" "),a("li",[a("code",[e._v("unshift()")])])]),e._v(" "),a("p",[e._v("不过，定型数组也提供了两个新方法，可以快速向外或向内复制数据："),a("code",[e._v("set()")]),e._v("和"),a("code",[e._v("subarray()")]),e._v("。")]),e._v(" "),a("p",[a("code",[e._v("set()")]),e._v("从提供的数组或定型数组中把值复制到当前定型数组中指定的索引位置：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// 创建长度为8的int16数组\nconst container = new Int16Array(8);\n// 把定型数组复制为前4个值\n// 偏移量默认为索引0\ncontainer.set(Int8Array.of(1, 2, 3, 4));\nconsole.log(container);  // [1,2,3,4,0,0,0,0]\n// 把普通数组复制为后4个值\n// 偏移量4表示从索引4开始插入\ncontainer.set([5,6,7,8], 4);\nconsole.log(container);  // [1,2,3,4,5,6,7,8]\n\n// 溢出会抛出错误\ncontainer.set([5,6,7,8], 7);\n// RangeError\n")])])]),a("p",[a("code",[e._v("subarray()")]),e._v("执行与"),a("code",[e._v("set()")]),e._v("相反的操作，它会基于从原始定型数组中复制的值返回一个新定型数组。复制值时的开始索引和结束索引是可选的：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("const source = Int16Array.of(2, 4, 6, 8);\n\n// 把整个数组复制为一个同类型的新数组\nconst fullCopy = source.subarray();\nconsole.log(fullCopy);  // [2, 4, 6, 8]\n\n// 从索引2开始复制数组\nconst halfCopy = source.subarray(2);\nconsole.log(halfCopy);  // [6, 8]\n\n// 从索引1开始复制到索引3\nconst partialCopy = source.subarray(1, 3);\nconsole.log(partialCopy);  // [4, 6]\n")])])]),a("p",[e._v("定型数组没有原生的拼接能力，但使用定型数组 API 提供的很多工具可以手动构建：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// 第一个参数是应该返回的数组类型\n// 其余参数是应该拼接在一起的定型数组\nfunction typedArrayConcat(typedArrayConstructor, ...typedArrays) {\n  // 计算所有数组中包含的元素总数\n  const numElements = typedArrays.reduce((x,y) => (x.length || x) + y.length);\n\n  // 按照提供的类型创建一个数组，为所有元素留出空间\n  const resultArray = new typedArrayConstructor(numElements);\n\n  // 依次转移数组\n  let currentOffset = 0;\n  typedArrays.map(x => {\n    resultArray.set(x, currentOffset);\n    currentOffset += x.length;\n  });\n\n  return resultArray;\n}\n\nconst concatArray = typedArrayConcat(Int32Array,\n                                     Int8Array.of(1, 2, 3),\n                                     Int16Array.of(4, 5, 6),\n                                     Float32Array.of(7, 8, 9));\nconsole.log(concatArray);  // [1, 2, 3, 4, 5, 6, 7, 8, 9]\nconsole.log(concatArray instanceof Int32Array); // true\n")])])])])]),e._v(" "),a("ol",{attrs:{start:"3"}},[a("li",[a("p",[a("strong",[e._v("下溢和上溢")])]),e._v(" "),a("p",[e._v("定型数组中值的下溢和上溢不会影响到其他索引，但仍然需要考虑数组的元素应该是什么类型。定型数组对于可以存储的每个索引只接受一个相关位，而不考虑它们对实际数值的影响。以下代码演示了如何处理下溢和上溢：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// 长度为2的有符号整数数组\n// 每个索引保存一个二补数形式的有符号整数\n// 范围是-128（-1 * 2^7）~127（2^7 - 1）\nconst ints = new Int8Array(2);\n\n// 长度为2的无符号整数数组\n// 每个索引保存一个无符号整数\n// 范围是0~255（2^7 - 1）\nconst unsignedInts = new Uint8Array(2);\n\n// 上溢的位不会影响相邻索引\n// 索引只取最低有效位上的8位\nunsignedInts[1] = 256;      // 0x100\nconsole.log(unsignedInts);  // [0, 0]\nunsignedInts[1] = 511;      // 0x1FF\nconsole.log(unsignedInts);  // [0, 255]\n\n// 下溢的位会被转换为其无符号的等价值\n// 0xFF是以二补数形式表示的-1（截取到8位）,\n// 但255是一个无符号整数\nunsignedInts[1] = -1        // 0xFF (truncated to 8 bits)\nconsole.log(unsignedInts);  // [0, 255]\n\n// 上溢自动变成二补数形式\n// 0x80是无符号整数的128，是二补数形式的-128\nints[1] = 128;        // 0x80\nconsole.log(ints);    // [0, -128]\n\n// 下溢自动变成二补数形式\n// 0xFF是无符号整数的255，是二补数形式的-1\nints[1] = 255;        // 0xFF\nconsole.log(ints);    // [0, -1]\n")])])]),a("p",[e._v("除了 8 种元素类型，还有一种“夹板”数组类型："),a("code",[e._v("Uint8ClampedArray")]),e._v("，不允许任何方向溢出。超出最大值 255 的值会被向下舍入为 255，而小于最小值 0 的值会被向上舍入为 0。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("const clampedInts = new Uint8ClampedArray([-1, 0, 255, 256]);\nconsole.log(clampedInts); // [0, 0, 255, 255]\n")])])]),a("p",[e._v("按照 JavaScript 之父 Brendan Eich 的说法：“"),a("code",[e._v("Uint8ClampedArray")]),e._v("完全是 HTML5"),a("code",[e._v("canvas")]),e._v("元素的历史留存。除非真的做跟"),a("code",[e._v("canvas")]),e._v("相关的开发，否则不要使用它。”")])])]),e._v(" "),a("h2",{attrs:{id:"_6-4-map"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-4-map"}},[e._v("#")]),e._v(" 6.4 　"),a("code",[e._v("Map")])]),e._v(" "),a("p",[e._v("ECMAScript 6 以前，在 JavaScript 中实现“键/值”式存储可以使用"),a("code",[e._v("Object")]),e._v("来方便高效地完成，也就是使用对象属性作为键，再使用属性来引用值。但这种实现并非没有问题，为此 TC39 委员会专门为“键/值”存储定义了一个规范。")]),e._v(" "),a("p",[e._v("作为 ECMAScript 6 的新增特性，"),a("code",[e._v("Map")]),e._v("是一种新的集合类型，为这门语言带来了真正的键/值存储机制。"),a("code",[e._v("Map")]),e._v("的大多数特性都可以通过"),a("code",[e._v("Object")]),e._v("类型实现，但二者之间还是存在一些细微的差异。具体实践中使用哪一个，还是值得细细甄别。")]),e._v(" "),a("h3",{attrs:{id:"_6-4-1-基本-api"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-4-1-基本-api"}},[e._v("#")]),e._v(" 6.4.1 　基本 API")]),e._v(" "),a("p",[e._v("使用"),a("code",[e._v("new")]),e._v("关键字和"),a("code",[e._v("Map")]),e._v("构造函数可以创建一个空映射：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("const m = new Map();\n")])])]),a("p",[e._v("如果想在创建的同时初始化实例，可以给"),a("code",[e._v("Map")]),e._v("构造函数传入一个可迭代对象，需要包含键/值对数组。可迭代对象中的每个键/值对都会按照迭代顺序插入到新映射实例中：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('// 使用嵌套数组初始化映射\nconst m1 = new Map([\n  ["key1", "val1"],\n  ["key2", "val2"],\n  ["key3", "val3"]\n]);\nalert(m1.size); // 3\n\n// 使用自定义迭代器初始化映射\nconst m2 = new Map({\n  [Symbol.iterator]: function*() {\n    yield ["key1", "val1"];\n    yield ["key2", "val2"];\n    yield ["key3", "val3"];\n  }\n});\nalert(m2.size); // 3\n\n// 映射期待的键/值对，无论是否提供\nconst m3 = new Map([[]]);\nalert(m3.has(undefined));  // true\nalert(m3.get(undefined));  // undefined\n')])])]),a("p",[e._v("初始化之后，可以使用"),a("code",[e._v("set()")]),e._v("方法再添加键/值对。另外，可以使用"),a("code",[e._v("get()")]),e._v("和"),a("code",[e._v("has()")]),e._v("进行查询，可以通过"),a("code",[e._v("size")]),e._v("属性获取映射中的键/值对的数量，还可以使用"),a("code",[e._v("delete()")]),e._v("和"),a("code",[e._v("clear()")]),e._v("删除值。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('const m = new Map();\n\nalert(m.has("firstName"));  // false\nalert(m.get("firstName"));  // undefined\nalert(m.size);              // 0\n\nm.set("firstName", "Matt")\n .set("lastName", "Frisbie");\n\nalert(m.has("firstName")); // true\nalert(m.get("firstName")); // Matt\nalert(m.size);             // 2\n\nm.delete("firstName");     // 只删除这一个键/值对\n\nalert(m.has("firstName")); // false\nalert(m.has("lastName"));  // true\nalert(m.size);             // 1\n\nm.clear(); // 清除这个映射实例中的所有键/值对\n\nalert(m.has("firstName")); // false\nalert(m.has("lastName"));  // false\nalert(m.size);             // 0\n')])])]),a("p",[a("code",[e._v("set()")]),e._v("方法返回映射实例，因此可以把多个操作连缀起来，包括初始化声明：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('const m = new Map().set("key1", "val1");\n\nm.set("key2", "val2")\n .set("key3", "val3");\n\nalert(m.size); // 3\n')])])]),a("p",[e._v("与"),a("code",[e._v("Object")]),e._v("只能使用数值、字符串或符号作为键不同，"),a("code",[e._v("Map")]),e._v("可以使用任何 JavaScript 数据类型作为键。"),a("code",[e._v("Map")]),e._v("内部使用 SameValueZero 比较操作（ECMAScript 规范内部定义，语言中不能使用），基本上相当于使用严格对象相等的标准来检查键的匹配性。与"),a("code",[e._v("Object")]),e._v("类似，映射的值是没有限制的。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('const m = new Map();\n\nconst functionKey = function() {};\nconst symbolKey = Symbol();\nconst objectKey = new Object();\n\nm.set(functionKey, "functionValue");\nm.set(symbolKey, "symbolValue");\nm.set(objectKey, "objectValue");\n\nalert(m.get(functionKey));  // functionValue\nalert(m.get(symbolKey));    // symbolValue\nalert(m.get(objectKey));    // objectValue\n\n// SameValueZero比较意味着独立实例不冲突\nalert(m.get(function() {})); // undefined\n')])])]),a("p",[e._v("与严格相等一样，在映射中用作键和值的对象及其他“集合”类型，在自己的内容或属性被修改时仍然保持不变：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('const m = new Map();\n\nconst objKey = {},\n      objVal = {},\n      arrKey = [],\n      arrVal = [];\n\nm.set(objKey, objVal);\nm.set(arrKey, arrVal);\n\nobjKey.foo = "foo";\nobjVal.bar = "bar";\narrKey.push("foo");\narrVal.push("bar");\n\nconsole.log(m.get(objKey)); // {bar: "bar"}\nconsole.log(m.get(arrKey)); // ["bar"]\n')])])]),a("p",[e._v("SameValueZero 比较也可能导致意想不到的冲突：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('const m = new Map();\n\nconst a = 0/"", // NaN\n      b = 0/"", // NaN\n      pz = +0,\n      nz = -0;\n\nalert(a === b);   // false\nalert(pz === nz); // true\n\nm.set(a, "foo");\nm.set(pz, "bar");\n\nalert(m.get(b));  // foo\nalert(m.get(nz)); // bar\n')])])]),a("blockquote",[a("p",[a("strong",[e._v("注意")]),e._v("　 SameValueZero 是 ECMAScript 规范新增的相等性比较算法。关于 ECMAScript 的相等性比较，可以参考 MDN 文档中的文章“Equality Comparisons and Sameness”。")])]),e._v(" "),a("h3",{attrs:{id:"_6-4-2-顺序与迭代"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-4-2-顺序与迭代"}},[e._v("#")]),e._v(" 6.4.2 　顺序与迭代")]),e._v(" "),a("p",[e._v("与"),a("code",[e._v("Object")]),e._v("类型的一个主要差异是，"),a("code",[e._v("Map")]),e._v("实例会维护键值对的插入顺序，因此可以根据插入顺序执行迭代操作。")]),e._v(" "),a("p",[e._v("映射实例可以提供一个迭代器（"),a("code",[e._v("Iterator")]),e._v("），能以插入顺序生成"),a("code",[e._v("[key, value]")]),e._v("形式的数组。可以通过"),a("code",[e._v("entries()")]),e._v("方法（或者"),a("code",[e._v("Symbol.iterator")]),e._v("属性，它引用"),a("code",[e._v("entries()")]),e._v("）取得这个迭代器：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('const m = new Map([\n  ["key1", "val1"],\n  ["key2", "val2"],\n  ["key3", "val3"]\n]);\n\nalert(m.entries === m[Symbol.iterator]); // true\n\nfor (let pair of m.entries()) {\n  alert(pair);\n}\n// [key1,val1]\n// [key2,val2]\n// [key3,val3]\n\nfor (let pair of m[Symbol.iterator]()) {\n  alert(pair);\n}\n// [key1,val1]\n// [key2,val2]\n// [key3,val3]\n')])])]),a("p",[e._v("因为"),a("code",[e._v("entries()")]),e._v("是默认迭代器，所以可以直接对映射实例使用扩展操作，把映射转换为数组：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('const m = new Map([\n  ["key1", "val1"],\n  ["key2", "val2"],\n  ["key3", "val3"]\n]);\n\nconsole.log([...m]); // [[key1,val1],[key2,val2],[key3,val3]]\n')])])]),a("p",[e._v("如果不使用迭代器，而是使用回调方式，则可以调用映射的"),a("code",[e._v("forEach()")]),e._v("方法并传入回调，依次迭代每个键/值对。传入的回调接收可选的第二个参数，这个参数用于重写回调内部"),a("code",[e._v("this")]),e._v("的值：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('const m = new Map([\n  ["key1", "val1"],\n  ["key2", "val2"],\n  ["key3", "val3"]\n]);\n\nm.forEach((val, key) => alert(`${key} -> ${val}`));\n// key1 -> val1\n// key2 -> val2\n// key3 -> val3\n')])])]),a("p",[a("code",[e._v("keys()")]),e._v("和"),a("code",[e._v("values()")]),e._v("分别返回以插入顺序生成键和值的迭代器：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('const m = new Map([\n  ["key1", "val1"],\n  ["key2", "val2"],\n  ["key3", "val3"]\n]);\n\nfor (let key of m.keys()) {\n  alert(key);\n}\n// key1\n// key2\n// key3\n\nfor (let key of m.values()) {\n  alert(key);\n}\n// value1\n// value2\n// value3\n')])])]),a("p",[e._v("键和值在迭代器遍历时是可以修改的，但映射内部的引用则无法修改。当然，这并不妨碍修改作为键或值的对象内部的属性，因为这样并不影响它们在映射实例中的身份：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('const m1 = new Map([\n  ["key1", "val1"]\n]);\n\n// 作为键的字符串原始值是不能修改的\nfor (let key of m1.keys()) {\n  key = "newKey";\n  alert(key);             // newKey\n  alert(m1.get("key1"));  // val1\n}\n\nconst keyObj = {id: 1};\n\nconst m = new Map([\n  [keyObj, "val1"]\n]);\n\n// 修改了作为键的对象的属性，但对象在映射内部仍然引用相同的值\nfor (let key of m.keys()) {\n  key.id = "newKey";\n  alert(key);            // {id: "newKey"}\n  alert(m.get(keyObj));  // val1\n}\nalert(keyObj);           // {id: "newKey"}\n')])])]),a("h3",{attrs:{id:"_6-4-3-选择object还是map"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-4-3-选择object还是map"}},[e._v("#")]),e._v(" 6.4.3 　选择"),a("code",[e._v("Object")]),e._v("还是"),a("code",[e._v("Map")])]),e._v(" "),a("p",[e._v("对于多数 Web 开发任务来说，选择"),a("code",[e._v("Object")]),e._v("还是"),a("code",[e._v("Map")]),e._v("只是个人偏好问题，影响不大。不过，对于在乎内存和性能的开发者来说，对象和映射之间确实存在显著的差别。")]),e._v(" "),a("ol",[a("li",[a("p",[a("strong",[e._v("内存占用")])]),e._v(" "),a("p",[a("code",[e._v("Object")]),e._v("和"),a("code",[e._v("Map")]),e._v("的工程级实现在不同浏览器间存在明显差异，但存储单个键/值对所占用的内存数量都会随键的数量线性增加。批量添加或删除键/值对则取决于各浏览器对该类型内存分配的工程实现。不同浏览器的情况不同，但给定固定大小的内存，"),a("code",[e._v("Map")]),e._v("大约可以比"),a("code",[e._v("Object")]),e._v("多存储 50%的键/值对。")])]),e._v(" "),a("li",[a("p",[a("strong",[e._v("插入性能")])]),e._v(" "),a("p",[e._v("向"),a("code",[e._v("Object")]),e._v("和"),a("code",[e._v("Map")]),e._v("中插入新键/值对的消耗大致相当，不过插入"),a("code",[e._v("Map")]),e._v("在所有浏览器中一般会稍微快一点儿。对这两个类型来说，插入速度并不会随着键/值对数量而线性增加。如果代码涉及大量插入操作，那么显然"),a("code",[e._v("Map")]),e._v("的性能更佳。")])]),e._v(" "),a("li",[a("p",[a("strong",[e._v("查找速度")])]),e._v(" "),a("p",[e._v("与插入不同，从大型"),a("code",[e._v("Object")]),e._v("和"),a("code",[e._v("Map")]),e._v("中查找键/值对的性能差异极小，但如果只包含少量键/值对，则"),a("code",[e._v("Object")]),e._v("有时候速度更快。在把"),a("code",[e._v("Object")]),e._v("当成数组使用的情况下（比如使用连续整数作为属性），浏览器引擎可以进行优化，在内存中使用更高效的布局。这对"),a("code",[e._v("Map")]),e._v("来说是不可能的。对这两个类型而言，查找速度不会随着键/值对数量增加而线性增加。如果代码涉及大量查找操作，那么某些情况下可能选择"),a("code",[e._v("Object")]),e._v("更好一些。")])]),e._v(" "),a("li",[a("p",[a("strong",[e._v("删除性能")])]),e._v(" "),a("p",[e._v("使用"),a("code",[e._v("delete")]),e._v("删除"),a("code",[e._v("Object")]),e._v("属性的性能一直以来饱受诟病，目前在很多浏览器中仍然如此。为此，出现了一些伪删除对象属性的操作，包括把属性值设置为"),a("code",[e._v("undefined")]),e._v("或"),a("code",[e._v("null")]),e._v("。但很多时候，这都是一种讨厌的或不适宜的折中。而对大多数浏览器引擎来说，"),a("code",[e._v("Map")]),e._v("的"),a("code",[e._v("delete()")]),e._v("操作都比插入和查找更快。如果代码涉及大量删除操作，那么毫无疑问应该选择"),a("code",[e._v("Map")]),e._v("。")])])]),e._v(" "),a("h2",{attrs:{id:"_6-5-weakmap"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-5-weakmap"}},[e._v("#")]),e._v(" 6.5 　"),a("code",[e._v("WeakMap")])]),e._v(" "),a("p",[e._v("ECMAScript 6 新增的“弱映射”（"),a("code",[e._v("WeakMap")]),e._v("）是一种新的集合类型，为这门语言带来了增强的键/值对存储机制。"),a("code",[e._v("WeakMap")]),e._v("是"),a("code",[e._v("Map")]),e._v("的“兄弟”类型，其 API 也是"),a("code",[e._v("Map")]),e._v("的子集。"),a("code",[e._v("WeakMap")]),e._v("中的“weak”（弱），描述的是 JavaScript 垃圾回收程序对待“弱映射”中键的方式。")]),e._v(" "),a("h3",{attrs:{id:"_6-5-1-基本-api"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-5-1-基本-api"}},[e._v("#")]),e._v(" 6.5.1 　基本 API")]),e._v(" "),a("p",[e._v("可以使用"),a("code",[e._v("new")]),e._v("关键字实例化一个空的"),a("code",[e._v("WeakMap")]),e._v("：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("const wm = new WeakMap();\n")])])]),a("p",[e._v("弱映射中的键只能是"),a("code",[e._v("Object")]),e._v("或者继承自"),a("code",[e._v("Object")]),e._v("的类型，尝试使用非对象设置键会抛出"),a("code",[e._v("TypeError")]),e._v("。值的类型没有限制。")]),e._v(" "),a("p",[e._v("如果想在初始化时填充弱映射，则构造函数可以接收一个可迭代对象，其中需要包含键/值对数组。可迭代对象中的每个键/值都会按照迭代顺序插入新实例中：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('const key1 = {id: 1},\n      key2 = {id: 2},\n      key3 = {id: 3};\n// 使用嵌套数组初始化弱映射\nconst wm1 = new WeakMap([\n  [key1, "val1"],\n  [key2, "val2"],\n  [key3, "val3"]\n]);\nalert(wm.get(key1)); // val2\nalert(wm.get(key2)); // val2\nalert(wm.get(key3)); // val3\n\n// 初始化是全有或全无的操作\n// 只要有一个键无效就会抛出错误，导致整个初始化失败\nconst wm2 = new WeakMap([\n  [key1, "val1"],\n  ["BADKEY", "val2"],\n  [key3, "val3"]\n]);\n// TypeError: Invalid value used as WeakMap key\ntypeof wm2;\n// ReferenceError: wm2 is not defined\n\n// 原始值可以先包装成对象再用作键\nconst stringKey = new String("key1");\nconst wm3 = new WeakMap([\n  stringKey, "val1"\n]);\nalert(wm3.get(stringKey)); // "val1"\n')])])]),a("p",[e._v("初始化之后可以使用"),a("code",[e._v("set()")]),e._v("再添加键/值对，可以使用"),a("code",[e._v("get()")]),e._v("和"),a("code",[e._v("has()")]),e._v("查询，还可以使用"),a("code",[e._v("delete()")]),e._v("删除：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('const wm = new WeakMap();\n\nconst key1 = {id: 1},\n      key2 = {id: 2};\n\nalert(wm.has(key1)); // false\nalert(wm.get(key1)); // undefined\n\nwm.set(key1, "Matt")\n  .set(key2, "Frisbie");\n\nalert(wm.has(key1)); // true\nalert(wm.get(key1)); // Matt\n\nwm.delete(key1);     // 只删除这一个键/值对\n\nalert(wm.has(key1)); // false\nalert(wm.has(key2)); // true\n')])])]),a("p",[a("code",[e._v("set()")]),e._v("方法返回弱映射实例，因此可以把多个操作连缀起来，包括初始化声明：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('const key1 = {id: 1},\n      key2 = {id: 2},\n      key3 = {id: 3};\n\nconst wm = new WeakMap().set(key1, "val1");\n\nwm.set(key2, "val2")\n  .set(key3, "val3");\n\nalert(wm.get(key1)); // val1\nalert(wm.get(key2)); // val2\nalert(wm.get(key3)); // val3\n')])])]),a("h3",{attrs:{id:"_6-5-2-弱键"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-5-2-弱键"}},[e._v("#")]),e._v(" 6.5.2 　弱键")]),e._v(" "),a("p",[a("code",[e._v("WeakMap")]),e._v("中“weak”表示弱映射的键是“弱弱地拿着”的。意思就是，这些键不属于正式的引用，不会阻止垃圾回收。但要注意的是，弱映射中值的引用可"),a("strong",[e._v("不是")]),e._v("“弱弱地拿着”的。只要键存在，键/值对就会存在于映射中，并被当作对值的引用，因此就不会被当作垃圾回收。")]),e._v(" "),a("p",[e._v("来看下面的例子：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('const wm = new WeakMap();\n\nwm.set({}, "val");\n')])])]),a("p",[a("code",[e._v("set()")]),e._v("方法初始化了一个新对象并将它用作一个字符串的键。因为没有指向这个对象的其他引用，所以当这行代码执行完成后，这个对象键就会被当作垃圾回收。然后，这个键/值对就从弱映射中消失了，使其成为一个空映射。在这个例子中，因为值也没有被引用，所以这对键/值被破坏以后，值本身也会成为垃圾回收的目标。")]),e._v(" "),a("p",[e._v("再看一个稍微不同的例子：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('const wm = new WeakMap();\n\nconst container = {\n  key: {}\n};\n\nwm.set(container.key, "val");\n\nfunction removeReference() {\n  container.key = null;\n}\n')])])]),a("p",[e._v("这一次，"),a("code",[e._v("container")]),e._v("对象维护着一个对弱映射键的引用，因此这个对象键不会成为垃圾回收的目标。不过，如果调用了"),a("code",[e._v("removeReference()")]),e._v("，就会摧毁键对象的最后一个引用，垃圾回收程序就可以把这个键/值对清理掉。")]),e._v(" "),a("h3",{attrs:{id:"_6-5-3-不可迭代键"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-5-3-不可迭代键"}},[e._v("#")]),e._v(" 6.5.3 　不可迭代键")]),e._v(" "),a("p",[e._v("因为"),a("code",[e._v("WeakMap")]),e._v("中的键/值对任何时候都可能被销毁，所以没必要提供迭代其键/值对的能力。当然，也用不着像"),a("code",[e._v("clear()")]),e._v("这样一次性销毁所有键/值的方法。"),a("code",[e._v("WeakMap")]),e._v(" 确实没有这个方法。因为不可能迭代，所以也不可能在不知道对象引用的情况下从弱映射中取得值。即便代码可以访问"),a("code",[e._v("WeakMap")]),e._v("实例，也没办法看到其中的内容。")]),e._v(" "),a("p",[a("code",[e._v("WeakMap")]),e._v("实例之所以限制只能用对象作为键，是为了保证只有通过键对象的引用才能取得值。如果允许原始值，那就没办法区分初始化时使用的字符串字面量和初始化之后使用的一个相等的字符串了。")]),e._v(" "),a("h3",{attrs:{id:"_6-5-4-使用弱映射"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-5-4-使用弱映射"}},[e._v("#")]),e._v(" 6.5.4 　使用弱映射")]),e._v(" "),a("p",[a("code",[e._v("WeakMap")]),e._v("实例与现有 JavaScript 对象有着很大不同，可能一时不容易说清楚应该怎么使用它。这个问题没有唯一的答案，但已经出现了很多相关策略。")]),e._v(" "),a("ol",[a("li",[a("p",[a("strong",[e._v("私有变量")])]),e._v(" "),a("p",[e._v("弱映射造就了在 JavaScript 中实现真正私有变量的一种新方式。前提很明确：私有变量会存储在弱映射中，以对象实例为键，以私有成员的字典为值。")]),e._v(" "),a("p",[e._v("下面是一个示例实现：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("const wm = new WeakMap();\n\nclass User {\n  constructor(id) {\n    this.idProperty = Symbol('id');\n    this.setId(id);\n  }\n\n  setPrivate(property, value) {\n    const privateMembers = wm.get(this) || {};\n    privateMembers[property] = value;\n    wm.set(this, privateMembers);\n  }\n\n  getPrivate(property) {\n    return wm.get(this)[property];\n  }\n\n  setId(id) {\n    this.setPrivate(this.idProperty, id);\n  }\n\n  getId() {\n    return this.getPrivate(this.idProperty);\n  }\n}\n\nconst user = new User(123);\nalert(user.getId()); // 123\nuser.setId(456);\nalert(user.getId()); // 456\n\n// 并不是真正私有的\nalert(wm.get(user)[user.idProperty]); // 456\n")])])]),a("p",[e._v("慧眼独具的读者会发现，对于上面的实现，外部代码只需要拿到对象实例的引用和弱映射，就可以取得“私有”变量了。为了避免这种访问，可以用一个闭包把"),a("code",[e._v("WeakMap")]),e._v("包装起来，这样就可以把弱映射与外界完全隔离开了：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("const User = (() => {\n  const wm = new WeakMap();\n\n  class User {\n    constructor(id) {\n      this.idProperty = Symbol('id');\n      this.setId(id);\n    }\n\n    setPrivate(property, value) {\n      const privateMembers = wm.get(this) || {};\n      privateMembers[property] = value;\n      wm.set(this, privateMembers);\n    }\n\n    getPrivate(property) {\n      return wm.get(this)[property];\n    }\n\n    setId(id) {\n      this.setPrivate(this.idProperty, id);\n    }\n\n    getId(id) {\n      return this.getPrivate(this.idProperty);\n    }\n  }\n  return User;\n})();\n\nconst user = new User(123);\nalert(user.getId()); // 123\nuser.setId(456);\nalert(user.getId()); // 456\n")])])]),a("p",[e._v("这样，拿不到弱映射中的健，也就无法取得弱映射中对应的值。虽然这防止了前面提到的访问，但整个代码也完全陷入了 ES6 之前的闭包私有变量模式。")])])]),e._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[a("p",[a("strong",[e._v("DOM 节点元数据")])]),e._v(" "),a("p",[e._v("因为"),a("code",[e._v("WeakMap")]),e._v("实例不会妨碍垃圾回收，所以非常适合保存关联元数据。来看下面这个例子，其中使用了常规的"),a("code",[e._v("Map")]),e._v("：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("const m = new Map();\n\nconst loginButton = document.querySelector('#login');\n\n// 给这个节点关联一些元数据\nm.set(loginButton, {disabled: true});\n")])])]),a("p",[e._v("假设在上面的代码执行后，页面被 JavaScript 改变了，原来的登录按钮从 DOM 树中被删掉了。但由于映射中还保存着按钮的引用，所以对应的 DOM 节点仍然会逗留在内存中，除非明确将其从映射中删除或者等到映射本身被销毁。")]),e._v(" "),a("p",[e._v("如果这里使用的是弱映射，如以下代码所示，那么当节点从 DOM 树中被删除后，垃圾回收程序就可以立即释放其内存（假设没有其他地方引用这个对象）：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("const wm = new WeakMap();\n\nconst loginButton = document.querySelector('#login');\n\n// 给这个节点关联一些元数据\nwm.set(loginButton, {disabled: true});\n")])])])])]),e._v(" "),a("h2",{attrs:{id:"_6-6-set"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-6-set"}},[e._v("#")]),e._v(" 6.6 　"),a("code",[e._v("Set")])]),e._v(" "),a("p",[e._v("ECMAScript 6 新增的"),a("code",[e._v("Set")]),e._v("是一种新集合类型，为这门语言带来集合数据结构。"),a("code",[e._v("Set")]),e._v("在很多方面都像是加强的"),a("code",[e._v("Map")]),e._v("，这是因为它们的大多数 API 和行为都是共有的。")]),e._v(" "),a("h3",{attrs:{id:"_6-6-1-基本-api"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-6-1-基本-api"}},[e._v("#")]),e._v(" 6.6.1 　基本 API")]),e._v(" "),a("p",[e._v("使用"),a("code",[e._v("new")]),e._v("关键字和"),a("code",[e._v("Set")]),e._v("构造函数可以创建一个空集合：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("const m = new Set();\n")])])]),a("p",[e._v("如果想在创建的同时初始化实例，则可以给"),a("code",[e._v("Set")]),e._v("构造函数传入一个可迭代对象，其中需要包含插入到新集合实例中的元素：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('// 使用数组初始化集合\nconst s1 = new Set(["val1", "val2", "val3"]);\n\nalert(s1.size); // 3\n\n// 使用自定义迭代器初始化集合\nconst s2 = new Set({\n  [Symbol.iterator]: function*() {\n    yield "val1";\n    yield "val2";\n    yield "val3";\n  }\n});\nalert(s2.size); // 3\n')])])]),a("p",[e._v("初始化之后，可以使用"),a("code",[e._v("add()")]),e._v("增加值，使用"),a("code",[e._v("has()")]),e._v("查询，通过"),a("code",[e._v("size")]),e._v("取得元素数量，以及使用"),a("code",[e._v("delete()")]),e._v("和"),a("code",[e._v("clear()")]),e._v("删除元素：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('const s = new Set();\n\nalert(s.has("Matt"));    // false\nalert(s.size);           // 0\n\ns.add("Matt")\n .add("Frisbie");\n\nalert(s.has("Matt"));    // true\nalert(s.size);           // 2\n\ns.delete("Matt");\n\nalert(s.has("Matt"));    // false\nalert(s.has("Frisbie")); // true\nalert(s.size);           // 1\n\ns.clear(); // 销毁集合实例中的所有值\n\nalert(s.has("Matt"));    // false\nalert(s.has("Frisbie")); // false\nalert(s.size);           // 0\n')])])]),a("p",[a("code",[e._v("add()")]),e._v("返回集合的实例，所以可以将多个添加操作连缀起来，包括初始化：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('const s = new Set().add("val1");\n\ns.add("val2")\n .add("val3");\n\nalert(s.size); // 3\n')])])]),a("p",[e._v("与"),a("code",[e._v("Map")]),e._v("类似，"),a("code",[e._v("Set")]),e._v("可以包含任何 JavaScript 数据类型作为值。集合也使用 SameValueZero 操作（ECMAScript 内部定义，无法在语言中使用），基本上相当于使用严格对象相等的标准来检查值的匹配性。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("const s = new Set();\n\nconst functionVal = function() {};\nconst symbolVal = Symbol();\nconst objectVal = new Object();\n\ns.add(functionVal);\ns.add(symbolVal);\ns.add(objectVal);\n\nalert(s.has(functionVal));   // true\nalert(s.has(symbolVal));     // true\nalert(s.has(objectVal));     // true\n\n// SameValueZero检查意味着独立的实例不会冲突\nalert(s.has(function() {})); // false\n")])])]),a("p",[e._v("与严格相等一样，用作值的对象和其他“集合”类型在自己的内容或属性被修改时也不会改变：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('const s = new Set();\n\nconst objVal = {},\n      arrVal = [];\n\ns.add(objVal);\ns.add(arrVal);\n\nobjVal.bar = "bar";\narrVal.push("bar");\n\nalert(s.has(objVal)); // true\nalert(s.has(arrVal)); // true\n')])])]),a("p",[a("code",[e._v("add()")]),e._v("和"),a("code",[e._v("delete()")]),e._v("操作是幂等的。"),a("code",[e._v("delete()")]),e._v("返回一个布尔值，表示集合中是否存在要删除的值：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("const s = new Set();\n\ns.add('foo');\nalert(s.size); // 1\ns.add('foo');\nalert(s.size); // 1\n\n// 集合里有这个值\nalert(s.delete('foo')); // true\n\n// 集合里没有这个值\nalert(s.delete('foo')); // false\n")])])]),a("h3",{attrs:{id:"_6-6-2-顺序与迭代"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-6-2-顺序与迭代"}},[e._v("#")]),e._v(" 6.6.2 　顺序与迭代")]),e._v(" "),a("p",[a("code",[e._v("Set")]),e._v("会维护值插入时的顺序，因此支持按顺序迭代。")]),e._v(" "),a("p",[e._v("集合实例可以提供一个迭代器（"),a("code",[e._v("Iterator")]),e._v("），能以插入顺序生成集合内容。可以通过"),a("code",[e._v("values()")]),e._v("方法及其别名方法"),a("code",[e._v("keys()")]),e._v("（或者"),a("code",[e._v("Symbol.iterator")]),e._v("属性，它引用"),a("code",[e._v("values()")]),e._v("）取得这个迭代器：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('const s = new Set(["val1", "val2", "val3"]);\n\nalert(s.values === s[Symbol.iterator]); // true\nalert(s.keys === s[Symbol.iterator]);   // true\n\nfor (let value of s.values()) {\n  alert(value);\n}\n// val1\n// val2\n// val3\n\nfor (let value of s[Symbol.iterator]()) {\n  alert(value);\n}\n// val1\n// val2\n// val3\n')])])]),a("p",[e._v("因为"),a("code",[e._v("values()")]),e._v("是默认迭代器，所以可以直接对集合实例使用扩展操作，把集合转换为数组：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('const s = new Set(["val1", "val2", "val3"]);\n\nconsole.log([...s]); // ["val1", "val2", "val3"]\n')])])]),a("p",[e._v("集合的"),a("code",[e._v("entries()")]),e._v("方法返回一个迭代器，可以按照插入顺序产生包含两个元素的数组，这两个元素是集合中每个值的重复出现：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('const s = new Set(["val1", "val2", "val3"]);\n\nfor (let pair of s.entries()) {\n  console.log(pair);\n}\n// ["val1", "val1"]\n// ["val2", "val2"]\n// ["val3", "val3"]\n')])])]),a("p",[e._v("如果不使用迭代器，而是使用回调方式，则可以调用集合的"),a("code",[e._v("forEach()")]),e._v("方法并传入回调，依次迭代每个键/值对。传入的回调接收可选的第二个参数，这个参数用于重写回调内部"),a("code",[e._v("this")]),e._v("的值：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('const s = new Set(["val1", "val2", "val3"]);\n\ns.forEach((val, dupVal) => alert(`${val} -> ${dupVal}`));\n// val1 -> val1\n// val2 -> val2\n// val3 -> val3\n')])])]),a("p",[e._v("修改集合中值的属性不会影响其作为集合值的身份：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('const s1 = new Set(["val1"]);\n\n// 字符串原始值作为值不会被修改\nfor (let value of s1.values()) {\n  value = "newVal";\n  alert(value);          // newVal\n  alert(s1.has("val1")); // true\n}\n\nconst valObj = {id: 1};\n\nconst s2 = new Set([valObj]);\n\n// 修改值对象的属性，但对象仍然存在于集合中\nfor (let value of s2.values()) {\n  value.id = "newVal";\n  alert(value);           // {id: "newVal"}\n  alert(s2.has(valObj));  // true\n}\nalert(valObj);            // {id: "newVal"}\n')])])]),a("h3",{attrs:{id:"_6-6-3-定义正式集合操作"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-6-3-定义正式集合操作"}},[e._v("#")]),e._v(" 6.6.3 　定义正式集合操作")]),e._v(" "),a("p",[e._v("从各方面来看，"),a("code",[e._v("Set")]),e._v("跟"),a("code",[e._v("Map")]),e._v("都很相似，只是 API 稍有调整。唯一需要强调的就是集合的 API 只支持自引用操作。很多开发者都喜欢使用"),a("code",[e._v("Set")]),e._v("操作，但需要手动实现：或者是子类化"),a("code",[e._v("Set")]),e._v("，或者是定义一个实用函数库。要把两种方式合二为一，可以在子类上实现静态方法，然后在实例方法中使用这些静态方法。在实现这些操作时，需要考虑几个地方。")]),e._v(" "),a("ul",[a("li",[e._v("某些"),a("code",[e._v("Set")]),e._v("操作是有关联性的，因此最好让实现的方法能支持处理任意多个集合实例。")]),e._v(" "),a("li",[a("code",[e._v("Set")]),e._v("保留插入顺序，所有方法返回的集合必须保证顺序。")]),e._v(" "),a("li",[e._v("尽可能高效地使用内存。扩展操作符的语法很简洁，但尽可能避免集合和数组间的相互转换能够节省对象初始化成本。")]),e._v(" "),a("li",[e._v("不要修改已有的集合实例。"),a("code",[e._v("union(a, b)")]),e._v("或"),a("code",[e._v("a.union(b)")]),e._v("应该返回包含结果的新集合实例。")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("class XSet extends Set {\n  union(...sets) {\n    return XSet.union(this, ...sets)\n  }\n\n  intersection(...sets) {\n    return XSet.intersection(this, ...sets);\n  }\n\n  difference(set) {\n    return XSet.difference(this, set);\n  }\n\n  symmetricDifference(set) {\n    return XSet.symmetricDifference(this, set);\n  }\n\n  cartesianProduct(set) {\n    return XSet.cartesianProduct(this, set);\n  }\n\n  powerSet() {\n    return XSet.powerSet(this);\n  }\n\n  // 返回两个或更多集合的并集\n  static union(a, ...bSets) {\n    const unionSet = new XSet(a);\n    for (const b of bSets) {\n      for (const bValue of b) {\n        unionSet.add(bValue);\n      }\n    }\n    return unionSet;\n  }\n\n  // 返回两个或更多集合的交集\n  static intersection(a, ...bSets) {\n    const intersectionSet = new XSet(a);\n    for (const aValue of intersectionSet) {\n      for (const b of bSets) {\n        if (!b.has(aValue)) {\n          intersectionSet.delete(aValue);\n        }\n      }\n    }\n    return intersectionSet;\n  }\n\n  // 返回两个集合的差集\n  static difference(a, b) {\n    const differenceSet = new XSet(a);\n    for (const bValue of b) {\n      if (a.has(bValue)) {\n        differenceSet.delete(bValue);\n      }\n    }\n    return differenceSet;\n  }\n\n  // 返回两个集合的对称差集\n  static symmetricDifference(a, b) {\n    // 按照定义，对称差集可以表达为\n    return a.union(b).difference(a.intersection(b));\n  }\n\n  // 返回两个集合（数组对形式）的笛卡儿积\n  // 必须返回数组集合，因为笛卡儿积可能包含相同值的对\n  static cartesianProduct(a, b) {\n    const cartesianProductSet = new XSet();\n    for (const aValue of a) {\n      for (const bValue of b) {\n        cartesianProductSet.add([aValue, bValue]);\n      }\n    }\n    return cartesianProductSet;\n  }\n\n  // 返回一个集合的幂集\n  static powerSet(a) {\n    const powerSet = new XSet().add(new XSet());\n    for (const aValue of a) {\n      for (const set of new XSet(powerSet)) {\n        powerSet.add(new XSet(set).add(aValue));\n      }\n    }\n    return powerSet;\n  }\n}\n")])])]),a("h2",{attrs:{id:"_6-7-weakset"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-7-weakset"}},[e._v("#")]),e._v(" 6.7 　"),a("code",[e._v("WeakSet")])]),e._v(" "),a("p",[e._v("ECMAScript 6 新增的“弱集合”（"),a("code",[e._v("WeakSet")]),e._v("）是一种新的集合类型，为这门语言带来了集合数据结构。"),a("code",[e._v("WeakSet")]),e._v("是"),a("code",[e._v("Set")]),e._v("的“兄弟”类型，其 API 也是"),a("code",[e._v("Set")]),e._v("的子集。"),a("code",[e._v("WeakSet")]),e._v("中的“weak”（弱），描述的是 JavaScript 垃圾回收程序对待“弱集合”中值的方式。")]),e._v(" "),a("h3",{attrs:{id:"_6-7-1-基本-api"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-7-1-基本-api"}},[e._v("#")]),e._v(" 6.7.1 　基本 API")]),e._v(" "),a("p",[e._v("可以使用"),a("code",[e._v("new")]),e._v("关键字实例化一个空的"),a("code",[e._v("WeakSet")]),e._v("：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("const ws = new WeakSet();\n")])])]),a("p",[e._v("弱集合中的值只能是"),a("code",[e._v("Object")]),e._v("或者继承自"),a("code",[e._v("Object")]),e._v("的类型，尝试使用非对象设置值会抛出"),a("code",[e._v("TypeError")]),e._v("。")]),e._v(" "),a("p",[e._v("如果想在初始化时填充弱集合，则构造函数可以接收一个可迭代对象，其中需要包含有效的值。可迭代对象中的每个值都会按照迭代顺序插入到新实例中：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('const val1 = {id: 1},\n      val2 = {id: 2},\n      val3 = {id: 3};\n// 使用数组初始化弱集合\nconst ws1 = new WeakSet([val1, val2, val3]);\n\nalert(ws1.has(val1)); // true\nalert(ws1.has(val2)); // true\nalert(ws1.has(val3)); // true\n\n// 初始化是全有或全无的操作\n// 只要有一个值无效就会抛出错误，导致整个初始化失败\nconst ws2 = new WeakSet([val1, "BADVAL", val3]);\n// TypeError: Invalid value used in WeakSet\ntypeof ws2;\n// ReferenceError: ws2 is not defined\n\n// 原始值可以先包装成对象再用作值\nconst stringVal = new String("val1");\nconst ws3 = new WeakSet([stringVal]);\nalert(ws3.has(stringVal)); // true\n')])])]),a("p",[e._v("初始化之后可以使用"),a("code",[e._v("add()")]),e._v("再添加新值，可以使用"),a("code",[e._v("has()")]),e._v("查询，还可以使用"),a("code",[e._v("delete()")]),e._v("删除：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("const ws = new WeakSet();\n\nconst val1 = {id: 1},\n      val2 = {id: 2};\n\nalert(ws.has(val1)); // false\n\nws.add(val1)\n  .add(val2);\n\nalert(ws.has(val1)); // true\nalert(ws.has(val2)); // true\n\nws.delete(val1);     // 只删除这一个值\n\nalert(ws.has(val1)); // false\nalert(ws.has(val2)); // true\n")])])]),a("p",[a("code",[e._v("add()")]),e._v("方法返回弱集合实例，因此可以把多个操作连缀起来，包括初始化声明：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("const val1 = {id: 1},\n      val2 = {id: 2},\n      val3 = {id: 3};\n\nconst ws = new WeakSet().add(val1);\n\nws.add(val2)\n  .add(val3);\n\nalert(ws.has(val1)); // true\nalert(ws.has(val2)); // true\nalert(ws.has(val3)); // true\n")])])]),a("h3",{attrs:{id:"_6-7-2-弱值"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-7-2-弱值"}},[e._v("#")]),e._v(" 6.7.2 　弱值")]),e._v(" "),a("p",[a("code",[e._v("WeakSet")]),e._v("中“weak”表示弱集合的值是“弱弱地拿着”的。意思就是，这些值不属于正式的引用，不会阻止垃圾回收。")]),e._v(" "),a("p",[e._v("来看下面的例子：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("const ws = new WeakSet();\n\nws.add({});\n")])])]),a("p",[a("code",[e._v("add()")]),e._v("方法初始化了一个新对象，并将它用作一个值。因为没有指向这个对象的其他引用，所以当这行代码执行完成后，这个对象值就会被当作垃圾回收。然后，这个值就从弱集合中消失了，使其成为一个空集合。")]),e._v(" "),a("p",[e._v("再看一个稍微不同的例子：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("const ws = new WeakSet();\n\nconst container = {\n  val: {}\n};\n\nws.add(container.val);\n\nfunction removeReference() {\n  container.val = null;\n}\n")])])]),a("p",[e._v("这一次，"),a("code",[e._v("container")]),e._v("对象维护着一个对弱集合值的引用，因此这个对象值不会成为垃圾回收的目标。不过，如果调用了"),a("code",[e._v("removeReference()")]),e._v("，就会摧毁值对象的最后一个引用，垃圾回收程序就可以把这个值清理掉。")]),e._v(" "),a("h3",{attrs:{id:"_6-7-3-不可迭代值"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-7-3-不可迭代值"}},[e._v("#")]),e._v(" 6.7.3 　不可迭代值")]),e._v(" "),a("p",[e._v("因为"),a("code",[e._v("WeakSet")]),e._v("中的值任何时候都可能被销毁，所以没必要提供迭代其值的能力。当然，也用不着像"),a("code",[e._v("clear()")]),e._v("这样一次性销毁所有值的方法。"),a("code",[e._v("WeakSet")]),e._v(" 确实没有这个方法。因为不可能迭代，所以也不可能在不知道对象引用的情况下从弱集合中取得值。即便代码可以访问"),a("code",[e._v("WeakSet")]),e._v("实例，也没办法看到其中的内容。")]),e._v(" "),a("p",[a("code",[e._v("WeakSet")]),e._v("之所以限制只能用对象作为值，是为了保证只有通过值对象的引用才能取得值。如果允许原始值，那就没办法区分初始化时使用的字符串字面量和初始化之后使用的一个相等的字符串了。")]),e._v(" "),a("h3",{attrs:{id:"_6-7-4-使用弱集合"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-7-4-使用弱集合"}},[e._v("#")]),e._v(" 6.7.4 　使用弱集合")]),e._v(" "),a("p",[e._v("相比于"),a("code",[e._v("WeakMap")]),e._v("实例，"),a("code",[e._v("WeakSet")]),e._v("实例的用处没有那么大。不过，弱集合在给对象打标签时还是有价值的。")]),e._v(" "),a("p",[e._v("来看下面的例子，这里使用了一个普通"),a("code",[e._v("Set")]),e._v("：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("const disabledElements = new Set();\n\nconst loginButton = document.querySelector('#login');\n\n// 通过加入对应集合，给这个节点打上“禁用”标签\ndisabledElements.add(loginButton);\n")])])]),a("p",[e._v("这样，通过查询元素在不在"),a("code",[e._v("disabledElements")]),e._v("中，就可以知道它是不是被禁用了。不过，假如元素从 DOM 树中被删除了，它的引用却仍然保存在"),a("code",[e._v("Set")]),e._v("中，因此垃圾回收程序也不能回收它。")]),e._v(" "),a("p",[e._v("为了让垃圾回收程序回收元素的内存，可以在这里使用"),a("code",[e._v("WeakSet")]),e._v("：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("const disabledElements = new WeakSet();\n\nconst loginButton = document.querySelector('#login');\n\n// 通过加入对应集合，给这个节点打上“禁用”标签\ndisabledElements.add(loginButton);\n")])])]),a("p",[e._v("这样，只要"),a("code",[e._v("WeakSet")]),e._v("中任何元素从 DOM 树中被删除，垃圾回收程序就可以忽略其存在，而立即释放其内存（假设没有其他地方引用这个对象）。")]),e._v(" "),a("h2",{attrs:{id:"_6-8-迭代与扩展操作"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-8-迭代与扩展操作"}},[e._v("#")]),e._v(" 6.8 　迭代与扩展操作")]),e._v(" "),a("p",[e._v("ECMAScript 6 新增的迭代器和扩展操作符对集合引用类型特别有用。这些新特性让集合类型之间相互操作、复制和修改变得异常方便。")]),e._v(" "),a("blockquote",[a("p",[a("strong",[e._v("注意")]),e._v("　第 7 章会更详细地介绍迭代器和生成器。")])]),e._v(" "),a("p",[e._v("如本章前面所示，有 4 种原生集合类型定义了默认迭代器：")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("Array")])]),e._v(" "),a("li",[e._v("所有定型数组")]),e._v(" "),a("li",[a("code",[e._v("Map")])]),e._v(" "),a("li",[a("code",[e._v("Set")])])]),e._v(" "),a("p",[e._v("很简单，这意味着上述所有类型都支持顺序迭代，都可以传入"),a("code",[e._v("for-of")]),e._v("循环：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("let iterableThings = [\n  Array.of(1, 2),\n  typedArr = Int16Array.of(3, 4),\n  new Map([[5, 6], [7, 8]]),\n  new Set([9, 10])\n];\n\nfor (const iterableThing of iterableThings) {\n  for (const x of iterableThing) {\n    console.log(x);\n  }\n}\n\n// 1\n// 2\n// 3\n// 4\n// [5, 6]\n// [7, 8]\n// 9\n// 10\n")])])]),a("p",[e._v("这也意味着所有这些类型都兼容扩展操作符。扩展操作符在对可迭代对象执行浅复制时特别有用，只需简单的语法就可以复制整个对象：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("let arr1 = [1, 2, 3];\nlet arr2 = [...arr1];\n\nconsole.log(arr1);          // [1, 2, 3]\nconsole.log(arr2);          // [1, 2, 3]\nconsole.log(arr1 === arr2); // false\n")])])]),a("p",[e._v("对于期待可迭代对象的构造函数，只要传入一个可迭代对象就可以实现复制：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("let map1 = new Map([[1, 2], [3, 4]]);\nlet map2 = new Map(map1);\n\nconsole.log(map1); // Map {1 => 2, 3 => 4}\nconsole.log(map2); // Map {1 => 2, 3 => 4}\n")])])]),a("p",[e._v("当然，也可以构建数组的部分元素：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("let arr1 = [1, 2, 3];\nlet arr2 = [0, ...arr1, 4, 5];\n\nconsole.log(arr2); // [0, 1, 2, 3, 4, 5]\n")])])]),a("p",[e._v("浅复制意味着只会复制对象引用：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("let arr1 = [{}];\nlet arr2 = [...arr1];\n\narr1[0].foo = 'bar';\nconsole.log(arr2[0]); // { foo: 'bar' }\n")])])]),a("p",[e._v("上面的这些类型都支持多种构建方法，比如"),a("code",[e._v("Array.of()")]),e._v("和"),a("code",[e._v("Array.from()")]),e._v("静态方法。在与扩展操作符一起使用时，可以非常方便地实现互操作：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("let arr1 = [1, 2, 3];\n\n// 把数组复制到定型数组\nlet typedArr1 = Int16Array.of(...arr1);\nlet typedArr2 = Int16Array.from(arr1);\nconsole.log(typedArr1);   // Int16Array [1, 2, 3]\nconsole.log(typedArr2);   // Int16Array [1, 2, 3]\n\n// 把数组复制到映射\nlet map = new Map(arr1.map((x) => [x, 'val' + x]));\nconsole.log(map);   // Map {1 => 'val 1', 2 => 'val 2', 3 => 'val 3'}\n\n// 把数组复制到集合\nlet set = new Set(typedArr2);\nconsole.log(set);   // Set {1, 2, 3}\n\n// 把集合复制回数组\nlet arr2 = [...set];\nconsole.log(arr2);  // [1, 2, 3]\n")])])]),a("h2",{attrs:{id:"_6-9-小结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-9-小结"}},[e._v("#")]),e._v(" 6.9 　小结")]),e._v(" "),a("p",[e._v("JavaScript 中的对象是引用值，可以通过几种内置引用类型创建特定类型的对象。")]),e._v(" "),a("ul",[a("li",[e._v("引用类型与传统面向对象编程语言中的类相似，但实现不同。")]),e._v(" "),a("li",[a("code",[e._v("Object")]),e._v("类型是一个基础类型，所有引用类型都从它继承了基本的行为。")]),e._v(" "),a("li",[a("code",[e._v("Array")]),e._v("类型表示一组有序的值，并提供了操作和转换值的能力。")]),e._v(" "),a("li",[e._v("定型数组包含一套不同的引用类型，用于管理数值在内存中的类型。")]),e._v(" "),a("li",[a("code",[e._v("Date")]),e._v("类型提供了关于日期和时间的信息，包括当前日期和时间以及计算。")]),e._v(" "),a("li",[a("code",[e._v("RegExp")]),e._v("类型是 ECMAScript 支持的正则表达式的接口，提供了大多数基本正则表达式以及一些高级正则表达式的能力。")])]),e._v(" "),a("p",[e._v("JavaScript 比较独特的一点是，函数其实是"),a("code",[e._v("Function")]),e._v("类型的实例，这意味着函数也是对象。由于函数是对象，因此也就具有能够增强自身行为的方法。")]),e._v(" "),a("p",[e._v("因为原始值包装类型的存在，所以 JavaScript 中的原始值可以拥有类似对象的行为。有 3 种原始值包装类型："),a("code",[e._v("Boolean")]),e._v("、"),a("code",[e._v("Number")]),e._v("和"),a("code",[e._v("String")]),e._v("。它们都具有如下特点。")]),e._v(" "),a("ul",[a("li",[e._v("每种包装类型都映射到同名的原始类型。")]),e._v(" "),a("li",[e._v("在以读模式访问原始值时，后台会实例化一个原始值包装对象，通过这个对象可以操作数据。")]),e._v(" "),a("li",[e._v("涉及原始值的语句只要一执行完毕，包装对象就会立即销毁。")])]),e._v(" "),a("p",[e._v("JavaScript 还有两个在一开始执行代码时就存在的内置对象："),a("code",[e._v("Global")]),e._v("和"),a("code",[e._v("Math")]),e._v("。其中，"),a("code",[e._v("Global")]),e._v("对象可以在大多数 ECMAScript 实现中访问。不过浏览器将"),a("code",[e._v("Global")]),e._v("实现为"),a("code",[e._v("window")]),e._v("对象。所有全局变量和函数都是"),a("code",[e._v("Global")]),e._v("对象的属性。"),a("code",[e._v("Math")]),e._v("对象包含辅助完成复杂数学计算的属性和方法。")]),e._v(" "),a("p",[e._v("ECMAScript 6 新增了一批引用类型："),a("code",[e._v("Map")]),e._v("、"),a("code",[e._v("WeakMap")]),e._v("、"),a("code",[e._v("Set")]),e._v("和"),a("code",[e._v("WeakSet")]),e._v("。这些类型为组织应用程序数据和简化内存管理提供了新能力。")])])}),[],!1,null,null,null);t.default=v.exports}}]);