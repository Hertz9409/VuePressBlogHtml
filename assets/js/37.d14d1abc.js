(window.webpackJsonp=window.webpackJsonp||[]).push([[37],{494:function(t,e,s){"use strict";s.r(e);var a=s(27),r=Object(a.a)({},(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"事件循环"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#事件循环"}},[t._v("#")]),t._v(" 事件循环")]),t._v(" "),s("h2",{attrs:{id:"单线程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#单线程"}},[t._v("#")]),t._v(" 单线程")]),t._v(" "),s("p",[t._v("JS 是单线程的,一个时间只能做一件事情,所以要通过异步来提高代码执行效率和 CPU 利用率.")]),t._v(" "),s("h2",{attrs:{id:"执行栈和任务队列"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#执行栈和任务队列"}},[t._v("#")]),t._v(" 执行栈和任务队列")]),t._v(" "),s("p",[t._v("前面我们已经讲过执行栈的概念,这里不再赘述,其实执行栈就是函数排队调用执行的地方,里面保存着当前函数执行的全部环境和上下文.需要注意的是执行栈只存放同步任务.异步任务的回调函数会存放到任务队列中.")]),t._v(" "),s("p",[t._v("当执行栈执行到异步任务,它会把回调函数放到任务队列,等到执行栈中的同步任务全部执行完成,再去查看任务队列中是否有任务,如果有,则会将任务队列中第一个任务放到执行栈中执行,然后不断循环这个过程,这其实就是事件循环.")]),t._v(" "),s("h2",{attrs:{id:"宏任务和微任务"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#宏任务和微任务"}},[t._v("#")]),t._v(" 宏任务和微任务")]),t._v(" "),s("p",[t._v("异步任务又分为宏任务和微任务,对于异步回调函数,根据类型会进入不同的任务队列.")]),t._v(" "),s("p",[t._v("常见的宏任务有 script 整体代码, setTimeout, setInterval,setImmediate, I/O, UI Render.")]),t._v(" "),s("p",[t._v("常见的微任务有 Promise, MutationObserver, process.nextTick, Async/Await.")]),t._v(" "),s("p",[t._v("当执行栈为空时,主线程会从任务队列中取任务执行:")]),t._v(" "),s("ol",[s("li",[s("p",[t._v("选择最先进入任务队列的宏任务")])]),t._v(" "),s("li",[s("p",[t._v("执行过程中遇到微任务,将其添加到微任务队列")])]),t._v(" "),s("li",[s("p",[t._v("宏任务执行结束后,依次执行当前微任务队列中所有任务,直至微任务队列为空")])]),t._v(" "),s("li",[s("p",[t._v("宏任务执行完毕,执行渲染")])]),t._v(" "),s("li",[s("p",[t._v("渲染完毕,执行下一个宏任务")])])])])}),[],!1,null,null,null);e.default=r.exports}}]);