(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{321:function(e,t,v){"use strict";v.r(t);var _=v(322),a=v.n(_);for(var l in _)["default"].indexOf(l)<0&&function(e){v.d(t,e,(function(){return _[e]}))}(l);t.default=a.a},322:function(e,t){},470:function(e,t,v){"use strict";v.d(t,"a",(function(){return _})),v.d(t,"b",(function(){return a}));var _=function(){var e=this,t=e.$createElement,v=e._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("h2",{attrs:{id:"第-14-章-dom"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#第-14-章-dom"}},[e._v("#")]),e._v(" 第 14 章　 DOM")]),e._v(" "),v("blockquote",[v("p",[v("strong",[e._v("本章内容")])]),e._v(" "),v("ul",[v("li",[e._v("理解文档对象模型（DOM）的构成")]),e._v(" "),v("li",[e._v("节点类型")]),e._v(" "),v("li",[e._v("浏览器兼容性")]),e._v(" "),v("li",[v("code",[e._v("MutationObserver")]),e._v("接口")])])]),e._v(" "),v("p",[e._v("文档对象模型（DOM，Document Object Model）是 HTML 和 XML 文档的编程接口。DOM 表示由多层节点构成的文档，通过它开发者可以添加、删除和修改页面的各个部分。脱胎于网景和微软早期的动态 HTML（DHTML，Dynamic HTML），DOM 现在是真正跨平台、语言无关的表示和操作网页的方式。")]),e._v(" "),v("p",[e._v("DOM Level 1 在 1998 年成为 W3C 推荐标准，提供了基本文档结构和查询的接口。本章之所以介绍 DOM，主要因为它与浏览器中的 HTML 网页相关，并且在 JavaScript 中提供了 DOM API。")]),e._v(" "),v("blockquote",[v("p",[v("strong",[e._v("注意")]),e._v("　 IE8 及更低版本中的 DOM 是通过 COM 对象实现的。这意味着这些版本的 IE 中，DOM 对象跟原生 JavaScript 对象具有不同的行为和功能。")])]),e._v(" "),v("h2",{attrs:{id:"_14-1-节点层级"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_14-1-节点层级"}},[e._v("#")]),e._v(" 14.1 　节点层级")]),e._v(" "),v("p",[e._v("任何 HTML 或 XML 文档都可以用 DOM 表示为一个由节点构成的层级结构。节点分很多类型，每种类型对应着文档中不同的信息和（或）标记，也都有自己不同的特性、数据和方法，而且与其他类型有某种关系。这些关系构成了层级，让标记可以表示为一个以特定节点为根的树形结构。以下面的 HTML 为例：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("<html>\n  <head>\n    <title>Sample Page</title>\n  </head>\n  <body>\n    <p>Hello World!</p>\n  </body>\n</html>\n")])])]),v("p",[e._v("如果表示为层级结构，则如图 14-1 所示。")]),e._v(" "),v("p",[v("img",{attrs:{src:"http://www.ituring.com.cn/figures/2020/JavaScriptWebDeve4th/021.png",alt:"img"}})]),e._v(" "),v("p",[v("strong",[e._v("图　 14-1")])]),e._v(" "),v("p",[e._v("其中，"),v("code",[e._v("document")]),e._v("节点表示每个文档的根节点。在这里，根节点的唯一子节点是"),v("code",[e._v("<html>")]),e._v("元素，我们称之为"),v("strong",[e._v("文档元素")]),e._v("（"),v("code",[e._v("documentElement")]),e._v("）。文档元素是文档最外层的元素，所有其他元素都存在于这个元素之内。每个文档只能有一个文档元素。在 HTML 页面中，文档元素始终是"),v("code",[e._v("<html>")]),e._v("元素。在 XML 文档中，则没有这样预定义的元素，任何元素都可能成为文档元素。")]),e._v(" "),v("p",[e._v("HTML 中的每段标记都可以表示为这个树形结构中的一个节点。元素节点表示 HTML 元素，属性节点表示属性，文档类型节点表示文档类型，注释节点表示注释。DOM 中总共有 12 种节点类型，这些类型都继承一种基本类型。")]),e._v(" "),v("h3",{attrs:{id:"_14-1-1-node类型"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_14-1-1-node类型"}},[e._v("#")]),e._v(" 14.1.1 　"),v("code",[e._v("Node")]),e._v("类型")]),e._v(" "),v("p",[e._v("DOM Level 1 描述了名为"),v("code",[e._v("Node")]),e._v("的接口，这个接口是所有 DOM 节点类型都必须实现的。"),v("code",[e._v("Node")]),e._v("接口在 JavaScript 中被实现为"),v("code",[e._v("Node")]),e._v("类型，在除 IE 之外的所有浏览器中都可以直接访问这个类型。在 JavaScript 中，所有节点类型都继承"),v("code",[e._v("Node")]),e._v("类型，因此所有类型都共享相同的基本属性和方法。")]),e._v(" "),v("p",[e._v("每个节点都有"),v("code",[e._v("nodeType")]),e._v("属性，表示该节点的类型。节点类型由定义在"),v("code",[e._v("Node")]),e._v("类型上的 12 个数值常量表示：")]),e._v(" "),v("ul",[v("li",[v("code",[e._v("Node.ELEMENT_NODE")]),e._v("（1）")]),e._v(" "),v("li",[v("code",[e._v("Node.ATTRIBUTE_NODE")]),e._v("（2）")]),e._v(" "),v("li",[v("code",[e._v("Node.TEXT_NODE")]),e._v("（3）")]),e._v(" "),v("li",[v("code",[e._v("Node.CDATA_SECTION_NODE")]),e._v("（4）")]),e._v(" "),v("li",[v("code",[e._v("Node.ENTITY_REFERENCE_NODE")]),e._v("（5）")]),e._v(" "),v("li",[v("code",[e._v("Node.ENTITY_NODE")]),e._v("（6）")]),e._v(" "),v("li",[v("code",[e._v("Node.PROCESSING_INSTRUCTION_NODE")]),e._v("（7）")]),e._v(" "),v("li",[v("code",[e._v("Node.COMMENT_NODE")]),e._v("（8）")]),e._v(" "),v("li",[v("code",[e._v("Node.DOCUMENT_NODE")]),e._v("（9）")]),e._v(" "),v("li",[v("code",[e._v("Node.DOCUMENT_TYPE_NODE")]),e._v("（10）")]),e._v(" "),v("li",[v("code",[e._v("Node.DOCUMENT_FRAGMENT_NODE")]),e._v("（11）")]),e._v(" "),v("li",[v("code",[e._v("Node.NOTATION_NODE")]),e._v("（12）")])]),e._v(" "),v("p",[e._v("节点类型可通过与这些常量比较来确定，比如：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v('if (someNode.nodeType == Node.ELEMENT_NODE){\n  alert("Node is an element.");\n}\n')])])]),v("p",[e._v("这个例子比较了"),v("code",[e._v("someNode.nodeType")]),e._v("与"),v("code",[e._v("Node.ELEMENT_NODE")]),e._v("常量。如果两者相等，则意味着 someNode 是一个元素节点。")]),e._v(" "),v("p",[e._v("浏览器并不支持所有节点类型。开发者最常用到的是元素节点和文本节点。本章后面会讨论每种节点受支持的程度及其用法。")]),e._v(" "),v("ol",[v("li",[v("p",[v("strong",[e._v("nodeName 与 nodeValue")])]),e._v(" "),v("p",[v("code",[e._v("nodeName")]),e._v("与"),v("code",[e._v("nodeValue")]),e._v("保存着有关节点的信息。这两个属性的值完全取决于节点类型。在使用这两个属性前，最好先检测节点类型，如下所示：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("if (someNode.nodeType == 1){\n  value = someNode.nodeName; // 会显示元素的标签名\n}\n")])])]),v("p",[e._v("在这个例子中，先检查了节点是不是元素。如果是，则将其"),v("code",[e._v("nodeName")]),e._v("的值赋给一个变量。对元素而言，"),v("code",[e._v("nodeName")]),e._v("始终等于元素的标签名，而"),v("code",[e._v("nodeValue")]),e._v("则始终为"),v("code",[e._v("null")]),e._v("。")])])]),e._v(" "),v("ol",{attrs:{start:"2"}},[v("li",[v("p",[v("strong",[e._v("节点关系")])]),e._v(" "),v("p",[e._v("文档中的所有节点都与其他节点有关系。这些关系可以形容为家族关系，相当于把文档树比作家谱。在 HTML 中，"),v("code",[e._v("<body>")]),e._v("元素是"),v("code",[e._v("<html>")]),e._v("元素的子元素，而"),v("code",[e._v("<html>")]),e._v("元素则是"),v("code",[e._v("<body>")]),e._v("元素的父元素。"),v("code",[e._v("<head>")]),e._v("元素是"),v("code",[e._v("<body>")]),e._v("元素的同胞元素，因为它们有共同的父元素"),v("code",[e._v("<html>")]),e._v("。")]),e._v(" "),v("p",[e._v("每个节点都有一个"),v("code",[e._v("childNodes")]),e._v("属性，其中包含一个"),v("code",[e._v("NodeList")]),e._v("的实例。"),v("code",[e._v("NodeList")]),e._v("是一个类数组对象，用于存储可以按位置存取的有序节点。注意，"),v("code",[e._v("NodeList")]),e._v("并不是"),v("code",[e._v("Array")]),e._v("的实例，但可以使用中括号访问它的值，而且它也有"),v("code",[e._v("length")]),e._v("属性。"),v("code",[e._v("NodeList")]),e._v("对象独特的地方在于，它其实是一个对 DOM 结构的查询，因此 DOM 结构的变化会自动地在"),v("code",[e._v("NodeList")]),e._v("中反映出来。我们通常说"),v("code",[e._v("NodeList")]),e._v("是实时的活动对象，而不是第一次访问时所获得内容的快照。")]),e._v(" "),v("p",[e._v("下面的例子展示了如何使用中括号或使用"),v("code",[e._v("item()")]),e._v("方法访问"),v("code",[e._v("NodeList")]),e._v("中的元素：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("let firstChild = someNode.childNodes[0];\nlet secondChild = someNode.childNodes.item(1);\nlet count = someNode.childNodes.length;\n")])])]),v("p",[e._v("无论是使用中括号还是"),v("code",[e._v("item()")]),e._v("方法都是可以的，但多数开发者倾向于使用中括号，因为它是一个类数组对象。注意，"),v("code",[e._v("length")]),e._v("属性表示那一时刻"),v("code",[e._v("NodeList")]),e._v("中节点的数量。使用"),v("code",[e._v("Array.prototype.slice()")]),e._v("可以像前面介绍"),v("code",[e._v("arguments")]),e._v("时一样把"),v("code",[e._v("NodeList")]),e._v("对象转换为数组。比如：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("let arrayOfNodes = Array.prototype.slice.call(someNode.childNodes,0);\n")])])]),v("p",[e._v("当然，使用 ES6 的"),v("code",[e._v("Array.from()")]),e._v("静态方法，可以替换这种笨拙的方式：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("let arrayOfNodes = Array.from(someNode.childNodes);\n")])])]),v("p",[e._v("每个节点都有一个"),v("code",[e._v("parentNode")]),e._v("属性，指向其 DOM 树中的父元素。"),v("code",[e._v("childNodes")]),e._v("中的所有节点都有同一个父元素，因此它们的"),v("code",[e._v("parentNode")]),e._v("属性都指向同一个节点。此外，"),v("code",[e._v("childNodes")]),e._v("列表中的每个节点都是同一列表中其他节点的同胞节点。而使用"),v("code",[e._v("previousSibling")]),e._v("和"),v("code",[e._v("nextSibling")]),e._v("可以在这个列表的节点间导航。这个列表中第一个节点的"),v("code",[e._v("previousSibling")]),e._v("属性是"),v("code",[e._v("null")]),e._v("，最后一个节点的"),v("code",[e._v("nextSibling")]),e._v("属性也是"),v("code",[e._v("null")]),e._v("，如下所示：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v('if (someNode.nextSibling === null){\n  alert("Last node in the parent\'s childNodes list.");\n} else if (someNode.previousSibling === null){\n  alert("First node in the parent\'s childNodes list.");\n}\n')])])]),v("p",[e._v("注意，如果"),v("code",[e._v("childNodes")]),e._v("中只有一个节点，则它的"),v("code",[e._v("previousSibling")]),e._v("和"),v("code",[e._v("nextSibling")]),e._v("属性都是"),v("code",[e._v("null")]),e._v("。")]),e._v(" "),v("p",[e._v("父节点和它的第一个及最后一个子节点也有专门属性："),v("code",[e._v("firstChild")]),e._v("和"),v("code",[e._v("lastChild")]),e._v("分别指向"),v("code",[e._v("childNodes")]),e._v("中的第一个和最后一个子节点。"),v("code",[e._v("someNode.firstChild")]),e._v("的值始终等于"),v("code",[e._v("someNode.childNodes[0]")]),e._v("，而"),v("code",[e._v("someNode.lastChild")]),e._v("的值始终等于"),v("code",[e._v("someNode.childNodes[someNode.childNodes.length-1]")]),e._v("。如果只有一个子节点，则"),v("code",[e._v("firstChild")]),e._v("和"),v("code",[e._v("lastChild")]),e._v("指向同一个节点。如果没有子节点，则"),v("code",[e._v("firstChild")]),e._v("和"),v("code",[e._v("lastChild")]),e._v("都是"),v("code",[e._v("null")]),e._v("。上述这些节点之间的关系为在文档树的节点之间导航提供了方便。图 14-2 形象地展示了这些关系。")]),e._v(" "),v("p",[v("img",{attrs:{src:"http://www.ituring.com.cn/figures/2020/JavaScriptWebDeve4th/022.png",alt:"img"}})]),e._v(" "),v("p",[v("strong",[e._v("图　 14-2")])]),e._v(" "),v("p",[e._v("有了这些关系，"),v("code",[e._v("childNodes")]),e._v("属性的作用远远不止是必备属性那么简单了。这是因为利用这些关系指针，几乎可以访问到文档树中的任何节点，而这种便利性是"),v("code",[e._v("childNodes")]),e._v("的最大亮点。还有一个便利的方法是"),v("code",[e._v("hasChildNodes()")]),e._v("，这个方法如果返回"),v("code",[e._v("true")]),e._v("则说明节点有一个或多个子节点。相比查询"),v("code",[e._v("childNodes")]),e._v("的"),v("code",[e._v("length")]),e._v("属性，这个方法无疑更方便。")]),e._v(" "),v("p",[e._v("最后还有一个所有节点都共享的关系。"),v("code",[e._v("ownerDocument")]),e._v("属性是一个指向代表整个文档的文档节点的指针。所有节点都被创建它们（或自己所在）的文档所拥有，因为一个节点不可能同时存在于两个或者多个文档中。这个属性为迅速访问文档节点提供了便利，因为无需在文档结构中逐层上溯了。")]),e._v(" "),v("blockquote",[v("p",[v("strong",[e._v("注意")]),e._v("　虽然所有节点类型都继承了"),v("code",[e._v("Node")]),e._v("，但并非所有节点都有子节点。本章后面会讨论不同节点类型的差异。")])])])]),e._v(" "),v("ol",{attrs:{start:"3"}},[v("li",[v("p",[v("strong",[e._v("操纵节点")])]),e._v(" "),v("p",[e._v("因为所有关系指针都是只读的，所以 DOM 又提供了一些操纵节点的方法。最常用的方法是"),v("code",[e._v("appendChild()")]),e._v("，用于在"),v("code",[e._v("childNodes")]),e._v("列表末尾添加节点。添加新节点会更新相关的关系指针，包括父节点和之前的最后一个子节点。"),v("code",[e._v("appendChild()")]),e._v("方法返回新添加的节点，如下所示：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("let returnedNode = someNode.appendChild(newNode);\nalert(returnedNode == newNode);        // true\nalert(someNode.lastChild == newNode);  // true\n")])])]),v("p",[e._v("如果把文档中已经存在的节点传给"),v("code",[e._v("appendChild()")]),e._v("，则这个节点会从之前的位置被转移到新位置。即使 DOM 树通过各种关系指针维系，一个节点也不会在文档中同时出现在两个或更多个地方。因此，如果调用"),v("code",[e._v("appendChild()")]),e._v("传入父元素的第一个子节点，则这个节点会成为父元素的最后一个子节点，如下所示：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("// 假设someNode有多个子节点\nlet returnedNode = someNode.appendChild(someNode.firstChild);\nalert(returnedNode == someNode.firstChild);  // false\nalert(returnedNode == someNode.lastChild);   // true\n")])])]),v("p",[e._v("如果想把节点放到"),v("code",[e._v("childNodes")]),e._v("中的特定位置而不是末尾，则可以使用"),v("code",[e._v("insertBefore()")]),e._v("方法。这个方法接收两个参数：要插入的节点和参照节点。调用这个方法后，要插入的节点会变成参照节点的前一个同胞节点，并被返回。如果参照节点是"),v("code",[e._v("null")]),e._v("，则"),v("code",[e._v("insertBefore()")]),e._v("与"),v("code",[e._v("appendChild()")]),e._v("效果相同，如下面的例子所示：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("// 作为最后一个子节点插入\nreturnedNode = someNode.insertBefore(newNode, null);\nalert(newNode == someNode.lastChild);  // true\n\n// 作为新的第一个子节点插入\nreturnedNode = someNode.insertBefore(newNode, someNode.firstChild);\nalert(returnedNode == newNode);         // true\nalert(newNode == someNode.firstChild);  // true\n\n// 插入最后一个子节点前面\nreturnedNode = someNode.insertBefore(newNode, someNode.lastChild);\nalert(newNode == someNode.childNodes[someNode.childNodes.length - 2]); // true\n")])])]),v("p",[v("code",[e._v("appendChild()")]),e._v("和"),v("code",[e._v("insertBefore()")]),e._v("在插入节点时不会删除任何已有节点。相对地，"),v("code",[e._v("replaceChild()")]),e._v("方法接收两个参数：要插入的节点和要替换的节点。要替换的节点会被返回并从文档树中完全移除，要插入的节点会取而代之。下面看一个例子：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("// 替换第一个子节点\nlet returnedNode = someNode.replaceChild(newNode, someNode.firstChild);\n\n// 替换最后一个子节点\nreturnedNode = someNode.replaceChild(newNode, someNode.lastChild);\n")])])]),v("p",[e._v("使用"),v("code",[e._v("replaceChild()")]),e._v("插入一个节点后，所有关系指针都会从被替换的节点复制过来。虽然被替换的节点从技术上说仍然被同一个文档所拥有，但文档中已经没有它的位置。")]),e._v(" "),v("p",[e._v("要移除节点而不是替换节点，可以使用"),v("code",[e._v("removeChild()")]),e._v("方法。这个方法接收一个参数，即要移除的节点。被移除的节点会被返回，如下面的例子所示：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("// 删除第一个子节点\nlet formerFirstChild = someNode.removeChild(someNode.firstChild);\n\n// 删除最后一个子节点\nlet formerLastChild = someNode.removeChild(someNode.lastChild);\n")])])]),v("p",[e._v("与"),v("code",[e._v("replaceChild()")]),e._v("方法一样，通过"),v("code",[e._v("removeChild()")]),e._v("被移除的节点从技术上说仍然被同一个文档所拥有，但文档中已经没有它的位置。")]),e._v(" "),v("p",[e._v("上面介绍的 4 个方法都用于操纵某个节点的子元素，也就是说使用它们之前必须先取得父节点（使用前面介绍的"),v("code",[e._v("parentNode")]),e._v("属性）。并非所有节点类型都有子节点，如果在不支持子节点的节点上调用这些方法，则会导致抛出错误。")])])]),e._v(" "),v("ol",{attrs:{start:"4"}},[v("li",[v("p",[v("strong",[e._v("其他方法")])]),e._v(" "),v("p",[e._v("所有节点类型还共享了两个方法。第一个是"),v("code",[e._v("cloneNode()")]),e._v("，会返回与调用它的节点一模一样的节点。"),v("code",[e._v("cloneNode()")]),e._v("方法接收一个布尔值参数，表示是否深复制。在传入"),v("code",[e._v("true")]),e._v("参数时，会进行深复制，即复制节点及其整个子 DOM 树。如果传入"),v("code",[e._v("false")]),e._v("，则只会复制调用该方法的节点。复制返回的节点属于文档所有，但尚未指定父节点，所以可称为孤儿节点（orphan）。可以通过"),v("code",[e._v("appendChild()")]),e._v("、"),v("code",[e._v("insertBefore()")]),e._v("或"),v("code",[e._v("replaceChild()")]),e._v("方法把孤儿节点添加到文档中。以下面的 HTML 片段为例：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("<ul>\n  <li>item 1</li>\n  <li>item 2</li>\n  <li>item 3</li>\n</ul>\n")])])]),v("p",[e._v("如果"),v("code",[e._v("myList")]),e._v("保存着对这个"),v("code",[e._v("<ul>")]),e._v("元素的引用，则下列代码展示了使用"),v("code",[e._v("cloneNode()")]),e._v("方法的两种方式：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("let deepList = myList.cloneNode(true);\nalert(deepList.childNodes.length);    // 3（IE9之前的版本）或7（其他浏览器）\n\nlet shallowList = myList.cloneNode(false);\nalert(shallowList.childNodes.length); // 0\n")])])]),v("p",[e._v("在这个例子中，"),v("code",[e._v("deepList")]),e._v("保存着"),v("code",[e._v("myList")]),e._v("的副本。这意味着"),v("code",[e._v("deepList")]),e._v("有 3 个列表项，每个列表项又各自包含文本。变量"),v("code",[e._v("shallowList")]),e._v("则保存着"),v("code",[e._v("myList")]),e._v("的浅副本，因此没有子节点。"),v("code",[e._v("deepList.childNodes.length")]),e._v("的值会因 IE8 及更低版本和其他浏览器对空格的处理方式而不同。IE9 之前的版本不会为空格创建节点。")]),e._v(" "),v("blockquote",[v("p",[v("strong",[e._v("注意")]),e._v(" "),v("code",[e._v("cloneNode()")]),e._v("方法不会复制添加到 DOM 节点的 JavaScript 属性，比如事件处理程序。这个方法只复制 HTML 属性，以及可选地复制子节点。除此之外则一概不会复制。IE 在很长时间内会复制事件处理程序，这是一个 bug，所以推荐在复制前先删除事件处理程序。")])]),e._v(" "),v("p",[e._v("本节要介绍的最后一个方法是"),v("code",[e._v("normalize()")]),e._v("。这个方法唯一的任务就是处理文档子树中的文本节点。由于解析器实现的差异或 DOM 操作等原因，可能会出现并不包含文本的文本节点，或者文本节点之间互为同胞关系。在节点上调用"),v("code",[e._v("normalize()")]),e._v("方法会检测这个节点的所有后代，从中搜索上述两种情形。如果发现空文本节点，则将其删除；如果两个同胞节点是相邻的，则将其合并为一个文本节点。这个方法将在本章后面进一步讨论。")])])]),e._v(" "),v("h3",{attrs:{id:"_14-1-2-document类型"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_14-1-2-document类型"}},[e._v("#")]),e._v(" 14.1.2 　"),v("code",[e._v("Document")]),e._v("类型")]),e._v(" "),v("p",[v("code",[e._v("Document")]),e._v("类型是 JavaScript 中表示文档节点的类型。在浏览器中，文档对象"),v("code",[e._v("document")]),e._v("是"),v("code",[e._v("HTMLDocument")]),e._v("的实例（"),v("code",[e._v("HTMLDocument")]),e._v("继承"),v("code",[e._v("Document")]),e._v("），表示整个 HTML 页面。"),v("code",[e._v("document")]),e._v("是"),v("code",[e._v("window")]),e._v("对象的属性，因此是一个全局对象。"),v("code",[e._v("Document")]),e._v("类型的节点有以下特征：")]),e._v(" "),v("ul",[v("li",[v("code",[e._v("nodeType")]),e._v("等于 9；")]),e._v(" "),v("li",[v("code",[e._v("nodeName")]),e._v("值为"),v("code",[e._v('"#document"')]),e._v("；")]),e._v(" "),v("li",[v("code",[e._v("nodeValue")]),e._v("值为"),v("code",[e._v("null")]),e._v("；")]),e._v(" "),v("li",[v("code",[e._v("parentNode")]),e._v("值为"),v("code",[e._v("null")]),e._v("；")]),e._v(" "),v("li",[v("code",[e._v("ownerDocument")]),e._v("值为"),v("code",[e._v("null")]),e._v("；")]),e._v(" "),v("li",[e._v("子节点可以是"),v("code",[e._v("DocumentType")]),e._v("（最多一个）、"),v("code",[e._v("Element")]),e._v("（最多一个）、"),v("code",[e._v("ProcessingInstruction")]),e._v("或"),v("code",[e._v("Comment")]),e._v("类型。")])]),e._v(" "),v("p",[v("code",[e._v("Document")]),e._v("类型可以表示 HTML 页面或其他 XML 文档，但最常用的还是通过"),v("code",[e._v("HTMLDocument")]),e._v("的实例取得"),v("code",[e._v("document")]),e._v("对象。"),v("code",[e._v("document")]),e._v("对象可用于获取关于页面的信息以及操纵其外观和底层结构。")]),e._v(" "),v("ol",[v("li",[v("p",[v("strong",[e._v("文档子节点")])]),e._v(" "),v("p",[e._v("虽然 DOM 规范规定"),v("code",[e._v("Document")]),e._v("节点的子节点可以是"),v("code",[e._v("DocumentType")]),e._v("、"),v("code",[e._v("Element")]),e._v("、"),v("code",[e._v("ProcessingInstruction")]),e._v("或"),v("code",[e._v("Comment")]),e._v("，但也提供了两个访问子节点的快捷方式。第一个是"),v("code",[e._v("documentElement")]),e._v("属性，始终指向 HTML 页面中的"),v("code",[e._v("<html>")]),e._v("元素。虽然"),v("code",[e._v("document.childNodes")]),e._v("中始终有"),v("code",[e._v("<html>")]),e._v("元素，但使用"),v("code",[e._v("documentElement")]),e._v("属性可以更快更直接地访问该元素。假如有以下简单的页面：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("<html>\n  <body>\n\n  </body>\n</html>\n")])])]),v("p",[e._v("浏览器解析完这个页面之后，文档只有一个子节点，即"),v("code",[e._v("<html>")]),e._v("元素。这个元素既可以通过"),v("code",[e._v("documentElement")]),e._v("属性获取，也可以通过"),v("code",[e._v("childNodes")]),e._v("列表访问，如下所示：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("let html = document.documentElement;     // 取得对<html>的引用\nalert(html === document.childNodes[0]);  // true\nalert(html === document.firstChild);     // true\n")])])]),v("p",[e._v("这个例子表明"),v("code",[e._v("documentElement")]),e._v("、 "),v("code",[e._v("firstChild")]),e._v("和"),v("code",[e._v("childNodes[0]")]),e._v("都指向同一个值，即"),v("code",[e._v("<html>")]),e._v("元素。")]),e._v(" "),v("p",[e._v("作为"),v("code",[e._v("HTMLDocument")]),e._v("的实例，"),v("code",[e._v("document")]),e._v("对象还有一个"),v("code",[e._v("body")]),e._v("属性，直接指向"),v("code",[e._v("<body>")]),e._v("元素。因为这个元素是开发者使用最多的元素，所以 JavaScript 代码中经常可以看到"),v("code",[e._v("document.body")]),e._v("，比如：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("let body = document.body; // 取得对<body>的引用\n")])])]),v("p",[e._v("所有主流浏览器都支持"),v("code",[e._v("document.documentElement")]),e._v("和"),v("code",[e._v("document.body")]),e._v("。")]),e._v(" "),v("p",[v("code",[e._v("Document")]),e._v("类型另一种可能的子节点是"),v("code",[e._v("DocumentType")]),e._v("。"),v("code",[e._v("<!doctype>")]),e._v("标签是文档中独立的部分，其信息可以通过"),v("code",[e._v("doctype")]),e._v("属性（在浏览器中是"),v("code",[e._v("document.doctype")]),e._v("）来访问，比如：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("let doctype = document.doctype; // 取得对<!doctype>的引用\n")])])]),v("p",[e._v("另外，严格来讲出现在"),v("code",[e._v("<html>")]),e._v("元素外面的注释也是文档的子节点，它们的类型是"),v("code",[e._v("Comment")]),e._v("。不过，由于浏览器实现不同，这些注释不一定能被识别，或者表现可能不一致。比如以下 HTML 页面：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("\x3c!-- 第一条注释 --\x3e\n<html>\n  <body>\n\n  </body>\n</html>\n\x3c!-- 第二条注释 --\x3e\n")])])]),v("p",[e._v("这个页面看起来有 3 个子节点：注释、"),v("code",[e._v("<html>")]),e._v("元素、注释。逻辑上讲，"),v("code",[e._v("document.childNodes")]),e._v("应该包含 3 项，对应代码中的每个节点。但实际上，浏览器有可能以不同方式对待"),v("code",[e._v("<html>")]),e._v("元素外部的注释，比如忽略一个或两个注释。")]),e._v(" "),v("p",[e._v("一般来说，"),v("code",[e._v("appendChild()")]),e._v("、"),v("code",[e._v("removeChild()")]),e._v("和"),v("code",[e._v("replaceChild()")]),e._v("方法不会用在"),v("code",[e._v("document")]),e._v("对象上。这是因为文档类型（如果存在）是只读的，而且只能有一个"),v("code",[e._v("Element")]),e._v("类型的子节点（即"),v("code",[e._v("<html>")]),e._v("，已经存在了）。"),v("strong",[e._v("1")])])])]),e._v(" "),v("ol",{attrs:{start:"2"}},[v("li",[v("p",[v("strong",[e._v("文档信息")])]),e._v(" "),v("p",[v("code",[e._v("document")]),e._v("作为"),v("code",[e._v("HTMLDocument")]),e._v("的实例，还有一些标准"),v("code",[e._v("Document")]),e._v("对象上所没有的属性。这些属性提供浏览器所加载网页的信息。其中第一个属性是"),v("code",[e._v("title")]),e._v("，包含"),v("code",[e._v("<title>")]),e._v("元素中的文本，通常显示在浏览器窗口或标签页的标题栏。通过这个属性可以读写页面的标题，修改后的标题也会反映在浏览器标题栏上。不过，修改"),v("code",[e._v("title")]),e._v("属性并不会改变"),v("code",[e._v("<title>")]),e._v("元素。下面是一个例子：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v('// 读取文档标题\nlet originalTitle = document.title;\n\n// 修改文档标题\ndocument.title = "New page title";\n')])])]),v("p",[e._v("接下来要介绍的 3 个属性是"),v("code",[e._v("URL")]),e._v("、"),v("code",[e._v("domain")]),e._v("和"),v("code",[e._v("referrer")]),e._v("。其中，"),v("code",[e._v("URL")]),e._v("包含当前页面的完整 URL（地址栏中的 URL），"),v("code",[e._v("domain")]),e._v("包含页面的域名，而"),v("code",[e._v("referrer")]),e._v("包含链接到当前页面的那个页面的 URL。如果当前页面没有来源，则"),v("code",[e._v("referrer")]),e._v("属性包含空字符串。所有这些信息都可以在请求的 HTTP 头部信息中获取，只是在 JavaScript 中通过这几个属性暴露出来而已，如下面的例子所示：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("// 取得完整的URL\nlet url = document.URL;\n\n// 取得域名\nlet domain = document.domain;\n\n// 取得来源\nlet referrer = document.referrer;\n")])])]),v("p",[e._v("URL 跟域名是相关的。比如，如果"),v("code",[e._v("document.URL")]),e._v("是"),v("code",[e._v("http://www.wrox.com/WileyCDA/")]),e._v("，则"),v("code",[e._v("document.domain")]),e._v("就是"),v("code",[e._v("www.wrox.com")]),e._v("。")]),e._v(" "),v("p",[e._v("在这些属性中，只有"),v("code",[e._v("domain")]),e._v("属性是可以设置的。出于安全考虑，给"),v("code",[e._v("domain")]),e._v("属性设置的值是有限制的。如果 URL 包含子域名如"),v("code",[e._v("p2p.wrox.com")]),e._v("，则可以将"),v("code",[e._v("domain")]),e._v("设置为"),v("code",[e._v('"wrox.com"')]),e._v("（URL 包含“www”时也一样，比如"),v("code",[e._v("www.wrox.com")]),e._v("）。不能给这个属性设置 URL 中不包含的值，比如：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v('// 页面来自p2p.wrox.com\n\ndocument.domain = "wrox.com";      // 成功\n\ndocument.domain = "nczonline.net"; // 出错！\n')])])]),v("p",[e._v("当页面中包含来自某个不同子域的窗格（"),v("code",[e._v("<frame>")]),e._v("）或内嵌窗格（"),v("code",[e._v("<iframe>")]),e._v("）时，设置"),v("code",[e._v("document.domain")]),e._v("是有用的。因为跨源通信存在安全隐患，所以不同子域的页面间无法通过 JavaScript 通信。此时，在每个页面上把"),v("code",[e._v("document.domain")]),e._v("设置为相同的值，这些页面就可以访问对方的 JavaScript 对象了。比如，一个加载自"),v("code",[e._v("www.wrox.com")]),e._v("的页面中包含一个内嵌窗格，其中的页面加载自"),v("code",[e._v("p2p.wrox.com")]),e._v("。这两个页面的"),v("code",[e._v("document.domain")]),e._v("包含不同的字符串，内部和外部页面相互之间不能访问对方的 JavaScript 对象。如果每个页面都把"),v("code",[e._v("document.domain")]),e._v("设置为"),v("code",[e._v("wrox.com")]),e._v("，那这两个页面之间就可以通信了。")]),e._v(" "),v("p",[e._v("浏览器对"),v("code",[e._v("domain")]),e._v("属性还有一个限制，即这个属性一旦放松就不能再收紧。比如，把"),v("code",[e._v("document.domain")]),e._v(" 设置为"),v("code",[e._v('"wrox.com"')]),e._v("之后，就不能再将其设置回"),v("code",[e._v('"p2p.wrox.com"')]),e._v("，后者会导致错误，比如：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v('// 页面来自p2p.wrox.com\n\ndocument.domain = "wrox.com";     // 放松，成功\n\ndocument.domain = "p2p.wrox.com"; // 收紧，错误！\n')])])])])]),e._v(" "),v("ol",{attrs:{start:"3"}},[v("li",[v("p",[v("strong",[e._v("定位元素")])]),e._v(" "),v("p",[e._v("使用 DOM 最常见的情形可能就是获取某个或某组元素的引用，然后对它们执行某些操作。"),v("code",[e._v("document")]),e._v("对象上暴露了一些方法，可以实现这些操作。"),v("code",[e._v("getElementById()")]),e._v("和"),v("code",[e._v("getElementsByTagName()")]),e._v("就是"),v("code",[e._v("Document")]),e._v("类型提供的两个方法。")]),e._v(" "),v("p",[v("code",[e._v("getElementById()")]),e._v("方法接收一个参数，即要获取元素的 ID，如果找到了则返回这个元素，如果没找到则返回"),v("code",[e._v("null")]),e._v("。参数 ID 必须跟元素在页面中的"),v("code",[e._v("id")]),e._v("属性值完全匹配，包括大小写。比如页面中有以下元素：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v('<div id="myDiv">Some text</div>\n')])])]),v("p",[e._v("可以使用如下代码取得这个元素：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v('let div = document.getElementById("myDiv"); // 取得对这个<div>元素的引用\n')])])]),v("p",[e._v("但参数大小写不匹配会返回"),v("code",[e._v("null")]),e._v("：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v('let div = document.getElementById("mydiv"); // null\n')])])]),v("p",[e._v("如果页面中存在多个具有相同 ID 的元素，则"),v("code",[e._v("getElementById()")]),e._v("返回在文档中出现的第一个元素。")]),e._v(" "),v("p",[v("code",[e._v("getElementsByTagName()")]),e._v("是另一个常用来获取元素引用的方法。这个方法接收一个参数，即要获取元素的标签名，返回包含零个或多个元素的"),v("code",[e._v("NodeList")]),e._v("。在 HTML 文档中，这个方法返回一个"),v("code",[e._v("HTMLCollection")]),e._v("对象。考虑到二者都是“实时”列表，"),v("code",[e._v("HTMLCollection")]),e._v("与"),v("code",[e._v("NodeList")]),e._v("是很相似的。例如，下面的代码会取得页面中所有的"),v("code",[e._v("<img>")]),e._v("元素并返回包含它们的"),v("code",[e._v("HTMLCollection")]),e._v("：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v('let images = document.getElementsByTagName("img");\n')])])]),v("p",[e._v("这里把返回的"),v("code",[e._v("HTMLCollection")]),e._v("对象保存在了变量"),v("code",[e._v("images")]),e._v("中。与"),v("code",[e._v("NodeList")]),e._v("对象一样，也可以使用中括号或"),v("code",[e._v("item()")]),e._v("方法从"),v("code",[e._v("HTMLCollection")]),e._v("取得特定的元素。而取得元素的数量同样可以通过"),v("code",[e._v("length")]),e._v("属性得知，如下所示：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("alert(images.length);       // 图片数量\nalert(images[0].src);       // 第一张图片的src属性\nalert(images.item(0).src);  // 同上\n")])])]),v("p",[v("code",[e._v("HTMLCollection")]),e._v("对象还有一个额外的方法"),v("code",[e._v("namedItem()")]),e._v("，可通过标签的"),v("code",[e._v("name")]),e._v("属性取得某一项的引用。例如，假设页面中包含如下的"),v("code",[e._v("<img>")]),e._v("元素：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v('<img src="myimage.gif" name="myImage">\n')])])]),v("p",[e._v("那么也可以像这样从"),v("code",[e._v("images")]),e._v("中取得对这个"),v("code",[e._v("<img>")]),e._v("元素的引用：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v('let myImage = images.namedItem("myImage");\n')])])]),v("p",[e._v("这样，"),v("code",[e._v("HTMLCollection")]),e._v("就提供了除索引之外的另一种获取列表项的方式，从而为取得元素提供了便利。对于"),v("code",[e._v("name")]),e._v("属性的元素，还可以直接使用中括号来获取，如下面的例子所示：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v('let myImage = images["myImage"];\n')])])]),v("p",[e._v("对"),v("code",[e._v("HTMLCollection")]),e._v("对象而言，中括号既可以接收数值索引，也可以接收字符串索引。而在后台，数值索引会调用"),v("code",[e._v("item()")]),e._v("，字符串索引会调用"),v("code",[e._v("namedItem()")]),e._v("。")]),e._v(" "),v("p",[e._v("要取得文档中的所有元素，可以给"),v("code",[e._v("getElementsByTagName()")]),e._v("传入"),v("code",[e._v("*")]),e._v("。在 JavaScript 和 CSS 中，"),v("code",[e._v("*")]),e._v("一般被认为是匹配一切的字符。来看下面的例子：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v('let allElements = document.getElementsByTagName("*");\n')])])]),v("p",[e._v("这行代码可以返回包含页面中所有元素的"),v("code",[e._v("HTMLCollection")]),e._v("对象，顺序就是它们在页面中出现的顺序。因此第一项是"),v("code",[e._v("<html>")]),e._v("元素，第二项是"),v("code",[e._v("<head>")]),e._v("元素，以此类推。")]),e._v(" "),v("blockquote",[v("p",[v("strong",[e._v("注意")]),e._v("　对于"),v("code",[e._v("document.getElementsByTagName()")]),e._v("方法，虽然规范要求区分标签的大小写，但为了最大限度兼容原有 HTML 页面，实际上是不区分大小写的。如果是在 XML 页面（如 XHTML）中使用，那么"),v("code",[e._v("document.getElementsByTagName()")]),e._v("就是区分大小写的。")])]),e._v(" "),v("p",[v("code",[e._v("HTMLDocument")]),e._v("类型上定义的获取元素的第三个方法是"),v("code",[e._v("getElementsByName()")]),e._v("。顾名思义，这个方法会返回具有给定"),v("code",[e._v("name")]),e._v("属性的所有元素。"),v("code",[e._v("getElementsByName()")]),e._v("方法最常用于单选按钮，因为同一字段的单选按钮必须具有相同的"),v("code",[e._v("name")]),e._v("属性才能确保把正确的值发送给服务器，比如下面的例子：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v('<fieldset>\n  <legend>Which color do you prefer?</legend>\n  <ul>\n    <li>\n      <input type="radio" value="red" name="color" id="colorRed">\n      <label for="colorRed">Red</label>\n    </li>\n    <li>\n      <input type="radio" value="green" name="color" id="colorGreen">\n      <label for="colorGreen">Green</label>\n    </li>\n    <li>\n      <input type="radio" value="blue" name="color" id="colorBlue">\n      <label for="colorBlue">Blue</label>\n    </li>\n  </ul>\n</fieldset>\n')])])]),v("p",[e._v("这里所有的单选按钮都有名为"),v("code",[e._v('"color"')]),e._v("的"),v("code",[e._v("name")]),e._v("属性，但它们的 ID 都不一样。这是因为 ID 是为了匹配对应的"),v("code",[e._v("<label>")]),e._v("元素，而"),v("code",[e._v("name")]),e._v("相同是为了保证只将三个中的一个值发送给服务器。然后就可以像下面这样取得所有单选按钮：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v('let radios = document.getElementsByName("color");\n')])])]),v("p",[e._v("与"),v("code",[e._v("getElementsByTagName()")]),e._v("一样，"),v("code",[e._v("getElementsByName()")]),e._v("方法也返回"),v("code",[e._v("HTMLCollection")]),e._v("。不过在这种情况下，"),v("code",[e._v("namedItem()")]),e._v("方法只会取得第一项（因为所有项的"),v("code",[e._v("name")]),e._v("属性都一样）。")])])]),e._v(" "),v("ol",{attrs:{start:"4"}},[v("li",[v("p",[v("strong",[e._v("特殊集合")])]),e._v(" "),v("p",[v("code",[e._v("document")]),e._v("对象上还暴露了几个特殊集合，这些集合也都是"),v("code",[e._v("HTMLCollection")]),e._v("的实例。这些集合是访问文档中公共部分的快捷方式，列举如下。")]),e._v(" "),v("ul",[v("li",[v("code",[e._v("document.anchors")]),e._v("包含文档中所有带"),v("code",[e._v("name")]),e._v("属性的"),v("code",[e._v("<a>")]),e._v("元素。")]),e._v(" "),v("li",[v("code",[e._v("document.applets")]),e._v("包含文档中所有"),v("code",[e._v("<applet>")]),e._v("元素（因为"),v("code",[e._v("<applet>")]),e._v("元素已经不建议使用，所以这个集合已经废弃）。")]),e._v(" "),v("li",[v("code",[e._v("document.forms")]),e._v("包含文档中所有"),v("code",[e._v("<form>")]),e._v("元素（与"),v("code",[e._v('document.getElementsByTagName ("form")')]),e._v("返回的结果相同）。")]),e._v(" "),v("li",[v("code",[e._v("document.images")]),e._v("包含文档中所有"),v("code",[e._v("<img>")]),e._v("元素（与"),v("code",[e._v('document.getElementsByTagName ("img")')]),e._v("返回的结果相同）。")]),e._v(" "),v("li",[v("code",[e._v("document.links")]),e._v("包含文档中所有带"),v("code",[e._v("href")]),e._v("属性的"),v("code",[e._v("<a>")]),e._v("元素。")])]),e._v(" "),v("p",[e._v("这些特殊集合始终存在于"),v("code",[e._v("HTMLDocument")]),e._v("对象上，而且与所有"),v("code",[e._v("HTMLCollection")]),e._v("对象一样，其内容也会实时更新以符合当前文档的内容。")])])]),e._v(" "),v("ol",{attrs:{start:"5"}},[v("li",[v("p",[v("strong",[e._v("DOM 兼容性检测")])]),e._v(" "),v("p",[e._v("由于 DOM 有多个 Level 和多个部分，因此确定浏览器实现了 DOM 的哪些部分是很必要的。"),v("code",[e._v("document.implementation")]),e._v("属性是一个对象，其中提供了与浏览器 DOM 实现相关的信息和能力。DOM Level 1 在"),v("code",[e._v("document.implementation")]),e._v("上只定义了一个方法，即"),v("code",[e._v("hasFeature()")]),e._v("。这个方法接收两个参数：特性名称和 DOM 版本。如果浏览器支持指定的特性和版本，则"),v("code",[e._v("hasFeature()")]),e._v("方法返回"),v("code",[e._v("true")]),e._v("，如下面的例子所示：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v('let hasXmlDom = document.implementation.hasFeature("XML", "1.0");\n')])])]),v("p",[e._v("可以使用"),v("code",[e._v("hasFeature()")]),e._v("方法测试的特性及版本如下表所列。")]),e._v(" "),v("table",[v("thead",[v("tr",[v("th",{staticStyle:{"text-align":"left"}},[e._v("特性")]),e._v(" "),v("th",{staticStyle:{"text-align":"left"}},[e._v("支持的版本")]),e._v(" "),v("th",{staticStyle:{"text-align":"left"}},[e._v("说明")])])]),e._v(" "),v("tbody",[v("tr",[v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("Core")])]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[e._v("1.0、2.0、3.0")]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[e._v("定义树形文档结构的基本 DOM")])]),e._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("XML")])]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[e._v("1.0、2.0、3.0")]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("Core")]),e._v("的 XML 扩展，增加了对 CDATA 区块、处理指令和实体的支持")])]),e._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("HTML")])]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[e._v("1.0、2.0")]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("XML")]),e._v("的 HTML 扩展，增加了 HTML 特定的元素和实体")])]),e._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("Views")])]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[e._v("2.0")]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[e._v("文档基于某些样式的实现格式")])]),e._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("StyleSheets")])]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[e._v("2.0")]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[e._v("文档的相关样式表")])]),e._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("CSS")])]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[e._v("2.0")]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[e._v("Cascading Style Sheets Level 1")])]),e._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("CSS2")])]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[e._v("2.0")]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[e._v("Cascading Style Sheets Level 2")])]),e._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("Events")])]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[e._v("2.0、3.0")]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[e._v("通用 DOM 事件")])]),e._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("UIEvents")])]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[e._v("2.0、3.0")]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[e._v("用户界面事件")])]),e._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("TextEvents")])]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[e._v("3.0")]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[e._v("文本输入设备触发的事件")])]),e._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("MouseEvents")])]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[e._v("2.0、3.0")]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[e._v("鼠标导致的事件（单击、悬停等）")])]),e._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("MutationEvents")])]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[e._v("2.0、3.0")]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[e._v("DOM 树变化时触发的事件")])]),e._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("MutationNameEvents")])]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[e._v("3.0")]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[e._v("DOM 元素或元素属性被重命名时触发的事件")])]),e._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("HTMLEvents")])]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[e._v("2.0")]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[e._v("HTML 4.01 事件")])]),e._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("Range")])]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[e._v("2.0")]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[e._v("在 DOM 树中操作一定范围的对象和方法")])]),e._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("Traversal")])]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[e._v("2.0")]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[e._v("遍历 DOM 树的方法")])]),e._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("LS")])]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[e._v("3.0")]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[e._v("文件与 DOM 树之间的同步加载与保存")])]),e._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("LS-Async")])]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[e._v("3.0")]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[e._v("文件与 DOM 树之间的异步加载与保存")])]),e._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("Validation")])]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[e._v("3.0")]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[e._v("修改 DOM 树并保证其继续有效的方法")])]),e._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("XPath")])]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[e._v("3.0")]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[e._v("访问 XML 文档不同部分的语言")])])])]),e._v(" "),v("p",[e._v("由于实现不一致，因此"),v("code",[e._v("hasFeature()")]),e._v("的返回值并不可靠。目前这个方法已经被废弃，不再建议使用。为了向后兼容，目前主流浏览器仍然支持这个方法，但无论检测什么都一律返回"),v("code",[e._v("true")]),e._v("。")])])]),e._v(" "),v("ol",{attrs:{start:"6"}},[v("li",[v("p",[v("strong",[e._v("文档写入")])]),e._v(" "),v("p",[v("code",[e._v("document")]),e._v("对象有一个古老的能力，即向网页输出流中写入内容。这个能力对应 4 个方法："),v("code",[e._v("write()")]),e._v("、"),v("code",[e._v("writeln()")]),e._v("、"),v("code",[e._v("open()")]),e._v("和"),v("code",[e._v("close()")]),e._v("。其中，"),v("code",[e._v("write()")]),e._v("和"),v("code",[e._v("writeln()")]),e._v("方法都接收一个字符串参数，可以将这个字符串写入网页中。"),v("code",[e._v("write()")]),e._v("简单地写入文本，而"),v("code",[e._v("writeln()")]),e._v("还会在字符串末尾追加一个换行符（"),v("code",[e._v("\\n")]),e._v("）。这两个方法可以用来在页面加载期间向页面中动态添加内容，如下所示：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v('<html>\n<head>\n  <title>document.write() Example</title>\n</head>\n<body>\n  <p>The current date and time is:\n  <script type="text/javascript">\n    document.write("<strong>" + (new Date()).toString() + "</strong>");\n  <\/script>\n</p>\n</body>\n</html>\n')])])]),v("p",[e._v("这个例子会在页面加载过程中输出当前日期和时间。日期放在了"),v("code",[e._v("<strong>")]),e._v("元素中，如同它们之前就包含在 HTML 页面中一样。这意味着会创建一个 DOM 元素，以后也可以访问。通过"),v("code",[e._v("write()")]),e._v("和"),v("code",[e._v("writeln()")]),e._v("输出的任何 HTML 都会以这种方式来处理。")]),e._v(" "),v("p",[v("code",[e._v("write()")]),e._v("和"),v("code",[e._v("writeln()")]),e._v("方法经常用于动态包含外部资源，如 JavaScript 文件。在包含 JavaScript 文件时，记住不能像下面的例子中这样直接包含字符串"),v("code",[e._v('"<\/script>"')]),e._v("，因为这个字符串会被解释为脚本块的结尾，导致后面的代码不能执行：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v('<html>\n<head>\n  <title>document.write() Example</title>\n</head>\n<body>\n  <script type="text/javascript">\n    document.write("<script type=\\"text/javascript\\" src=\\"file.js\\">" +\n      "<\/script>");\n  <\/script>\n</body>\n</html>\n')])])]),v("p",[e._v("虽然这样写看起来没错，但输出之后的"),v("code",[e._v('"<\/script>"')]),e._v("会匹配最外层的"),v("code",[e._v("<script>")]),e._v("标签，导致页面中显示出"),v("code",[e._v('");')]),e._v("。为避免出现这个问题，需要对前面的例子稍加修改：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v('<html>\n<head>\n  <title>document.write() Example</title>\n</head>\n<body>\n  <script type="text/javascript">\n    document.write("<script type=\\"text/javascript\\" src=\\"file.js\\">" +\n      "<\\/script>");\n  <\/script>\n</body>\n</html>\n')])])]),v("p",[e._v("这里的字符串"),v("code",[e._v('"<\\/script>"')]),e._v("不会再匹配最外层的"),v("code",[e._v("<script>")]),e._v("标签，因此不会在页面中输出额外内容。")]),e._v(" "),v("p",[e._v("前面的例子展示了在页面渲染期间通过"),v("code",[e._v("document.write()")]),e._v("向文档中输出内容。如果是在页面加载完之后再调用"),v("code",[e._v("document.write()")]),e._v("，则输出的内容会重写整个页面，如下面的例子所示：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v('<html>\n<head>\n  <title>document.write() Example</title>\n</head>\n<body>\n  <p>This is some content that you won\'t get to see because it will be\n  overwritten.</p>\n  <script type="text/javascript">\n    window.onload = function(){\n      document.write("Hello world!");\n    };\n  <\/script>\n</body>\n</html>\n')])])]),v("p",[e._v("这个例子使用了"),v("code",[e._v("window.onload")]),e._v("事件处理程序，将调用"),v("code",[e._v("document.write()")]),e._v("的函数推迟到页面加载完毕后执行。执行之后，字符串"),v("code",[e._v('"Hello world!"')]),e._v("会重写整个页面内容。")]),e._v(" "),v("p",[v("code",[e._v("open()")]),e._v("和"),v("code",[e._v("close()")]),e._v("方法分别用于打开和关闭网页输出流。在调用"),v("code",[e._v("write()")]),e._v("和"),v("code",[e._v("writeln()")]),e._v("时，这两个方法都不是必需的。")]),e._v(" "),v("blockquote",[v("p",[v("strong",[e._v("注意")]),e._v("　严格的 XHTML 文档不支持文档写入。对于内容类型为"),v("code",[e._v("application")]),e._v("/"),v("code",[e._v("xml")]),e._v("+"),v("code",[e._v("xhtml")]),e._v("的页面，这些方法不起作用。")])])])]),e._v(" "),v("p",[v("strong",[e._v("1")]),e._v("元素是"),v("code",[e._v("HTMLHtmlElement")]),e._v("的实例，"),v("code",[e._v("HTMLHtmlElement")]),e._v("继承"),v("code",[e._v("HTMLElement")]),e._v("，"),v("code",[e._v("HTMLElement")]),e._v("继承"),v("code",[e._v("Element")]),e._v("，因此 HTML 文档可以包含子节点，但不能多于一个。——译者注")]),e._v(" "),v("h3",{attrs:{id:"_14-1-3-element类型"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_14-1-3-element类型"}},[e._v("#")]),e._v(" 14.1.3 　"),v("code",[e._v("Element")]),e._v("类型")]),e._v(" "),v("p",[e._v("除了"),v("code",[e._v("Document")]),e._v("类型，"),v("code",[e._v("Element")]),e._v("类型就是 Web 开发中最常用的类型了。"),v("code",[e._v("Element")]),e._v("表示 XML 或 HTML 元素，对外暴露出访问元素标签名、子节点和属性的能力。"),v("code",[e._v("Element")]),e._v("类型的节点具有以下特征：")]),e._v(" "),v("ul",[v("li",[v("code",[e._v("nodeType")]),e._v("等于 1；")]),e._v(" "),v("li",[v("code",[e._v("nodeName")]),e._v("值为元素的标签名；")]),e._v(" "),v("li",[v("code",[e._v("nodeValue")]),e._v("值为"),v("code",[e._v("null")]),e._v("；")]),e._v(" "),v("li",[v("code",[e._v("parentNode")]),e._v("值为"),v("code",[e._v("Document")]),e._v("或"),v("code",[e._v("Element")]),e._v("对象；")]),e._v(" "),v("li",[e._v("子节点可以是"),v("code",[e._v("Element")]),e._v("、"),v("code",[e._v("Text")]),e._v("、"),v("code",[e._v("Comment")]),e._v("、"),v("code",[e._v("ProcessingInstruction")]),e._v("、"),v("code",[e._v("CDATASection")]),e._v("、"),v("code",[e._v("EntityReference")]),e._v("类型。")])]),e._v(" "),v("p",[e._v("可以通过"),v("code",[e._v("nodeName")]),e._v("或"),v("code",[e._v("tagName")]),e._v("属性来获取元素的标签名。这两个属性返回同样的值（添加后一个属性明显是为了不让人误会）。比如有下面的元素：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v('<div id="myDiv"></div>\n')])])]),v("p",[e._v("可以像这样取得这个元素的标签名：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v('let div = document.getElementById("myDiv");\nalert(div.tagName); // "DIV"\nalert(div.tagName == div.nodeName); // true\n')])])]),v("p",[e._v("例子中的元素标签名为"),v("code",[e._v("div")]),e._v("，ID 为"),v("code",[e._v('"myDiv"')]),e._v("。注意，"),v("code",[e._v("div.tagName")]),e._v("实际上返回的是"),v("code",[e._v('"DIV"')]),e._v("而不是"),v("code",[e._v('"div"')]),e._v("。在 HTML 中，元素标签名始终以全大写表示；在 XML（包括 XHTML）中，标签名始终与源代码中的大小写一致。如果不确定脚本是在 HTML 文档还是 XML 文档中运行，最好将标签名转换为小写形式，以便于比较：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v('if (element.tagName == "div"){ // 不要这样做，可能出错！\n  // do something here\n}\n\nif (element.tagName.toLowerCase() == "div"){ // 推荐，适用于所有文档\n  // 做点什么\n}\n')])])]),v("p",[e._v("这个例子演示了比较"),v("code",[e._v("tagName")]),e._v("属性的情形。第一个是容易出错的写法，因为 HTML 文档中"),v("code",[e._v("tagName")]),e._v("返回大写形式的标签名。第二个先把标签名转换为全部小写后再比较，这是推荐的做法，因为这对 HTML 和 XML 都适用。")]),e._v(" "),v("ol",[v("li",[v("p",[v("strong",[e._v("HTML 元素")])]),e._v(" "),v("p",[e._v("所有 HTML 元素都通过"),v("code",[e._v("HTMLElement")]),e._v("类型表示，包括其直接实例和间接实例。另外，"),v("code",[e._v("HTMLElement")]),e._v("直接继承"),v("code",[e._v("Element")]),e._v("并增加了一些属性。每个属性都对应下列属性之一，它们是所有 HTML 元素上都有的标准属性：")]),e._v(" "),v("ul",[v("li",[v("code",[e._v("id")]),e._v("，元素在文档中的唯一标识符；")]),e._v(" "),v("li",[v("code",[e._v("title")]),e._v("，包含元素的额外信息，通常以提示条形式展示；")]),e._v(" "),v("li",[v("code",[e._v("lang")]),e._v("，元素内容的语言代码（很少用）；")]),e._v(" "),v("li",[v("code",[e._v("dir")]),e._v("，语言的书写方向（"),v("code",[e._v('"ltr"')]),e._v("表示从左到右，"),v("code",[e._v('"rtl"')]),e._v("表示从右到左，同样很少用）；")]),e._v(" "),v("li",[v("code",[e._v("className")]),e._v("，相当于"),v("code",[e._v("class")]),e._v("属性，用于指定元素的 CSS 类（因为"),v("code",[e._v("class")]),e._v("是 ECMAScript 关键字，所以不能直接用这个名字）。")])]),e._v(" "),v("p",[e._v("所有这些都可以用来获取对应的属性值，也可以用来修改相应的值。比如有下面的 HTML 元素：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v('<div id="myDiv" class="bd" title="Body text" lang="en" dir="ltr"></div>\n')])])]),v("p",[e._v("这个元素中的所有属性都可以使用下列 JavaScript 代码读取：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v('let div = document.getElementById("myDiv");\nalert(div.id);         // "myDiv"\nalert(div.className);  // "bd"\nalert(div.title);      // "Body text"\nalert(div.lang);       // "en"\nalert(div.dir);        // "ltr"\n')])])]),v("p",[e._v("而且，可以使用下列代码修改元素的属性：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v('div.id = "someOtherId";\ndiv.className = "ft";\ndiv.title = "Some other text";\ndiv.lang = "fr";\ndiv.dir ="rtl";\n')])])]),v("p",[e._v("并非所有这些属性的修改都会对页面产生影响。比如，把"),v("code",[e._v("id")]),e._v("或"),v("code",[e._v("lang")]),e._v("改成其他值对用户是不可见的（假设没有基于这两个属性应用 CSS 样式），而修改"),v("code",[e._v("title")]),e._v("属性则只会在鼠标移到这个元素上时才会反映出来。修改"),v("code",[e._v("dir")]),e._v("会导致页面文本立即向左或向右对齐。修改"),v("code",[e._v("className")]),e._v("会立即反映应用到新类名的 CSS 样式（如果定义了不同的样式）。")]),e._v(" "),v("p",[e._v("如前所述，所有 HTML 元素都是"),v("code",[e._v("HTMLElement")]),e._v("或其子类型的实例。下表列出了所有 HTML 元素及其对应的类型（斜体表示已经废弃的元素）。")]),e._v(" "),v("table",[v("thead",[v("tr",[v("th",{staticStyle:{"text-align":"left"}},[e._v("元素")]),e._v(" "),v("th",{staticStyle:{"text-align":"left"}},[e._v("类型")]),e._v(" "),v("th",{staticStyle:{"text-align":"left"}},[e._v("元素")]),e._v(" "),v("th",{staticStyle:{"text-align":"left"}},[e._v("类型")])])]),e._v(" "),v("tbody",[v("tr",[v("td",{staticStyle:{"text-align":"left"}},[e._v("A")]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("HTMLAnchorElement")])]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[e._v("COL")]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("HTMLTableColElement")])])]),e._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"left"}},[e._v("ABBR")]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("HTMLElement")])]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[e._v("COLGROUP")]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("HTMLTableColElement")])])]),e._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"left"}},[e._v("ACRONYM")]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("HTMLElement")])]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[e._v("DD")]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("HTMLElement")])])]),e._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"left"}},[e._v("ADDRESS")]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("HTMLElement")])]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[e._v("DEL")]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("HTMLModElement")])])]),e._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"left"}},[v("em",[e._v("APPLET")])]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("*HTMLAppletElement*")])]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[e._v("DFN")]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("HTMLElement")])])]),e._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"left"}},[e._v("AREA")]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("HTMLAreaElement")])]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[v("em",[e._v("DIR")])]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("*HTMLDirectoryElement*")])])]),e._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"left"}},[e._v("B")]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("HTMLElement")])]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[e._v("DIV")]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("HTMLDivElement")])])]),e._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"left"}},[e._v("BASE")]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("HTMLBaseElement")])]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[e._v("DL")]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("HTMLDListElement")])])]),e._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"left"}},[v("em",[e._v("BASEFONT")])]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("*HTMLBaseFontElement*")])]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[e._v("DT")]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("HTMLElement")])])]),e._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"left"}},[e._v("BDO")]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("HTMLElement")])]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[e._v("EM")]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("HTMLElement")])])]),e._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"left"}},[e._v("BIG")]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("HTMLElement")])]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[e._v("FIELDSET")]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("HTMLFieldSetElement")])])]),e._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"left"}},[e._v("BLOCKQUOTE")]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("HTMLQuoteElement")])]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[v("em",[e._v("FONT")])]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("*HTMLFontElement*")])])]),e._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"left"}},[e._v("BODY")]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("HTMLBodyElement")])]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[e._v("FORM")]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("HTMLFormElement")])])]),e._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"left"}},[e._v("BR")]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("HTMLBRElement")])]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[e._v("FRAME")]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("HTMLFrameElement")])])]),e._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"left"}},[e._v("BUTTON")]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("HTMLButtonElement")])]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[e._v("FRAMESET")]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("HTMLFrameSetElement")])])]),e._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"left"}},[e._v("CAPTION")]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("HTMLTableCaption Element")])]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[e._v("H1")]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("HTMLHeadingElement")])])]),e._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"left"}},[v("em",[e._v("CENTER")])]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("*HTMLElement*")])]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[e._v("H2")]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("HTMLHeadingElement")])])]),e._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"left"}},[e._v("CITE")]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("HTMLElement")])]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[e._v("H3")]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("HTMLHeadingElement")])])]),e._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"left"}},[e._v("CODE")]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("HTMLElement")])]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[e._v("H4")]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("HTMLHeadingElement")])])]),e._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"left"}},[e._v("H5")]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("HTMLHeadingElement")])]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[e._v("PRE")]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("HTMLPreElement")])])]),e._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"left"}},[e._v("H6")]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("HTMLHeadingElement")])]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[e._v("Q")]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("HTMLQuoteElement")])])]),e._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"left"}},[e._v("HEAD")]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("HTMLHeadElement")])]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[v("em",[e._v("S")])]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("*HTMLElement*")])])]),e._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"left"}},[e._v("HR")]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("HTMLHRElement")])]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[e._v("SAMP")]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("HTMLElement")])])]),e._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"left"}},[e._v("HTML")]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("HTMLHtmlElement")])]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[e._v("SCRIPT")]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("HTMLScriptElement")])])]),e._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"left"}},[e._v("I")]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("HTMLElement")])]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[e._v("SELECT")]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("HTMLSelectElement")])])]),e._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"left"}},[e._v("IFRAME")]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("HTMLIFrameElement")])]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[e._v("SMALL")]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("HTMLElement")])])]),e._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"left"}},[e._v("IMG")]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("HTMLImageElement")])]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[e._v("SPAN")]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("HTMLElement")])])]),e._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"left"}},[e._v("INPUT")]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("HTMLInputElement")])]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[v("em",[e._v("STRIKE")])]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("*HTMLElement*")])])]),e._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"left"}},[e._v("INS")]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("HTMLModElement")])]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[e._v("STRONG")]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("HTMLElement")])])]),e._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"left"}},[v("em",[e._v("ISINDEX")])]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("*HTMLIsIndexElement*")])]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[e._v("STYLE")]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("HTMLStyleElement")])])]),e._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"left"}},[e._v("KBD")]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("HTMLElement")])]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[e._v("SUB")]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("HTMLElement")])])]),e._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"left"}},[e._v("LABEL")]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("HTMLLabelElement")])]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[e._v("SUP")]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("HTMLElement")])])]),e._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"left"}},[e._v("LEGEND")]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("HTMLLegendElement")])]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[e._v("TABLE")]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("HTMLTableElement")])])]),e._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"left"}},[e._v("LI")]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("HTMLLIElement")])]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[e._v("TBODY")]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("HTMLTableSectionElement")])])]),e._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"left"}},[e._v("LINK")]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("HTMLLinkElement")])]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[e._v("TD")]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("HTMLTableCellElement")])])]),e._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"left"}},[e._v("MAP")]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("HTMLMapElement")])]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[e._v("TEXTAREA")]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("HTMLTextAreaElement")])])]),e._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"left"}},[v("em",[e._v("MENU")])]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("*HTMLMenuElement*")])]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[e._v("TFOOT")]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("HTMLTableSectionElement")])])]),e._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"left"}},[e._v("META")]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("HTMLMetaElement")])]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[e._v("TH")]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("HTMLTableCellElement")])])]),e._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"left"}},[e._v("NOFRAMES")]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("HTMLElement")])]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[e._v("THEAD")]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("HTMLTableSectionElement")])])]),e._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"left"}},[e._v("NOSCRIPT")]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("HTMLElement")])]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[e._v("TITLE")]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("HTMLTitleElement")])])]),e._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"left"}},[e._v("OBJECT")]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("HTMLObjectElement")])]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[e._v("TR")]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("HTMLTableRowElement")])])]),e._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"left"}},[e._v("OL")]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("HTMLOListElement")])]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[e._v("TT")]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("HTMLElement")])])]),e._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"left"}},[e._v("OPTGROUP")]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("HTMLOptGroupElement")])]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[v("em",[e._v("U")])]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("*HTMLElement*")])])]),e._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"left"}},[e._v("OPTION")]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("HTMLOptionElement")])]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[e._v("UL")]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("HTMLUListElement")])])]),e._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"left"}},[e._v("P")]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("HTMLParagraphElement")])]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[e._v("VAR")]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("HTMLElement")])])]),e._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"left"}},[e._v("PARAM")]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("HTMLParamElement")])]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}}),e._v(" "),v("td",{staticStyle:{"text-align":"left"}})])])]),e._v(" "),v("p",[e._v("这里列出的每种类型都有关联的属性和方法。本书会涉及其中的很多类型。")])])]),e._v(" "),v("ol",{attrs:{start:"2"}},[v("li",[v("p",[v("strong",[e._v("取得属性")])]),e._v(" "),v("p",[e._v("每个元素都有零个或多个属性，通常用于为元素或其内容附加更多信息。与属性相关的 DOM 方法主要有 3 个："),v("code",[e._v("getAttribute()")]),e._v("、"),v("code",[e._v("setAttribute()")]),e._v("和"),v("code",[e._v("removeAttribute()")]),e._v("。这些方法主要用于操纵属性，包括在"),v("code",[e._v("HTMLElement")]),e._v("类型上定义的属性。下面看一个例子：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v('let div = document.getElementById("myDiv");\nalert(div.getAttribute("id"));     // "myDiv"\nalert(div.getAttribute("class"));  // "bd"\nalert(div.getAttribute("title"));  // "Body text"\nalert(div.getAttribute("lang"));   // "en"\nalert(div.getAttribute("dir"));    // "ltr"\n')])])]),v("p",[e._v("注意传给"),v("code",[e._v("getAttribute()")]),e._v("的属性名与它们实际的属性名是一样的，因此这里要传"),v("code",[e._v('"class"')]),e._v("而非"),v("code",[e._v('"className"')]),e._v("（"),v("code",[e._v("className")]),e._v("是作为对象属性时才那么拼写的）。如果给定的属性不存在，则"),v("code",[e._v("getAttribute()")]),e._v("返回"),v("code",[e._v("null")]),e._v("。")]),e._v(" "),v("p",[v("code",[e._v("getAttribute()")]),e._v("方法也能取得不是 HTML 语言正式属性的自定义属性的值。比如下面的元素：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v('<div id="myDiv" my_special_attribute="hello!"></div>\n')])])]),v("p",[e._v("这个元素有一个自定义属性"),v("code",[e._v("my_special_attribute")]),e._v("，值为"),v("code",[e._v('"hello!"')]),e._v("。可以像其他属性一样使用"),v("code",[e._v("getAttribute()")]),e._v("取得这个属性的值：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v('let value = div.getAttribute("my_special_attribute");\n')])])]),v("p",[e._v("注意，属性名不区分大小写，因此"),v("code",[e._v('"ID"')]),e._v("和"),v("code",[e._v('"id"')]),e._v("被认为是同一个属性。另外，根据 HTML5 规范的要求，自定义属性名应该前缀"),v("code",[e._v("data-")]),e._v("以方便验证。")]),e._v(" "),v("p",[e._v("元素的所有属性也可以通过相应 DOM 元素对象的属性来取得。当然，这包括"),v("code",[e._v("HTMLElement")]),e._v("上定义的直接映射对应属性的 5 个属性，还有所有公认（非自定义）的属性也会被添加为 DOM 对象的属性。比如下面的例子：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v('<div id="myDiv" align="left" my_special_attribute="hello"></div>\n')])])]),v("p",[e._v("因为"),v("code",[e._v("id")]),e._v("和"),v("code",[e._v("align")]),e._v("在 HTML 中是"),v("code",[e._v("<div>")]),e._v("元素公认的属性，所以 DOM 对象上也会有这两个属性。但"),v("code",[e._v("my_special_attribute")]),e._v("是自定义属性，因此不会成为 DOM 对象的属性。")]),e._v(" "),v("p",[e._v("通过 DOM 对象访问的属性中有两个返回的值跟使用"),v("code",[e._v("getAttribute")]),e._v("()取得的值不一样。首先是"),v("code",[e._v("style")]),e._v("属性，这个属性用于为元素设定 CSS 样式。在使用"),v("code",[e._v("getAttribute()")]),e._v("访问 style 属性时，返回的是 CSS 字符串。而在通过 DOM 对象的属性访问时，"),v("code",[e._v("style")]),e._v("属性返回的是一个（"),v("code",[e._v("CSSStyleDeclaration")]),e._v("）对象。DOM 对象的"),v("code",[e._v("style")]),e._v("属性用于以编程方式读写元素样式，因此不会直接映射为元素中"),v("code",[e._v("style")]),e._v("属性的字符串值。")]),e._v(" "),v("p",[e._v("第二个属性其实是一类，即事件处理程序（或者事件属性），比如"),v("code",[e._v("onclick")]),e._v("。在元素上使用事件属性时（比如"),v("code",[e._v("onclick")]),e._v("），属性的值是一段 JavaScript 代码。如果使用"),v("code",[e._v("getAttribute()")]),e._v("访问事件属性，则返回的是字符串形式的源代码。而通过 DOM 对象的属性访问事件属性时返回的则是一个 JavaScript 函数（未指定该属性则返回"),v("code",[e._v("null")]),e._v("）。这是因为"),v("code",[e._v("onclick")]),e._v("及其他事件属性是可以接受函数作为值的。")]),e._v(" "),v("p",[e._v("考虑到以上差异，开发者在进行 DOM 编程时通常会放弃使用"),v("code",[e._v("getAttribute()")]),e._v("而只使用对象属性。"),v("code",[e._v("getAttribute()")]),e._v("主要用于取得自定义属性的值。")])])]),e._v(" "),v("ol",{attrs:{start:"3"}},[v("li",[v("p",[v("strong",[e._v("设置属性")])]),e._v(" "),v("p",[e._v("与"),v("code",[e._v("getAttribute()")]),e._v("配套的方法是"),v("code",[e._v("setAttribute()")]),e._v("，这个方法接收两个参数：要设置的属性名和属性的值。如果属性已经存在，则"),v("code",[e._v("setAttribute()")]),e._v("会以指定的值替换原来的值；如果属性不存在，则"),v("code",[e._v("setAttribute()")]),e._v("会以指定的值创建该属性。下面看一个例子：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v('div.setAttribute("id", "someOtherId");\ndiv.setAttribute("class", "ft");\ndiv.setAttribute("title", "Some other text");\ndiv.setAttribute("lang","fr");\ndiv.setAttribute("dir", "rtl");\n')])])]),v("p",[v("code",[e._v("setAttribute()")]),e._v("适用于 HTML 属性，也适用于自定义属性。另外，使用"),v("code",[e._v("setAttribute()")]),e._v("方法设置的属性名会规范为小写形式，因此"),v("code",[e._v('"ID"')]),e._v("会变成"),v("code",[e._v('"id"')]),e._v("。")]),e._v(" "),v("p",[e._v("因为元素属性也是 DOM 对象属性，所以直接给 DOM 对象的属性赋值也可以设置元素属性的值，如下所示：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v('div.id = "someOtherId";\ndiv.align = "left";\n')])])]),v("p",[e._v("注意，在 DOM 对象上添加自定义属性，如下面的例子所示，不会自动让它变成元素的属性：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v('div.mycolor = "red";\nalert(div.getAttribute("mycolor")); // null（IE除外）\n')])])]),v("p",[e._v("这个例子添加了一个自定义属性"),v("code",[e._v("mycolor")]),e._v("并将其值设置为"),v("code",[e._v('"red"')]),e._v("。在多数浏览器中，这个属性不会自动变成元素属性。因此调用"),v("code",[e._v("getAttribute()")]),e._v("取得"),v("code",[e._v("mycolor")]),e._v("的值会返回"),v("code",[e._v("null")]),e._v("。")]),e._v(" "),v("p",[e._v("最后一个方法"),v("code",[e._v("removeAttribute()")]),e._v("用于从元素中删除属性。这样不单单是清除属性的值，而是会把整个属性完全从元素中去掉，如下所示：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v('div.removeAttribute("class");\n')])])]),v("p",[e._v("这个方法用得并不多，但在序列化 DOM 元素时可以通过它控制要包含的属性。")])])]),e._v(" "),v("ol",{attrs:{start:"4"}},[v("li",[v("p",[v("strong",[e._v("attributes 属性")])]),e._v(" "),v("p",[v("code",[e._v("Element")]),e._v("类型是唯一使用"),v("code",[e._v("attributes")]),e._v("属性的 DOM 节点类型。"),v("code",[e._v("attributes")]),e._v("属性包含一个"),v("code",[e._v("NamedNodeMap")]),e._v("实例，是一个类似"),v("code",[e._v("NodeList")]),e._v("的“实时”集合。元素的每个属性都表示为一个"),v("code",[e._v("Attr")]),e._v("节点，并保存在这个"),v("code",[e._v("NamedNodeMap")]),e._v("对象中。"),v("code",[e._v("NamedNodeMap")]),e._v("对象包含下列方法：")]),e._v(" "),v("ul",[v("li",[v("code",[e._v("getNamedItem(*name*)")]),e._v("，返回"),v("code",[e._v("nodeName")]),e._v("属性等于"),v("code",[e._v("*name*")]),e._v("的节点；")]),e._v(" "),v("li",[v("code",[e._v("removeNamedItem(*name*)")]),e._v("，删除"),v("code",[e._v("nodeName")]),e._v("属性等于"),v("code",[e._v("*name*")]),e._v("的节点；")]),e._v(" "),v("li",[v("code",[e._v("setNamedItem(*node*)")]),e._v("，向列表中添加"),v("code",[e._v("*node*")]),e._v("节点，以其"),v("code",[e._v("nodeName")]),e._v("为索引；")]),e._v(" "),v("li",[v("code",[e._v("item(*pos*)")]),e._v("，返回索引位置"),v("code",[e._v("*pos*")]),e._v("处的节点。")])]),e._v(" "),v("p",[v("code",[e._v("attributes")]),e._v("属性中的每个节点的"),v("code",[e._v("nodeName")]),e._v("是对应属性的名字，"),v("code",[e._v("nodeValue")]),e._v("是属性的值。比如，要取得元素"),v("code",[e._v("id")]),e._v("属性的值，可以使用以下代码：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v('let id = element.attributes.getNamedItem("id").nodeValue;\n')])])]),v("p",[e._v("下面是使用中括号访问属性的简写形式：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v('let id = element.attributes["id"].nodeValue;\n')])])]),v("p",[e._v("同样，也可以用这种语法设置属性的值，即先取得属性节点，再将其"),v("code",[e._v("nodeValue")]),e._v("设置为新值，如下所示：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v('element.attributes["id"].nodeValue = "someOtherId";\n')])])]),v("p",[v("code",[e._v("removeNamedItem()")]),e._v("方法与元素上的"),v("code",[e._v("removeAttribute()")]),e._v("方法类似，也是删除指定名字的属性。下面的例子展示了这两个方法唯一的不同之处，就是"),v("code",[e._v("removeNamedItem()")]),e._v("返回表示被删除属性的"),v("code",[e._v("Attr")]),e._v("节点：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v('let oldAttr = element.attributes.removeNamedItem("id");\n')])])]),v("p",[v("code",[e._v("setNamedItem()")]),e._v("方法很少使用，它接收一个属性节点，然后给元素添加一个新属性，如下所示：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("element.attributes.setNamedItem(newAttr);\n")])])]),v("p",[e._v("一般来说，因为使用起来更简便，通常开发者更喜欢使用"),v("code",[e._v("getAttribute()")]),e._v("、"),v("code",[e._v("removeAttribute()")]),e._v("和"),v("code",[e._v("setAttribute()")]),e._v("方法，而不是刚刚介绍的"),v("code",[e._v("NamedNodeMap")]),e._v("对象的方法。")]),e._v(" "),v("p",[v("code",[e._v("attributes")]),e._v("属性最有用的场景是需要迭代元素上所有属性的时候。这时候往往是要把 DOM 结构序列化为 XML 或 HTML 字符串。比如，以下代码能够迭代一个元素上的所有属性并以"),v("code",[e._v('attribute1= "value1" attribute2="value2"')]),e._v("的形式生成格式化字符串：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v('function outputAttributes(element) {\n  let pairs = [];\n\n  for (let i = 0, len = element.attributes.length; i < len; ++i) {\n    const attribute = element.attributes[i];\n    pairs.push(`${attribute.nodeName}="${attribute.nodeValue}"`);\n  }\n\n  return pairs.join(" ");\n}\n')])])]),v("p",[e._v("这个函数使用数组存储每个名/值对，迭代完所有属性后，再将这些名/值对用空格拼接在一起。（这个技术常用于序列化为长字符串。）这个函数中的"),v("code",[e._v("for")]),e._v("循环使用"),v("code",[e._v("attributes.length")]),e._v("属性迭代每个属性，将每个属性的名字和值输出为字符串。不同浏览器返回的"),v("code",[e._v("attributes")]),e._v("中的属性顺序也可能不一样。HTML 或 XML 代码中属性出现的顺序不一定与"),v("code",[e._v("attributes")]),e._v("中的顺序一致。")])])]),e._v(" "),v("ol",{attrs:{start:"5"}},[v("li",[v("p",[v("strong",[e._v("创建元素")])]),e._v(" "),v("p",[e._v("可以使用"),v("code",[e._v("document.createElement()")]),e._v("方法创建新元素。这个方法接收一个参数，即要创建元素的标签名。在 HTML 文档中，标签名是不区分大小写的，而 XML 文档（包括 XHTML）是区分大小写的。要创建"),v("code",[e._v("<div>")]),e._v("元素，可以使用下面的代码：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v('let div = document.createElement("div");\n')])])]),v("p",[e._v("使用"),v("code",[e._v("createElement()")]),e._v("方法创建新元素的同时也会将其"),v("code",[e._v("ownerDocument")]),e._v("属性设置为"),v("code",[e._v("document")]),e._v("。此时，可以再为其添加属性、添加更多子元素。比如：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v('div.id = "myNewDiv";\ndiv.className = "box";\n')])])]),v("p",[e._v("在新元素上设置这些属性只会附加信息。因为这个元素还没有添加到文档树，所以不会影响浏览器显示。要把元素添加到文档树，可以使用"),v("code",[e._v("appendChild()")]),e._v("、"),v("code",[e._v("insertBefore()")]),e._v("或"),v("code",[e._v("replaceChild()")]),e._v("。比如，以下代码会把刚才创建的元素添加到文档的"),v("code",[e._v("<body>")]),e._v("元素中：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("document.body.appendChild(div);\n")])])]),v("p",[e._v("元素被添加到文档树之后，浏览器会立即将其渲染出来。之后再对这个元素所做的任何修改，都会立即在浏览器中反映出来。")])])]),e._v(" "),v("ol",{attrs:{start:"6"}},[v("li",[v("p",[v("strong",[e._v("元素后代")])]),e._v(" "),v("p",[e._v("元素可以拥有任意多个子元素和后代元素，因为元素本身也可以是其他元素的子元素。"),v("code",[e._v("childNodes")]),e._v("属性包含元素所有的子节点，这些子节点可能是其他元素、文本节点、注释或处理指令。不同浏览器在识别这些节点时的表现有明显不同。比如下面的代码：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v('<ul id="myList">\n  <li>Item 1</li>\n  <li>Item 2</li>\n  <li>Item 3</li>\n</ul>\n')])])]),v("p",[e._v("在解析以上代码时，"),v("code",[e._v("<ul>")]),e._v("元素会包含 7 个子元素，其中 3 个是"),v("code",[e._v("<li>")]),e._v("元素，还有 4 个"),v("code",[e._v("Text")]),e._v("节点（表示"),v("code",[e._v("<li>")]),e._v("元素周围的空格）。如果把元素之间的空格删掉，变成下面这样，则所有浏览器都会返回同样数量的子节点：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v('<ul id="myList"><li>Item 1</li><li>Item 2</li><li>Item 3</li></ul>\n')])])]),v("p",[e._v("所有浏览器解析上面的代码后，"),v("code",[e._v("<ul>")]),e._v("元素都会包含 3 个子节点。考虑到这种情况，通常在执行某个操作之后需要先检测一下节点的"),v("code",[e._v("nodeType")]),e._v("，如下所示：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("for (let i = 0, len = element.childNodes.length; i < len; ++i) {\n  if (element.childNodes[i].nodeType == 1) {\n    // 执行某个操作\n  }\n}\n")])])]),v("p",[e._v("以上代码会遍历某个元素的子节点，并且只在"),v("code",[e._v("nodeType")]),e._v("等于 1（即"),v("code",[e._v("Element")]),e._v("节点）时执行某个操作。")]),e._v(" "),v("p",[e._v("要取得某个元素的子节点和其他后代节点，可以使用元素的"),v("code",[e._v("getElementsByTagName()")]),e._v("方法。在元素上调用这个方法与在文档上调用是一样的，只不过搜索范围限制在当前元素之内，即只会返回当前元素的后代。对于本节前面"),v("code",[e._v("<ul>")]),e._v("的例子，可以像下面这样取得其所有的"),v("code",[e._v("<li>")]),e._v("元素：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v('let ul = document.getElementById("myList");\nlet items = ul.getElementsByTagName("li");\n')])])]),v("p",[e._v("这里例子中的"),v("code",[e._v("<ul>")]),e._v("元素只有一级子节点，如果它包含更多层级，则所有层级中的"),v("code",[e._v("<li>")]),e._v("元素都会返回。")])])]),e._v(" "),v("h3",{attrs:{id:"_14-1-4-text类型"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_14-1-4-text类型"}},[e._v("#")]),e._v(" 14.1.4 　"),v("code",[e._v("Text")]),e._v("类型")]),e._v(" "),v("p",[v("code",[e._v("Text")]),e._v("节点由"),v("code",[e._v("Text")]),e._v("类型表示，包含按字面解释的纯文本，也可能包含转义后的 HTML 字符，但不含 HTML 代码。"),v("code",[e._v("Text")]),e._v("类型的节点具有以下特征：")]),e._v(" "),v("ul",[v("li",[v("code",[e._v("nodeType")]),e._v("等于 3；")]),e._v(" "),v("li",[v("code",[e._v("nodeName")]),e._v("值为"),v("code",[e._v('"#text"')]),e._v("；")]),e._v(" "),v("li",[v("code",[e._v("nodeValue")]),e._v("值为节点中包含的文本；")]),e._v(" "),v("li",[v("code",[e._v("parentNode")]),e._v("值为"),v("code",[e._v("Element")]),e._v("对象；")]),e._v(" "),v("li",[e._v("不支持子节点。")])]),e._v(" "),v("p",[v("code",[e._v("Text")]),e._v("节点中包含的文本可以通过"),v("code",[e._v("nodeValue")]),e._v("属性访问，也可以通过"),v("code",[e._v("data")]),e._v("属性访问，这两个属性包含相同的值。修改"),v("code",[e._v("nodeValue")]),e._v("或"),v("code",[e._v("data")]),e._v("的值，也会在另一个属性反映出来。文本节点暴露了以下操作文本的方法：")]),e._v(" "),v("ul",[v("li",[v("code",[e._v("appendData(*text*)")]),e._v("，向节点末尾添加文本"),v("code",[e._v("*text*")]),e._v("；")]),e._v(" "),v("li",[v("code",[e._v("deleteData(*offset, count*)")]),e._v("，从位置"),v("code",[e._v("*offset*")]),e._v("开始删除"),v("code",[e._v("*count*")]),e._v("个字符；")]),e._v(" "),v("li",[v("code",[e._v("insertData(*offset, text*)")]),e._v("，在位置"),v("code",[e._v("*offset*")]),e._v("插入"),v("code",[e._v("*text*")]),e._v("；")]),e._v(" "),v("li",[v("code",[e._v("replaceData(*offset, count, text*)")]),e._v("，用"),v("code",[e._v("*text*")]),e._v("替换从位置"),v("code",[e._v("*offset*")]),e._v("到"),v("code",[e._v("*offset* + *count*")]),e._v("的文本；")]),e._v(" "),v("li",[v("code",[e._v("splitText(*offset*)")]),e._v("，在位置"),v("code",[e._v("*offset*")]),e._v("将当前文本节点拆分为两个文本节点；")]),e._v(" "),v("li",[v("code",[e._v("substringData(*offset, count*)")]),e._v("，提取从位置"),v("code",[e._v("*offset*")]),e._v("到"),v("code",[e._v("*offset* + *count*")]),e._v("的文本。")])]),e._v(" "),v("p",[e._v("除了这些方法，还可以通过"),v("code",[e._v("length")]),e._v("属性获取文本节点中包含的字符数量。这个值等于"),v("code",[e._v("nodeValue.length")]),e._v("和"),v("code",[e._v("data.length")]),e._v("。")]),e._v(" "),v("p",[e._v("默认情况下，包含文本内容的每个元素最多只能有一个文本节点。例如：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("\x3c!-- 没有内容，因此没有文本节点 --\x3e\n<div></div>\n\n\x3c!-- 有空格，因此有一个文本节点 --\x3e\n<div></div>\n\n\x3c!-- 有内容，因此有一个文本节点 --\x3e\n<div>Hello World!</div>\n")])])]),v("p",[e._v("示例中的第一个"),v("code",[e._v("<div>")]),e._v("元素中不包含内容，因此不会产生文本节点。只要开始标签和结束标签之间有内容，就会创建一个文本节点，因此第二个"),v("code",[e._v("<div>")]),e._v("元素会有一个文本节点的子节点，虽然它只包含空格。这个文本节点的"),v("code",[e._v("nodeValue")]),e._v("就是一个空格。第三个"),v("code",[e._v("<div>")]),e._v("元素也有一个文本节点的子节点，其"),v("code",[e._v("nodeValue")]),e._v("的值为"),v("code",[e._v('"Hello World!"')]),e._v("。下列代码可以用来访问这个文本节点：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("let textNode = div.firstChild; // 或div.childNodes[0]\n")])])]),v("p",[e._v("取得文本节点的引用后，可以像这样来修改它：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v('div.firstChild.nodeValue = "Some other message";\n')])])]),v("p",[e._v("只要节点在当前的文档树中，这样的修改就会马上反映出来。修改文本节点还有一点要注意，就是 HTML 或 XML 代码（取决于文档类型）会被转换成实体编码，即小于号、大于号或引号会被转义，如下所示：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v('// 输出为"Some &lt;strong&gt;other&lt;/strong&gt; message"\ndiv.firstChild.nodeValue = "Some <strong>other</strong> message";\n')])])]),v("p",[e._v("这实际上是在将 HTML 字符串插入 DOM 文档前进行编码的有效方式。")]),e._v(" "),v("ol",[v("li",[v("p",[v("strong",[e._v("创建文本节点")])]),e._v(" "),v("p",[v("code",[e._v("document.createTextNode()")]),e._v("可以用来创建新文本节点，它接收一个参数，即要插入节点的文本。跟设置已有文本节点的值一样，这些要插入的文本也会应用 HTML 或 XML 编码，如下面的例子所示：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v('let textNode = document.createTextNode("<strong>Hello</strong> world!");\n')])])]),v("p",[e._v("创建新文本节点后，其"),v("code",[e._v("ownerDocument")]),e._v("属性会被设置为"),v("code",[e._v("document")]),e._v("。但在把这个节点添加到文档树之前，我们不会在浏览器中看到它。以下代码创建了一个"),v("code",[e._v("<div>")]),e._v("元素并给它添加了一段文本消息：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v('let element = document.createElement("div");\nelement.className = "message";\n\nlet textNode = document.createTextNode("Hello world!");\nelement.appendChild(textNode);\n\ndocument.body.appendChild(element);\n')])])]),v("p",[e._v("这个例子首先创建了一个"),v("code",[e._v("<div>")]),e._v("元素并给它添加了值为"),v("code",[e._v('"message"')]),e._v("的"),v("code",[e._v("class")]),e._v("属性，然后又创建了一个文本节点并添加到该元素。最后一步是把这个元素添加到文档的主体上，这样元素及其包含的文本会出现在浏览器中。")]),e._v(" "),v("p",[e._v("一般来说一个元素只包含一个文本子节点。不过，也可以让元素包含多个文本子节点，如下面的例子所示：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v('let element = document.createElement("div");\nelement.className = "message";\n\nlet textNode = document.createTextNode("Hello world!");\nelement.appendChild(textNode);\n\nlet anotherTextNode = document.createTextNode("Yippee!");\nelement.appendChild(anotherTextNode);\n\ndocument.body.appendChild(element);\n')])])]),v("p",[e._v("在将一个文本节点作为另一个文本节点的同胞插入后，两个文本节点的文本之间不会包含空格。")])])]),e._v(" "),v("ol",{attrs:{start:"2"}},[v("li",[v("p",[v("strong",[e._v("规范化文本节点")])]),e._v(" "),v("p",[e._v("DOM 文档中的同胞文本节点可能导致困惑，因为一个文本节点足以表示一个文本字符串。同样，DOM 文档中也经常会出现两个相邻文本节点。为此，有一个方法可以合并相邻的文本节点。这个方法叫"),v("code",[e._v("normalize()")]),e._v("，是在"),v("code",[e._v("Node")]),e._v("类型中定义的（因此所有类型的节点上都有这个方法）。在包含两个或多个相邻文本节点的父节点上调用"),v("code",[e._v("normalize()")]),e._v("时，所有同胞文本节点会被合并为一个文本节点，这个文本节点的"),v("code",[e._v("nodeValue")]),e._v("就等于之前所有同胞节点"),v("code",[e._v("nodeValue")]),e._v("拼接在一起得到的字符串。来看下面的例子：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v('let element = document.createElement("div");\nelement.className = "message";\n\nlet textNode = document.createTextNode("Hello world!");\nelement.appendChild(textNode);\n\nlet anotherTextNode = document.createTextNode("Yippee!");\nelement.appendChild(anotherTextNode);\n\ndocument.body.appendChild(element);\n\nalert(element.childNodes.length);    // 2\n\nelement.normalize();\nalert(element.childNodes.length);    // 1\nalert(element.firstChild.nodeValue); // "Hello world!Yippee!"\n')])])]),v("p",[e._v("浏览器在解析文档时，永远不会创建同胞文本节点。同胞文本节点只会出现在 DOM 脚本生成的文档树中。")])])]),e._v(" "),v("ol",{attrs:{start:"3"}},[v("li",[v("p",[v("strong",[e._v("拆分文本节点")])]),e._v(" "),v("p",[v("code",[e._v("Text")]),e._v("类型定义了一个与"),v("code",[e._v("normalize()")]),e._v("相反的方法——"),v("code",[e._v("splitText()")]),e._v("。这个方法可以在指定的偏移位置拆分"),v("code",[e._v("nodeValue")]),e._v("，将一个文本节点拆分成两个文本节点。拆分之后，原来的文本节点包含开头到偏移位置前的文本，新文本节点包含剩下的文本。这个方法返回新的文本节点，具有与原来的文本节点相同的"),v("code",[e._v("parentNode")]),e._v("。来看下面的例子：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v('let element = document.createElement("div");\nelement.className = "message";\n\nlet textNode = document.createTextNode("Hello world!");\nelement.appendChild(textNode);\n\ndocument.body.appendChild(element);\n\nlet newNode = element.firstChild.splitText(5);\nalert(element.firstChild.nodeValue);  // "Hello"\nalert(newNode.nodeValue);             // " world!"\nalert(element.childNodes.length);     // 2\n')])])]),v("p",[e._v("在这个例子中，包含"),v("code",[e._v('"Hello world!"')]),e._v("的文本节点被从位置"),v("code",[e._v("5")]),e._v("拆分成两个文本节点。位置"),v("code",[e._v("5")]),e._v("对应"),v("code",[e._v('"Hello"')]),e._v("和"),v("code",[e._v('"world!"')]),e._v("之间的空格，因此原始文本节点包含字符串"),v("code",[e._v('"Hello"')]),e._v("，而新文本节点包含文本"),v("code",[e._v('" world!"')]),e._v("（包含空格）。")]),e._v(" "),v("p",[e._v("拆分文本节点最常用于从文本节点中提取数据的 DOM 解析技术。")])])]),e._v(" "),v("h3",{attrs:{id:"_14-1-5-comment类型"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_14-1-5-comment类型"}},[e._v("#")]),e._v(" 14.1.5 　"),v("code",[e._v("Comment")]),e._v("类型")]),e._v(" "),v("p",[e._v("DOM 中的注释通过"),v("code",[e._v("Comment")]),e._v("类型表示。"),v("code",[e._v("Comment")]),e._v("类型的节点具有以下特征：")]),e._v(" "),v("ul",[v("li",[v("code",[e._v("nodeType")]),e._v("等于 8；")]),e._v(" "),v("li",[v("code",[e._v("nodeName")]),e._v("值为"),v("code",[e._v('"#comment"')]),e._v("；")]),e._v(" "),v("li",[v("code",[e._v("nodeValue")]),e._v("值为注释的内容；")]),e._v(" "),v("li",[v("code",[e._v("parentNode")]),e._v("值为"),v("code",[e._v("Document")]),e._v("或"),v("code",[e._v("Element")]),e._v("对象；")]),e._v(" "),v("li",[e._v("不支持子节点。")])]),e._v(" "),v("p",[v("code",[e._v("Comment")]),e._v("类型与"),v("code",[e._v("Text")]),e._v("类型继承同一个基类（"),v("code",[e._v("CharacterData")]),e._v("），因此拥有除"),v("code",[e._v("splitText()")]),e._v("之外"),v("code",[e._v("Text")]),e._v("节点所有的字符串操作方法。与"),v("code",[e._v("Text")]),e._v("类型相似，注释的实际内容可以通过"),v("code",[e._v("nodeValue")]),e._v("或"),v("code",[e._v("data")]),e._v("属性获得。")]),e._v(" "),v("p",[e._v("注释节点可以作为父节点的子节点来访问。比如下面的 HTML 代码：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v('<div id="myDiv">\x3c!-- A comment --\x3e</div>\n')])])]),v("p",[e._v("这里的注释是"),v("code",[e._v("<div>")]),e._v("元素的子节点，这意味着可以像下面这样访问它：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v('let div = document.getElementById("myDiv");\nlet comment = div.firstChild;\nalert(comment.data); // "A comment"\n')])])]),v("p",[e._v("可以使用"),v("code",[e._v("document.createComment()")]),e._v("方法创建注释节点，参数为注释文本，如下所示：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v('let comment = document.createComment("A comment");\n')])])]),v("p",[e._v("显然，注释节点很少通过 JavaScrpit 创建和访问，因为注释几乎不涉及算法逻辑。此外，浏览器不承认结束的"),v("code",[e._v("</html>")]),e._v("标签之后的注释。如果要访问注释节点，则必须确定它们是"),v("code",[e._v("<html>")]),e._v("元素的后代。")]),e._v(" "),v("h3",{attrs:{id:"_14-1-6-cdatasection类型"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_14-1-6-cdatasection类型"}},[e._v("#")]),e._v(" 14.1.6 　"),v("code",[e._v("CDATASection")]),e._v("类型")]),e._v(" "),v("p",[v("code",[e._v("CDATASection")]),e._v("类型表示 XML 中特有的 CDATA 区块。"),v("code",[e._v("CDATASection")]),e._v("类型继承"),v("code",[e._v("Text")]),e._v("类型，因此拥有包括"),v("code",[e._v("splitText()")]),e._v("在内的所有字符串操作方法。"),v("code",[e._v("CDATASection")]),e._v("类型的节点具有以下特征：")]),e._v(" "),v("ul",[v("li",[v("code",[e._v("nodeType")]),e._v("等于 4；")]),e._v(" "),v("li",[v("code",[e._v("nodeName")]),e._v("值为"),v("code",[e._v('"#cdata-section"')]),e._v("；")]),e._v(" "),v("li",[v("code",[e._v("nodeValue")]),e._v("值为 CDATA 区块的内容；")]),e._v(" "),v("li",[v("code",[e._v("parentNode")]),e._v("值为"),v("code",[e._v("Document")]),e._v("或"),v("code",[e._v("Element")]),e._v("对象；")]),e._v(" "),v("li",[e._v("不支持子节点。")])]),e._v(" "),v("p",[e._v("CDATA 区块只在 XML 文档中有效，因此某些浏览器比较陈旧的版本会错误地将 CDATA 区块解析为"),v("code",[e._v("Comment")]),e._v("或"),v("code",[e._v("Element")]),e._v("。比如下面这行代码：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v('<div id="myDiv"><![CDATA[This is some content.]]></div>\n')])])]),v("p",[e._v("这里"),v("code",[e._v("<div>")]),e._v("的第一个子节点应该是"),v("code",[e._v("CDATASection")]),e._v("节点。但主流的四大浏览器没有一个将其识别为"),v("code",[e._v("CDATASection")]),e._v("。即使在有效的 XHTML 文档中，这些浏览器也不能恰当地支持嵌入的 CDATA 区块。")]),e._v(" "),v("p",[e._v("在真正的 XML 文档中，可以使用"),v("code",[e._v("document.createCDataSection()")]),e._v("并传入节点内容来创建 CDATA 区块。")]),e._v(" "),v("h3",{attrs:{id:"_14-1-7-documenttype类型"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_14-1-7-documenttype类型"}},[e._v("#")]),e._v(" 14.1.7 　"),v("code",[e._v("DocumentType")]),e._v("类型")]),e._v(" "),v("p",[v("code",[e._v("DocumentType")]),e._v("类型的节点包含文档的文档类型（"),v("code",[e._v("doctype")]),e._v("）信息，具有以下特征：")]),e._v(" "),v("ul",[v("li",[v("code",[e._v("nodeType")]),e._v("等于 10；")]),e._v(" "),v("li",[v("code",[e._v("nodeName")]),e._v("值为文档类型的名称；")]),e._v(" "),v("li",[v("code",[e._v("nodeValue")]),e._v("值为"),v("code",[e._v("null")]),e._v("；")]),e._v(" "),v("li",[v("code",[e._v("parentNode")]),e._v("值为"),v("code",[e._v("Document")]),e._v("对象；")]),e._v(" "),v("li",[e._v("不支持子节点。")])]),e._v(" "),v("p",[v("code",[e._v("DocumentType")]),e._v("对象在 DOM Level 1 中不支持动态创建，只能在解析文档代码时创建。对于支持这个类型的浏览器，"),v("code",[e._v("DocumentType")]),e._v("对象保存在"),v("code",[e._v("document.doctype")]),e._v("属性中。DOM Level 1 规定了"),v("code",[e._v("DocumentType")]),e._v("对象的 3 个属性："),v("code",[e._v("name")]),e._v("、"),v("code",[e._v("entities")]),e._v("和"),v("code",[e._v("notations")]),e._v("。其中，"),v("code",[e._v("name")]),e._v("是文档类型的名称，"),v("code",[e._v("entities")]),e._v("是这个文档类型描述的实体的"),v("code",[e._v("NamedNodeMap")]),e._v("，而"),v("code",[e._v("notations")]),e._v("是这个文档类型描述的表示法的"),v("code",[e._v("NamedNodeMap")]),e._v("。因为浏览器中的文档通常是 HTML 或 XHTML 文档类型，所以"),v("code",[e._v("entities")]),e._v("和"),v("code",[e._v("notations")]),e._v("列表为空。（这个对象只包含行内声明的文档类型。）无论如何，只有"),v("code",[e._v("name")]),e._v("属性是有用的。这个属性包含文档类型的名称，即紧跟在"),v("code",[e._v("<!DOCTYPE")]),e._v("后面的那串文本。比如下面的 HTML 4.01 严格文档类型：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v('<!DOCTYPE HTML PUBLIC "-// W3C// DTD HTML 4.01// EN"\n  "http:// www.w3.org/TR/html4/strict.dtd">\n')])])]),v("p",[e._v("对于这个文档类型，"),v("code",[e._v("name")]),e._v("属性的值是"),v("code",[e._v('"HTML"')]),e._v("：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v('alert(document.doctype.name); // "HTML"\n')])])]),v("h3",{attrs:{id:"_14-1-8-documentfragment类型"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_14-1-8-documentfragment类型"}},[e._v("#")]),e._v(" 14.1.8 　"),v("code",[e._v("DocumentFragment")]),e._v("类型")]),e._v(" "),v("p",[e._v("在所有节点类型中，"),v("code",[e._v("DocumentFragment")]),e._v("类型是唯一一个在标记中没有对应表示的类型。DOM 将文档片段定义为“轻量级”文档，能够包含和操作节点，却没有完整文档那样额外的消耗。"),v("code",[e._v("DocumentFragment")]),e._v("节点具有以下特征：")]),e._v(" "),v("ul",[v("li",[v("code",[e._v("nodeType")]),e._v("等于 11；")]),e._v(" "),v("li",[v("code",[e._v("nodeName")]),e._v("值为"),v("code",[e._v('"#document-fragment"')]),e._v("；")]),e._v(" "),v("li",[v("code",[e._v("nodeValue")]),e._v("值为"),v("code",[e._v("null")]),e._v("；")]),e._v(" "),v("li",[v("code",[e._v("parentNode")]),e._v("值为"),v("code",[e._v("null")]),e._v("；")]),e._v(" "),v("li",[e._v("子节点可以是"),v("code",[e._v("Element")]),e._v("、"),v("code",[e._v("ProcessingInstruction")]),e._v("、"),v("code",[e._v("Comment")]),e._v("、"),v("code",[e._v("Text")]),e._v("、"),v("code",[e._v("CDATASection")]),e._v("或"),v("code",[e._v("EntityReference")]),e._v("。")])]),e._v(" "),v("p",[e._v("不能直接把文档片段添加到文档。相反，文档片段的作用是充当其他要被添加到文档的节点的仓库。可以使用"),v("code",[e._v("document.createDocumentFragment()")]),e._v("方法像下面这样创建文档片段：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("let fragment = document.createDocumentFragment();\n")])])]),v("p",[e._v("文档片段从"),v("code",[e._v("Node")]),e._v("类型继承了所有文档类型具备的可以执行 DOM 操作的方法。如果文档中的一个节点被添加到一个文档片段，则该节点会从文档树中移除，不会再被浏览器渲染。添加到文档片段的新节点同样不属于文档树，不会被浏览器渲染。可以通过"),v("code",[e._v("appendChild()")]),e._v("或"),v("code",[e._v("insertBefore()")]),e._v("方法将文档片段的内容添加到文档。在把文档片段作为参数传给这些方法时，这个文档片段的所有子节点会被添加到文档中相应的位置。文档片段本身永远不会被添加到文档树。以下面的 HTML 为例：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v('<ul id="myList"></ul>\n')])])]),v("p",[e._v("假设想给这个"),v("code",[e._v("<ul>")]),e._v("元素添加 3 个列表项。如果分 3 次给这个元素添加列表项，浏览器就要重新渲染 3 次页面，以反映新添加的内容。为避免多次渲染，下面的代码示例使用文档片段创建了所有列表项，然后一次性将它们添加到了"),v("code",[e._v("<ul>")]),e._v("元素：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v('let fragment = document.createDocumentFragment();\nlet ul = document.getElementById("myList");\n\nfor (let i = 0; i < 3; ++i) {\n  let li = document.createElement("li");\n  li.appendChild(document.createTextNode(`Item ${i + 1}`));\n  fragment.appendChild(li);\n}\n\nul.appendChild(fragment);\n')])])]),v("p",[e._v("这个例子先创建了一个文档片段，然后取得了"),v("code",[e._v("<ul>")]),e._v("元素的引用。接着通过"),v("code",[e._v("for")]),e._v("循环创建了 3 个列表项，每一项都包含表明自己身份的文本。为此先创建"),v("code",[e._v("<li>")]),e._v("元素，再创建文本节点并添加到该元素。然后通过"),v("code",[e._v("appendChild()")]),e._v("把"),v("code",[e._v("<li>")]),e._v("元素添加到文档片段。循环结束后，通过把文档片段传给"),v("code",[e._v("appendChild()")]),e._v("将所有列表项添加到了"),v("code",[e._v("<ul>")]),e._v("元素。此时，文档片段的子节点全部被转移到了"),v("code",[e._v("<ul>")]),e._v("元素。")]),e._v(" "),v("h3",{attrs:{id:"_14-1-9-attr类型"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_14-1-9-attr类型"}},[e._v("#")]),e._v(" 14.1.9 　"),v("code",[e._v("Attr")]),e._v("类型")]),e._v(" "),v("p",[e._v("元素数据在 DOM 中通过"),v("code",[e._v("Attr")]),e._v("类型表示。"),v("code",[e._v("Attr")]),e._v("类型构造函数和原型在所有浏览器中都可以直接访问。技术上讲，属性是存在于元素"),v("code",[e._v("attributes")]),e._v("属性中的节点。"),v("code",[e._v("Attr")]),e._v("节点具有以下特征：")]),e._v(" "),v("ul",[v("li",[v("code",[e._v("nodeType")]),e._v("等于 2；")]),e._v(" "),v("li",[v("code",[e._v("nodeName")]),e._v("值为属性名；")]),e._v(" "),v("li",[v("code",[e._v("nodeValue")]),e._v("值为属性值；")]),e._v(" "),v("li",[v("code",[e._v("parentNode")]),e._v("值为"),v("code",[e._v("null")]),e._v("；")]),e._v(" "),v("li",[e._v("在 HTML 中不支持子节点；")]),e._v(" "),v("li",[e._v("在 XML 中子节点可以是"),v("code",[e._v("Text")]),e._v("或"),v("code",[e._v("EntityReference")]),e._v("。")])]),e._v(" "),v("p",[e._v("属性节点尽管是节点，却不被认为是 DOM 文档树的一部分。"),v("code",[e._v("Attr")]),e._v("节点很少直接被引用，通常开发者更喜欢使用"),v("code",[e._v("getAttribute()")]),e._v("、"),v("code",[e._v("removeAttribute()")]),e._v("和"),v("code",[e._v("setAttribute()")]),e._v("方法操作属性。")]),e._v(" "),v("p",[v("code",[e._v("Attr")]),e._v("对象上有 3 个属性："),v("code",[e._v("name")]),e._v("、"),v("code",[e._v("value")]),e._v("和"),v("code",[e._v("specified")]),e._v("。其中，"),v("code",[e._v("name")]),e._v("包含属性名（与"),v("code",[e._v("nodeName")]),e._v("一样），"),v("code",[e._v("value")]),e._v("包含属性值（与"),v("code",[e._v("nodeValue")]),e._v("一样），而"),v("code",[e._v("specified")]),e._v("是一个布尔值，表示属性使用的是默认值还是被指定的值。")]),e._v(" "),v("p",[e._v("可以使用"),v("code",[e._v("document.createAttribute()")]),e._v("方法创建新的"),v("code",[e._v("Attr")]),e._v("节点，参数为属性名。比如，要给元素添加"),v("code",[e._v("align")]),e._v("属性，可以使用下列代码：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v('let attr = document.createAttribute("align");\nattr.value = "left";\nelement.setAttributeNode(attr);\n\nalert(element.attributes["align"].value);       // "left"\nalert(element.getAttributeNode("align").value); // "left"\nalert(element.getAttribute("align"));           // "left"\n')])])]),v("p",[e._v("在这个例子中，首先创建了一个新属性。调用"),v("code",[e._v("createAttribute()")]),e._v("并传入"),v("code",[e._v('"align"')]),e._v("为新属性设置了"),v("code",[e._v("name")]),e._v("属性，因此就不用再设置了。随后，"),v("code",[e._v("value")]),e._v("属性被赋值为"),v("code",[e._v('"left"')]),e._v("。为把这个新属性添加到元素上，可以使用元素的"),v("code",[e._v("setAttributeNode()")]),e._v("方法。添加这个属性后，可以通过不同方式访问它，包括"),v("code",[e._v("attributes")]),e._v("属性、"),v("code",[e._v("getAttributeNode()")]),e._v("和"),v("code",[e._v("getAttribute()")]),e._v("方法。其中，"),v("code",[e._v("attributes")]),e._v("属性和"),v("code",[e._v("getAttributeNode()")]),e._v("方法都返回属性对应的"),v("code",[e._v("Attr")]),e._v("节点，而"),v("code",[e._v("getAttribute()")]),e._v("方法只返回属性的值。")]),e._v(" "),v("blockquote",[v("p",[v("strong",[e._v("注意")]),e._v("　将属性作为节点来访问多数情况下并无必要。推荐使用"),v("code",[e._v("getAttribute()")]),e._v("、"),v("code",[e._v("removeAttribute()")]),e._v("和"),v("code",[e._v("setAttribute()")]),e._v("方法操作属性，而不是直接操作属性节点。")])]),e._v(" "),v("h2",{attrs:{id:"_14-2-dom-编程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_14-2-dom-编程"}},[e._v("#")]),e._v(" 14.2 　 DOM 编程")]),e._v(" "),v("p",[e._v("很多时候，操作 DOM 是很直观的。通过 HTML 代码能实现的，也一样能通过 JavaScript 实现。但有时候，DOM 也没有看起来那么简单。浏览器能力的参差不齐和各种问题，也会导致 DOM 的某些方面会复杂一些。")]),e._v(" "),v("h3",{attrs:{id:"_14-2-1-动态脚本"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_14-2-1-动态脚本"}},[e._v("#")]),e._v(" 14.2.1 　动态脚本")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("\n可以像这样通过DOM编程创建这个节点：\n\n")])])]),v("p",[e._v('let script = document.createElement("script");\nscript.src = "foo.js";\ndocument.body.appendChild(script);')]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("\n这里的DOM代码实际上完全照搬了它要表示的HTML代码。注意，在上面最后一行把`<script>`元素添加到页面之前，是不会开始下载外部文件的。当然也可以把它添加到`<head>`元素，同样可以实现动态脚本加载。这个过程可以抽象为一个函数，比如：\n\n")])])]),v("p",[e._v('function loadScript(url) {\nlet script = document.createElement("script");\nscript.src = url;\ndocument.body.appendChild(script);\n}')]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("\n然后，就可以像下面这样加载外部JavaScript文件了：\n\n")])])]),v("p",[e._v('loadScript("client.js");')]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("\n加载之后，这个脚本就可以对页面执行操作了。这里有个问题：怎么能知道脚本什么时候加载完？这个问题并没有标准答案。第17章会讨论一些与加载相关的事件，具体情况取决于使用的浏览器。\n\n另一个动态插入JavaScript的方式是嵌入源代码，如下面的例子所示：\n\n")])])]),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("\n使用DOM，可以实现以下逻辑：\n\n")])])]),v("p",[e._v('let script = document.createElement("script");\nscript.appendChild(document.createTextNode("function sayHi(){alert(\'hi\');}"));\ndocument.body.appendChild(script);')]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("\n以上代码可以在`Firefox`、`Safari`、`Chrome`和`Opera`中运行。不过在旧版本的IE中可能会导致问题。这是因为IE对`<script>`元素做了特殊处理，不允许常规DOM访问其子节点。但`<script>`元素上有一个`text`属性，可以用来添加JavaScript代码，如下所示：\n\n")])])]),v("p",[e._v('var script = document.createElement("script");\nscript.text = "function sayHi(){alert(\'hi\');}";\ndocument.body.appendChild(script);')]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("\n这样修改后，上面的代码可以在IE、Firefox、Opera和Safari 3及更高版本中运行。Safari 3之前的版本不能正确支持这个`text`属性，但这些版本却支持文本节点赋值。对于早期的Safari版本，需要使用以下代码：\n\n")])])]),v("p",[e._v('var script = document.createElement("script");\nvar code = "function sayHi(){alert(\'hi\');}";\ntry {\nscript.appendChild(document.createTextNode("code"));\n} catch (ex){\nscript.text = "code";\n}\ndocument.body.appendChild(script);')]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("\n这里先尝试使用标准的DOM文本节点插入方式，因为除IE之外的浏览器都支持这种方式。IE此时会抛出错误，那么可以在捕获错误之后再使用`text`属性来插入JavaScript代码。于是，我们就可以抽象出一个跨浏览器的函数：\n\n")])])]),v("p",[e._v('function loadScriptString(code){\nvar script = document.createElement("script");\nscript.type = "text/javascript";\ntry {\nscript.appendChild(document.createTextNode(code));\n} catch (ex){\nscript.text = code;\n}\ndocument.body.appendChild(script);\n}')]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("\n这个函数可以这样调用：\n\n")])])]),v("p",[e._v("loadScriptString(\"function sayHi(){alert('hi');}\");")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("\n以这种方式加载的代码会在全局作用域中执行，并在调用返回后立即生效。基本上，这就相当于在全局作用域中把源代码传给`eval()`方法。\n\n注意，通过`innerHTML`属性创建的`<script>`元素永远不会执行。浏览器会尽责地创建`<script>`元素，以及其中的脚本文本，但解析器会给这个`<script>`元素打上永不执行的标签。只要是使用`innerHTML`创建的`<script>`元素，以后也没有办法强制其执行。\n\n### 14.2.2　动态样式\n\nCSS样式在HTML页面中可以通过两个元素加载。`<link>`元素用于包含CSS外部文件，而`<style>`元素用于添加嵌入样式。与动态脚本类似，动态样式也是页面初始加载时并不存在，而是在之后才添加到页面中的。\n\n来看下面这个典型的`<link>`元素：\n\n")])])]),v("link",{attrs:{rel:"stylesheet",type:"text/css",href:"styles.css"}}),e._v("\n```\n"),v("p",[e._v("这个元素很容易使用 DOM 编程创建出来：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v('let link = document.createElement("link");\nlink.rel = "stylesheet";\nlink.type = "text/css";\nlink.href = "styles.css";\nlet head = document.getElementsByTagName("head")[0];\nhead.appendChild(link);\n')])])]),v("p",[e._v("以上代码在所有主流浏览器中都能正常运行。注意应该把"),v("code",[e._v("<link>")]),e._v("元素添加到"),v("code",[e._v("<head>")]),e._v("元素而不是"),v("code",[e._v("<body>")]),e._v("元素，这样才能保证所有浏览器都能正常运行。这个过程可以抽象为以下通用函数：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v('function loadStyles(url){\n  let link = document.createElement("link");\n  link.rel = "stylesheet";\n  link.type = "text/css";\n  link.href = url;\n  let head = document.getElementsByTagName("head")[0];\n  head.appendChild(link);\n}\n')])])]),v("p",[e._v("然后就可以这样调用这个"),v("code",[e._v("loadStyles()")]),e._v("函数了：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v('loadStyles("styles.css");\n')])])]),v("p",[e._v("通过外部文件加载样式是一个异步过程。因此，样式的加载和正执行的 JavaScript 代码并没有先后顺序。一般来说，也没有必要知道样式什么时候加载完成。")]),e._v(" "),v("p",[e._v("另一种定义样式的方式是使用"),v("code",[e._v("<script>")]),e._v("元素包含嵌入的 CSS 规则，例如：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v('<style type="text/css">\nbody {\n  background-color: red;\n}\n</style>\n')])])]),v("p",[e._v("逻辑上，下列 DOM 代码会有同样的效果：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v('let style = document.createElement("style");\nstyle.type = "text/css";\nstyle.appendChild(document.createTextNode("body{background-color:red}"));\nlet head = document.getElementsByTagName("head")[0];\nhead.appendChild(style);\n')])])]),v("p",[e._v("以上代码在 Firefox、Safari、Chrome 和 Opera 中都可以运行，但 IE 除外。IE 对"),v("code",[e._v("<style>")]),e._v("节点会施加限制，不允许访问其子节点，这一点与它对"),v("code",[e._v("<script>")]),e._v("元素施加的限制一样。事实上，IE 在执行到给"),v("code",[e._v("<style>")]),e._v("添加子节点的代码时，会抛出与给"),v("code",[e._v("<script>")]),e._v("添加子节点时同样的错误。对于 IE，解决方案是访问元素的"),v("code",[e._v("styleSheet")]),e._v("属性，这个属性又有一个"),v("code",[e._v("cssText")]),e._v("属性，然后给这个属性添加 CSS 代码：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v('let style = document.createElement("style");\nstyle.type = "text/css";\ntry{\n  style.appendChild(document.createTextNode("body{background-color:red}"));\n} catch (ex){\n  style.styleSheet.cssText = "body{background-color:red}";\n}\nlet head = document.getElementsByTagName("head")[0];\nhead.appendChild(style);\n')])])]),v("p",[e._v("与动态添加脚本源代码类似，这里也使用了"),v("code",[e._v("try...catch")]),e._v("语句捕获 IE 抛出的错误，然后再以 IE 特有的方式来设置样式。这是最终的通用函数：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v('function loadStyleString(css){\n  let style = document.createElement("style");\n  style.type = "text/css";\n  try{\n    style.appendChild(document.createTextNode(css));\n  } catch (ex){\n    style.styleSheet.cssText = css;\n  }\n  let head = document.getElementsByTagName("head")[0];\n    head.appendChild(style);\n}\n')])])]),v("p",[e._v("可以这样调用这个函数：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v('loadStyleString("body{background-color:red}");\n')])])]),v("p",[e._v("这样添加的样式会立即生效，因此所有变化会立即反映出来。")]),e._v(" "),v("blockquote",[v("p",[v("strong",[e._v("注意")]),e._v("　对于 IE，要小心使用"),v("code",[e._v("styleSheet.cssText")]),e._v("。如果重用同一个"),v("code",[e._v("<style>")]),e._v("元素并设置该属性超过一次，则可能导致浏览器崩溃。同样，将"),v("code",[e._v("cssText")]),e._v("设置为空字符串也可能导致浏览器崩溃。")])]),e._v(" "),v("h3",{attrs:{id:"_14-2-3-操作表格"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_14-2-3-操作表格"}},[e._v("#")]),e._v(" 14.2.3 　操作表格")]),e._v(" "),v("p",[e._v("表格是 HTML 中最复杂的结构之一。通过 DOM 编程创建"),v("code",[e._v("<table>")]),e._v("元素，通常要涉及大量标签，包括表行、表元、表题，等等。因此，通过 DOM 编程创建和修改表格时可能要写很多代码。假设要通过 DOM 来创建以下 HTML 表格：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v('<table border="1" width="100%">\n  <tbody>\n    <tr>\n      <td>Cell 1,1</td>\n      <td>Cell 2,1</td>\n    </tr>\n    <tr>\n      <td>Cell 1,2</td>\n      <td>Cell 2,2</td>\n    </tr>\n  </tbody>\n</table>\n')])])]),v("p",[e._v("下面就是以 DOM 编程方式重建这个表格的代码：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v('// 创建表格\nlet table = document.createElement("table");\ntable.border = 1;\ntable.width = "100%";\n\n// 创建表体\nlet tbody = document.createElement("tbody");\ntable.appendChild(tbody);\n\n// 创建第一行\nlet row1 = document.createElement("tr");\ntbody.appendChild(row1);\nlet cell1_1 = document.createElement("td");\ncell1_1.appendChild(document.createTextNode("Cell 1,1"));\nrow1.appendChild(cell1_1);\nlet cell2_1 = document.createElement("td");\ncell2_1.appendChild(document.createTextNode("Cell 2,1"));\nrow1.appendChild(cell2_1);\n\n// 创建第二行\nlet row2 = document.createElement("tr");\ntbody.appendChild(row2);\nlet cell1_2 = document.createElement("td");\ncell1_2.appendChild(document.createTextNode("Cell 1,2"));\nrow2.appendChild(cell1_2);\nlet cell2_2= document.createElement("td");\ncell2_2.appendChild(document.createTextNode("Cell 2,2"));\nrow2.appendChild(cell2_2);\n\n// 把表格添加到文档主体\ndocument.body.appendChild(table);\n')])])]),v("p",[e._v("以上代码相当烦琐，也不好理解。为了方便创建表格，HTML DOM 给"),v("code",[e._v("<table>")]),e._v("、"),v("code",[e._v("<tbody>")]),e._v("和"),v("code",[e._v("<tr>")]),e._v("元素添加了一些属性和方法。")]),e._v(" "),v("p",[v("code",[e._v("<table>")]),e._v("元素添加了以下属性和方法：")]),e._v(" "),v("ul",[v("li",[v("code",[e._v("caption")]),e._v("，指向"),v("code",[e._v("<caption>")]),e._v("元素的指针（如果存在）；")]),e._v(" "),v("li",[v("code",[e._v("tBodies")]),e._v("，包含"),v("code",[e._v("<tbody>")]),e._v("元素的"),v("code",[e._v("HTMLCollection")]),e._v("；")]),e._v(" "),v("li",[v("code",[e._v("tFoot")]),e._v("，指向"),v("code",[e._v("<tfoot>")]),e._v("元素（如果存在）；")]),e._v(" "),v("li",[v("code",[e._v("tHead")]),e._v("，指向"),v("code",[e._v("<thead>")]),e._v("元素（如果存在）；")]),e._v(" "),v("li",[v("code",[e._v("rows")]),e._v("，包含表示所有行的"),v("code",[e._v("HTMLCollection")]),e._v("；")]),e._v(" "),v("li",[v("code",[e._v("createTHead()")]),e._v("，创建"),v("code",[e._v("<thead>")]),e._v("元素，放到表格中，返回引用；")]),e._v(" "),v("li",[v("code",[e._v("createTFoot()")]),e._v("，创建"),v("code",[e._v("<tfoot>")]),e._v("元素，放到表格中，返回引用；")]),e._v(" "),v("li",[v("code",[e._v("createCaption()")]),e._v("，创建"),v("code",[e._v("<caption>")]),e._v("元素，放到表格中，返回引用；")]),e._v(" "),v("li",[v("code",[e._v("deleteTHead()")]),e._v("，删除"),v("code",[e._v("<thead>")]),e._v("元素；")]),e._v(" "),v("li",[v("code",[e._v("deleteTFoot()")]),e._v("，删除"),v("code",[e._v("<tfoot>")]),e._v("元素；")]),e._v(" "),v("li",[v("code",[e._v("deleteCaption()")]),e._v("，删除"),v("code",[e._v("<caption>")]),e._v("元素；")]),e._v(" "),v("li",[v("code",[e._v("deleteRow(*pos*)")]),e._v("，删除给定位置的行；")]),e._v(" "),v("li",[v("code",[e._v("insertRow(*pos*)")]),e._v("，在行集合中给定位置插入一行。")])]),e._v(" "),v("p",[v("code",[e._v("<tbody>")]),e._v("元素添加了以下属性和方法：")]),e._v(" "),v("ul",[v("li",[v("code",[e._v("rows")]),e._v("，包含"),v("code",[e._v("<tbody>")]),e._v("元素中所有行的"),v("code",[e._v("HTMLCollection")]),e._v("；")]),e._v(" "),v("li",[v("code",[e._v("deleteRow(*pos*)")]),e._v("，删除给定位置的行；")]),e._v(" "),v("li",[v("code",[e._v("insertRow(*pos*)")]),e._v("，在行集合中给定位置插入一行，返回该行的引用。")])]),e._v(" "),v("p",[v("code",[e._v("<tr>")]),e._v("元素添加了以下属性和方法：")]),e._v(" "),v("ul",[v("li",[v("code",[e._v("cells")]),e._v("，包含"),v("code",[e._v("<tr>")]),e._v("元素所有表元的"),v("code",[e._v("HTMLCollection")]),e._v("；")]),e._v(" "),v("li",[v("code",[e._v("deleteCell(*pos*)")]),e._v("，删除给定位置的表元；")]),e._v(" "),v("li",[v("code",[e._v("insertCell(*pos*)")]),e._v("，在表元集合给定位置插入一个表元，返回该表元的引用。")])]),e._v(" "),v("p",[e._v("这些属性和方法极大地减少了创建表格所需的代码量。例如，使用这些方法重写前面的代码之后是这样的（加粗代码表示更新的部分）：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v('// 创建表格\nlet table = document.createElement("table");\ntable.border = 1;\ntable.width = "100%";\n\n// 创建表体\nlet tbody = document.createElement("tbody");\ntable.appendChild(tbody);\n\n// 创建第一行\ntbody.insertRow(0);\ntbody.rows[0].insertCell(0);\ntbody.rows[0].cells[0].appendChild(document.createTextNode("Cell 1,1"));\ntbody.rows[0].insertCell(1);\ntbody.rows[0].cells[1].appendChild(document.createTextNode("Cell 2,1"));\n\n// 创建第二行\ntbody.insertRow(1);\ntbody.rows[1].insertCell(0);\ntbody.rows[1].cells[0].appendChild(document.createTextNode("Cell 1,2"));\ntbody.rows[1].insertCell(1);\ntbody.rows[1].cells[1].appendChild(document.createTextNode("Cell 2,2"));\n\n// 把表格添加到文档主体\ndocument.body.appendChild(table);\n')])])]),v("p",[e._v("这里创建"),v("code",[e._v("<table>")]),e._v("和"),v("code",[e._v("<tbody>")]),e._v("元素的代码没有变。变化的是创建两行的部分，这次使用了 HTML DOM 表格的属性和方法。创建第一行时，在"),v("code",[e._v("<tbody>")]),e._v("元素上调用了"),v("code",[e._v("insertRow()")]),e._v("方法。传入参数"),v("code",[e._v("0")]),e._v("，表示把这一行放在什么位置。然后，使用"),v("code",[e._v("tbody.rows[0]")]),e._v("来引用这一行，因为这一行刚刚创建并被添加到了"),v("code",[e._v("<tbody>")]),e._v("的位置"),v("code",[e._v("0")]),e._v("。")]),e._v(" "),v("p",[e._v("创建表元的方式也与之类似。在"),v("code",[e._v("<tr>")]),e._v("元素上调用"),v("code",[e._v("insertCell()")]),e._v("方法，传入参数"),v("code",[e._v("0")]),e._v("，表示把这个表元放在什么位置上。然后，使用"),v("code",[e._v("tbody.rows[0].cells[0]")]),e._v("来引用这个表元，因为这个表元刚刚创建并被添加到了"),v("code",[e._v("<tr>")]),e._v("的位置"),v("code",[e._v("0")]),e._v("。")]),e._v(" "),v("p",[e._v("虽然以上两种代码在技术上都是正确的，但使用这些属性和方法创建表格让代码变得更有逻辑性，也更容易理解。")]),e._v(" "),v("h3",{attrs:{id:"_14-2-4-使用nodelist"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_14-2-4-使用nodelist"}},[e._v("#")]),e._v(" 14.2.4 　使用"),v("code",[e._v("NodeList")])]),e._v(" "),v("p",[e._v("理解"),v("code",[e._v("NodeList")]),e._v("对象和相关的"),v("code",[e._v("NamedNodeMap")]),e._v("、"),v("code",[e._v("HTMLCollection")]),e._v("，是理解 DOM 编程的关键。这 3 个集合类型都是“实时的”，意味着文档结构的变化会实时地在它们身上反映出来，因此它们的值始终代表最新的状态。实际上，"),v("code",[e._v("NodeList")]),e._v("就是基于 DOM 文档的实时查询。例如，下面的代码会导致无穷循环：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v('let divs = document.getElementsByTagName("div");\n\nfor (let i = 0; i < divs.length; ++i){\n  let div = document.createElement("div");\n  document.body.appendChild(div);\n}\n')])])]),v("p",[e._v("第一行取得了包含文档中所有"),v("code",[e._v("<div>")]),e._v("元素的"),v("code",[e._v("HTMLCollection")]),e._v("。因为这个集合是“实时的”，所以任何时候只要向页面中添加一个新"),v("code",[e._v("<div>")]),e._v("元素，再查询这个集合就会多一项。因为浏览器不希望保存每次创建的集合，所以就会在每次访问时更新集合。这样就会出现前面使用循环的例子中所演示的问题。每次循环开始，都会求值"),v("code",[e._v("i < divs.length")]),e._v("。这意味着要执行获取所有"),v("code",[e._v("<div>")]),e._v("元素的查询。因为循环体中会创建并向文档添加一个新"),v("code",[e._v("<div>")]),e._v("元素，所以每次循环"),v("code",[e._v("divs.length")]),e._v("的值也会递增。因为两个值都会递增，所以"),v("code",[e._v("i")]),e._v("将永远不会等于"),v("code",[e._v("divs.length")]),e._v("。")]),e._v(" "),v("p",[e._v("使用 ES6 迭代器并不会解决这个问题，因为迭代的是一个永远增长的实时集合。以下代码仍然会导致无穷循环：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v('for (let div of document.getElementsByTagName("div")){\n  let newDiv = document.createElement("div");\n  document.body.appendChild(newDiv);\n}\n')])])]),v("p",[e._v("任何时候要迭代"),v("code",[e._v("NodeList")]),e._v("，最好再初始化一个变量保存当时查询时的长度，然后用循环变量与这个变量进行比较，如下所示：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v('let divs = document.getElementsByTagName("div");\n\nfor (let i = 0, len = divs.length; i < len; ++i) {\n  let div = document.createElement("div");\n  document.body.appendChild(div);\n}\n')])])]),v("p",[e._v("在这个例子中，又初始化了一个保存集合长度的变量"),v("code",[e._v("len")]),e._v("。因为"),v("code",[e._v("len")]),e._v("保存着循环开始时集合的长度，而这个值不会随集合增大动态增长，所以就可以避免前面例子中出现的无穷循环。本章还会使用这种技术来演示迭代"),v("code",[e._v("NodeList")]),e._v("对象的首选方式。")]),e._v(" "),v("p",[e._v("另外，如果不想再初始化一个变量，也可以像下面这样反向迭代集合：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v('let divs = document.getElementsByTagName("div");\n\nfor (let i = divs.length - 1; i >= 0; --i) {\n  let div = document.createElement("div");\n  document.body.appendChild(div);\n}\n')])])]),v("p",[e._v("一般来说，最好限制操作"),v("code",[e._v("NodeList")]),e._v("的次数。因为每次查询都会搜索整个文档，所以最好把查询到的"),v("code",[e._v("NodeList")]),e._v("缓存起来。")]),e._v(" "),v("h2",{attrs:{id:"_14-3-mutationobserver接口"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_14-3-mutationobserver接口"}},[e._v("#")]),e._v(" 14.3 　"),v("code",[e._v("MutationObserver")]),e._v("接口")]),e._v(" "),v("p",[e._v("不久前添加到 DOM 规范中的"),v("code",[e._v("MutationObserver")]),e._v("接口，可以在 DOM 被修改时异步执行回调。使用"),v("code",[e._v("MutationObserver")]),e._v("可以观察整个文档、DOM 树的一部分，或某个元素。此外还可以观察元素属性、子节点、文本，或者前三者任意组合的变化。")]),e._v(" "),v("blockquote",[v("p",[v("strong",[e._v("注意")]),e._v("　新引进"),v("code",[e._v("MutationObserver")]),e._v("接口是为了取代废弃的"),v("code",[e._v("MutationEvent")]),e._v("。")])]),e._v(" "),v("h3",{attrs:{id:"_14-3-1-基本用法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_14-3-1-基本用法"}},[e._v("#")]),e._v(" 14.3.1 　基本用法")]),e._v(" "),v("p",[v("code",[e._v("MutationObserver")]),e._v("的实例要通过调用"),v("code",[e._v("MutationObserver")]),e._v("构造函数并传入一个回调函数来创建：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("let observer = new MutationObserver(() => console.log('DOM was mutated!'));\n")])])]),v("ol",[v("li",[v("p",[v("strong",[e._v("observe()方法")])]),e._v(" "),v("p",[e._v("新创建的"),v("code",[e._v("MutationObserver")]),e._v("实例不会关联 DOM 的任何部分。要把这个"),v("code",[e._v("observer")]),e._v("与 DOM 关联起来，需要使用"),v("code",[e._v("observe()")]),e._v("方法。这个方法接收两个必需的参数：要观察其变化的 DOM 节点，以及一个"),v("code",[e._v("MutationObserverInit")]),e._v("对象。")]),e._v(" "),v("p",[v("code",[e._v("MutationObserverInit")]),e._v("对象用于控制观察哪些方面的变化，是一个键/值对形式配置选项的字典。例如，下面的代码会创建一个观察者（"),v("code",[e._v("observer")]),e._v("）并配置它观察"),v("code",[e._v("<body>")]),e._v("元素上的属性变化：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("let observer = new MutationObserver(() => console.log('<body> attributes changed'));\n\nobserver.observe(document.body, { attributes: true });\n")])])]),v("p",[e._v("执行以上代码后，"),v("code",[e._v("<body>")]),e._v("元素上任何属性发生变化都会被这个"),v("code",[e._v("MutationObserver")]),e._v("实例发现，然后就会异步执行注册的回调函数。"),v("code",[e._v("<body>")]),e._v("元素后代的修改或其他非属性修改都不会触发回调进入任务队列。可以通过以下代码来验证：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("let observer = new MutationObserver(() => console.log('<body> attributes changed'));\n\nobserver.observe(document.body, { attributes: true });\n\ndocument.body.className = 'foo';\nconsole.log('Changed body class');\n\n// Changed body class\n// <body> attributes changed\n")])])]),v("p",[e._v("注意，回调中的"),v("code",[e._v("console.log()")]),e._v("是后执行的。这表明回调并非与实际的 DOM 变化同步执行。")])])]),e._v(" "),v("ol",{attrs:{start:"2"}},[v("li",[v("p",[v("strong",[e._v("回调与 MutationRecord")])]),e._v(" "),v("p",[e._v("每个回调都会收到一个"),v("code",[e._v("MutationRecord")]),e._v("实例的数组。"),v("code",[e._v("MutationRecord")]),e._v("实例包含的信息包括发生了什么变化，以及 DOM 的哪一部分受到了影响。因为回调执行之前可能同时发生多个满足观察条件的事件，所以每次执行回调都会传入一个包含按顺序入队的"),v("code",[e._v("MutationRecord")]),e._v("实例的数组。")]),e._v(" "),v("p",[e._v("下面展示了反映一个属性变化的"),v("code",[e._v("MutationRecord")]),e._v("实例的数组：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("let observer = new MutationObserver(\n    (mutationRecords) => console.log(mutationRecords));\n\nobserver.observe(document.body, { attributes: true });\n\ndocument.body.setAttribute('foo', 'bar');\n// [\n//   {\n//     addedNodes: NodeList [],\n//     attributeName: \"foo\",\n//     attributeNamespace: null,\n//     nextSibling: null,\n//     oldValue: null,\n//     previousSibling: null\n//     removedNodes: NodeList [],\n//     target: body\n//     type: \"attributes\"\n//   }\n// ]\n")])])]),v("p",[e._v("下面是一次涉及命名空间的类似变化：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("let observer = new MutationObserver(\n    (mutationRecords) => console.log(mutationRecords));\n\nobserver.observe(document.body, { attributes: true });\n\ndocument.body.setAttributeNS('baz', 'foo', 'bar');\n\n// [\n//   {\n//     addedNodes: NodeList [],\n//     attributeName: \"foo\",\n//     attributeNamespace: \"baz\",\n//     nextSibling: null,\n//     oldValue: null,\n//     previousSibling: null\n//     removedNodes: NodeList [],\n//     target: body\n//     type: \"attributes\"\n//   }\n// ]\n")])])]),v("p",[e._v("连续修改会生成多个"),v("code",[e._v("MutationRecord")]),e._v("实例，下次回调执行时就会收到包含所有这些实例的数组，顺序为变化事件发生的顺序：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("let observer = new MutationObserver(\n    (mutationRecords) => console.log(mutationRecords));\n\nobserver.observe(document.body, { attributes: true });\n\ndocument.body.className = 'foo';\ndocument.body.className = 'bar';\ndocument.body.className = 'baz';\n\n// [MutationRecord, MutationRecord, MutationRecord]\n")])])]),v("p",[e._v("下表列出了"),v("code",[e._v("MutationRecord")]),e._v("实例的属性。")]),e._v(" "),v("table",[v("thead",[v("tr",[v("th",{staticStyle:{"text-align":"left"}},[e._v("属性")]),e._v(" "),v("th",{staticStyle:{"text-align":"left"}},[e._v("说明")])])]),e._v(" "),v("tbody",[v("tr",[v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("target")])]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[e._v("被修改影响的目标节点")])]),e._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("type")])]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[e._v("字符串，表示变化的类型："),v("code",[e._v('"attributes"')]),e._v("、"),v("code",[e._v('"characterData"')]),e._v("或"),v("code",[e._v('"childList"')])])]),e._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("oldValue")])]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[e._v("如果在"),v("code",[e._v("MutationObserverInit")]),e._v("对象中启用（"),v("code",[e._v("attributeOldValue")]),e._v("或"),v("code",[e._v("characterData OldValue")]),e._v("为"),v("code",[e._v("true")]),e._v("），"),v("code",[e._v('"attributes"')]),e._v("或"),v("code",[e._v('"characterData"')]),e._v("的变化事件会设置这个属性为被替代的值 "),v("code",[e._v('"childList"')]),e._v("类型的变化始终将这个属性设置为"),v("code",[e._v("null")])])]),e._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("attributeName")])]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[e._v("对于"),v("code",[e._v('"attributes"')]),e._v("类型的变化，这里保存被修改属性的名字 其他变化事件会将这个属性设置为"),v("code",[e._v("null")])])]),e._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("attributeNamespace")])]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[e._v("对于使用了命名空间的"),v("code",[e._v('"attributes"')]),e._v("类型的变化，这里保存被修改属性的名字 其他变化事件会将这个属性设置为"),v("code",[e._v("null")])])]),e._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("addedNodes")])]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[e._v("对于"),v("code",[e._v('"childList"')]),e._v("类型的变化，返回包含变化中添加节点的"),v("code",[e._v("NodeList")]),e._v(" 默认为空"),v("code",[e._v("NodeList")])])]),e._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("removedNodes")])]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[e._v("对于"),v("code",[e._v('"childList"')]),e._v("类型的变化，返回包含变化中删除节点的"),v("code",[e._v("NodeList")]),e._v(" 默认为空"),v("code",[e._v("NodeList")])])]),e._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("previousSibling")])]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[e._v("对于"),v("code",[e._v('"childList"')]),e._v("类型的变化，返回变化节点的前一个同胞"),v("code",[e._v("Node")]),e._v(" 默认为"),v("code",[e._v("null")])])]),e._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("nextSibling")])]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[e._v("对于"),v("code",[e._v('"childList"')]),e._v("类型的变化，返回变化节点的后一个同胞"),v("code",[e._v("Node")]),e._v(" 默认为"),v("code",[e._v("null")])])])])]),e._v(" "),v("p",[e._v("传给回调函数的第二个参数是观察变化的"),v("code",[e._v("MutationObserver")]),e._v("的实例，演示如下：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("let observer = new MutationObserver(\n    (mutationRecords, mutationObserver) => console.log(mutationRecords,\nmutationObserver));\n\nobserver.observe(document.body, { attributes: true });\n\ndocument.body.className = 'foo';\n\n// [MutationRecord], MutationObserver\n")])])])])]),e._v(" "),v("ol",{attrs:{start:"3"}},[v("li",[v("p",[v("strong",[e._v("disconnect()方法")])]),e._v(" "),v("p",[e._v("默认情况下，只要被观察的元素不被垃圾回收，"),v("code",[e._v("MutationObserver")]),e._v("的回调就会响应 DOM 变化事件，从而被执行。要提前终止执行回调，可以调用"),v("code",[e._v("disconnect()")]),e._v("方法。下面的例子演示了同步调用"),v("code",[e._v("disconnect()")]),e._v("之后，不仅会停止此后变化事件的回调，也会抛弃已经加入任务队列要异步执行的回调：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("let observer = new MutationObserver(() => console.log('<body> attributes changed'));\n\nobserver.observe(document.body, { attributes: true });\n\ndocument.body.className = 'foo';\n\nobserver.disconnect();\n\ndocument.body.className = 'bar';\n\n//（没有日志输出）\n")])])]),v("p",[e._v("要想让已经加入任务队列的回调执行，可以使用"),v("code",[e._v("setTimeout()")]),e._v("让已经入列的回调执行完毕再调用"),v("code",[e._v("disconnect()")]),e._v("：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("let observer = new MutationObserver(() => console.log('<body> attributes changed'));\n\nobserver.observe(document.body, { attributes: true });\n\ndocument.body.className = 'foo';\n\nsetTimeout(() => {\n  observer.disconnect();\n  document.body.className = 'bar';\n}, 0);\n\n// <body> attributes changed\n")])])])])]),e._v(" "),v("ol",{attrs:{start:"4"}},[v("li",[v("p",[v("strong",[e._v("复用 MutationObserver")])]),e._v(" "),v("p",[e._v("多次调用"),v("code",[e._v("observe()")]),e._v("方法，可以复用一个"),v("code",[e._v("MutationObserver")]),e._v("对象观察多个不同的目标节点。此时，"),v("code",[e._v("MutationRecord")]),e._v("的"),v("code",[e._v("target")]),e._v("属性可以标识发生变化事件的目标节点。下面的示例演示了这个过程：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("let observer = new MutationObserver(\n               (mutationRecords) => console.log(mutationRecords.map((x) =>\nx.target)));\n\n// 向页面主体添加两个子节点\nlet childA = document.createElement('div'),\n    childB = document.createElement('span');\ndocument.body.appendChild(childA);\ndocument.body.appendChild(childB);\n\n// 观察两个子节点\nobserver.observe(childA, { attributes: true });\nobserver.observe(childB, { attributes: true });\n\n// 修改两个子节点的属性\nchildA.setAttribute('foo', 'bar');\nchildB.setAttribute('foo', 'bar');\n\n// [<div>, <span>]\n")])])]),v("p",[v("code",[e._v("disconnect()")]),e._v("方法是一个“一刀切”的方案，调用它会停止观察所有目标：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("let observer = new MutationObserver(\n               (mutationRecords) => console.log(mutationRecords.map((x) =>\nx.target)));\n\n// 向页面主体添加两个子节点\nlet childA = document.createElement('div'),\n    childB = document.createElement('span');\ndocument.body.appendChild(childA);\ndocument.body.appendChild(childB);\n\n// 观察两个子节点\nobserver.observe(childA, { attributes: true });\nobserver.observe(childB, { attributes: true });\n\nobserver.disconnect();\n\n// 修改两个子节点的属性\nchildA.setAttribute('foo', 'bar');\nchildB.setAttribute('foo', 'bar');\n\n// （没有日志输出）\n")])])])])]),e._v(" "),v("ol",{attrs:{start:"5"}},[v("li",[v("p",[v("strong",[e._v("重用 MutationObserver")])]),e._v(" "),v("p",[e._v("调用"),v("code",[e._v("disconnect()")]),e._v("并不会结束"),v("code",[e._v("MutationObserver")]),e._v("的生命。还可以重新使用这个观察者，再将它关联到新的目标节点。下面的示例在两个连续的异步块中先断开然后又恢复了观察者与"),v("code",[e._v("<body>")]),e._v("元素的关联：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("let observer = new MutationObserver(() => console.log('<body> attributes\nchanged'));\n\nobserver.observe(document.body, { attributes: true });\n\n// 这行代码会触发变化事件\ndocument.body.setAttribute('foo', 'bar');\n\nsetTimeout(() => {\n  observer.disconnect();\n\n  // 这行代码不会触发变化事件\n  document.body.setAttribute('bar', 'baz');\n}, 0);\n　\n　\nsetTimeout(() => {\n  // Reattach\n  observer.observe(document.body, { attributes: true });\n\n  // 这行代码会触发变化事件\n  document.body.setAttribute('baz', 'qux');\n}, 0);\n\n// <body> attributes changed\n// <body> attributes changed\n")])])])])]),e._v(" "),v("h3",{attrs:{id:"_14-3-2-mutationobserverinit与观察范围"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_14-3-2-mutationobserverinit与观察范围"}},[e._v("#")]),e._v(" 14.3.2 　"),v("code",[e._v("MutationObserverInit")]),e._v("与观察范围")]),e._v(" "),v("p",[v("code",[e._v("MutationObserverInit")]),e._v("对象用于控制对目标节点的观察范围。粗略地讲，观察者可以观察的事件包括属性变化、文本变化和子节点变化。")]),e._v(" "),v("p",[e._v("下表列出了"),v("code",[e._v("MutationObserverInit")]),e._v("对象的属性。")]),e._v(" "),v("table",[v("thead",[v("tr",[v("th",{staticStyle:{"text-align":"left"}},[e._v("属性")]),e._v(" "),v("th",{staticStyle:{"text-align":"left"}},[e._v("说明")])])]),e._v(" "),v("tbody",[v("tr",[v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("subtree")])]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[e._v("布尔值，表示除了目标节点，是否观察目标节点的子树（后代） 如果是"),v("code",[e._v("false")]),e._v("，则只观察目标节点的变化；如果是"),v("code",[e._v("true")]),e._v("，则观察目标节点及其整个子树 默认为"),v("code",[e._v("false")])])]),e._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("attributes")])]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[e._v("布尔值，表示是否观察目标节点的属性变化 默认为"),v("code",[e._v("false")])])]),e._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("attributeFilter")])]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[e._v("字符串数组，表示要观察哪些属性的变化 把这个值设置为"),v("code",[e._v("true")]),e._v("也会将"),v("code",[e._v("attributes")]),e._v("的值转换为"),v("code",[e._v("true")]),e._v(" 默认为观察所有属性")])]),e._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("attributeOldValue")])]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[e._v("布尔值，表示"),v("code",[e._v("MutationRecord")]),e._v("是否记录变化之前的属性值 把这个值设置为"),v("code",[e._v("true")]),e._v("也会将"),v("code",[e._v("attributes")]),e._v("的值转换为"),v("code",[e._v("true")]),e._v(" 默认为"),v("code",[e._v("false")])])]),e._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("characterData")])]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[e._v("布尔值，表示修改字符数据是否触发变化事件 默认为"),v("code",[e._v("false")])])]),e._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("characterDataOldValue")])]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[e._v("布尔值，表示"),v("code",[e._v("MutationRecord")]),e._v("是否记录变化之前的字符数据 把这个值设置为"),v("code",[e._v("true")]),e._v("也会将"),v("code",[e._v("characterData")]),e._v("的值转换为"),v("code",[e._v("true")]),e._v(" 默认为"),v("code",[e._v("false")])])]),e._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"left"}},[v("code",[e._v("childList")])]),e._v(" "),v("td",{staticStyle:{"text-align":"left"}},[e._v("布尔值，表示修改目标节点的子节点是否触发变化事件 默认为"),v("code",[e._v("false")])])])])]),e._v(" "),v("blockquote",[v("p",[v("strong",[e._v("注意")]),e._v("　在调用"),v("code",[e._v("observe()")]),e._v("时，"),v("code",[e._v("MutationObserverInit")]),e._v("对象中的"),v("code",[e._v("attribute")]),e._v("、"),v("code",[e._v("characterData")]),e._v("和"),v("code",[e._v("childList")]),e._v("属性必须至少有一项为"),v("code",[e._v("true")]),e._v("（无论是直接设置这几个属性，还是通过设置"),v("code",[e._v("attributeOldValue")]),e._v("等属性间接导致它们的值转换为"),v("code",[e._v("true")]),e._v("）。否则会抛出错误，因为没有任何变化事件可能触发回调。")])]),e._v(" "),v("ol",[v("li",[v("p",[v("strong",[e._v("观察属性")])]),e._v(" "),v("p",[v("code",[e._v("MutationObserver")]),e._v("可以观察节点属性的添加、移除和修改。要为属性变化注册回调，需要在"),v("code",[e._v("MutationObserverInit")]),e._v("对象中将"),v("code",[e._v("attributes")]),e._v("属性设置为"),v("code",[e._v("true")]),e._v("，如下所示：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("let observer = new MutationObserver(\n    (mutationRecords) => console.log(mutationRecords));\n\nobserver.observe(document.body, { attributes: true });\n\n// 添加属性\ndocument.body.setAttribute('foo', 'bar');\n\n// 修改属性\ndocument.body.setAttribute('foo', 'baz');\n\n// 移除属性\ndocument.body.removeAttribute('foo');\n\n// 以上变化都被记录下来了\n// [MutationRecord, MutationRecord, MutationRecord]\n")])])]),v("p",[e._v("把"),v("code",[e._v("attributes")]),e._v("设置为"),v("code",[e._v("true")]),e._v("的默认行为是观察所有属性，但不会在"),v("code",[e._v("MutationRecord")]),e._v("对象中记录原来的属性值。如果想观察某个或某几个属性，可以使用"),v("code",[e._v("attributeFilter")]),e._v("属性来设置白名单，即一个属性名字符串数组：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("let observer = new MutationObserver(\n    (mutationRecords) => console.log(mutationRecords));\n\nobserver.observe(document.body, { attributeFilter: ['foo'] });\n\n// 添加白名单属性\ndocument.body.setAttribute('foo', 'bar');\n\n// 添加被排除的属性\ndocument.body.setAttribute('baz', 'qux');\n\n// 只有foo属性的变化被记录了\n// [MutationRecord]\n")])])]),v("p",[e._v("如果想在变化记录中保存属性原来的值，可以将"),v("code",[e._v("attributeOldValue")]),e._v("属性设置为"),v("code",[e._v("true")]),e._v("：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("let observer = new MutationObserver(\n    (mutationRecords) => console.log(mutationRecords.map((x) => x.oldValue)));\n\nobserver.observe(document.body, { attributeOldValue: true });\n\ndocument.body.setAttribute('foo', 'bar');\ndocument.body.setAttribute('foo', 'baz');\ndocument.body.setAttribute('foo', 'qux');\n\n// 每次变化都保留了上一次的值\n// [null, 'bar', 'baz']\n")])])])])]),e._v(" "),v("ol",{attrs:{start:"2"}},[v("li",[v("p",[v("strong",[e._v("观察字符数据")])]),e._v(" "),v("p",[v("code",[e._v("MutationObserver")]),e._v("可以观察文本节点（如"),v("code",[e._v("Text")]),e._v("、"),v("code",[e._v("Comment")]),e._v("或"),v("code",[e._v("ProcessingInstruction")]),e._v("节点）中字符的添加、删除和修改。要为字符数据注册回调，需要在"),v("code",[e._v("MutationObserverInit")]),e._v("对象中将"),v("code",[e._v("characterData")]),e._v("属性设置为"),v("code",[e._v("true")]),e._v("，如下所示：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("let observer = new MutationObserver(\n    (mutationRecords) => console.log(mutationRecords));\n\n// 创建要观察的文本节点\ndocument.body.innerText = 'foo';\n\nobserver.observe(document.body.firstChild, { characterData: true });\n\n// 赋值为相同的字符串\ndocument.body.innerText = 'foo';\n\n// 赋值为新字符串\ndocument.body.innerText = 'bar';\n\n// 通过节点设置函数赋值\ndocument.body.firstChild.textContent = 'baz';\n\n// 以上变化都被记录下来了\n// [MutationRecord, MutationRecord, MutationRecord]\n")])])]),v("p",[e._v("将"),v("code",[e._v("characterData")]),e._v("属性设置为"),v("code",[e._v("true")]),e._v("的默认行为不会在"),v("code",[e._v("MutationRecord")]),e._v("对象中记录原来的字符数据。如果想在变化记录中保存原来的字符数据，可以将"),v("code",[e._v("characterDataOldValue")]),e._v("属性设置为"),v("code",[e._v("true")]),e._v("：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("let observer = new MutationObserver(\n    (mutationRecords) => console.log(mutationRecords.map((x) => x.oldValue)));\ndocument.body.innerText = 'foo';\n\nobserver.observe(document.body.firstChild, { characterDataOldValue: true });\n\ndocument.body.innerText = 'foo';\ndocument.body.innerText = 'bar';\ndocument.body.firstChild.textContent = 'baz';\n\n// 每次变化都保留了上一次的值\n// [\"foo\", \"foo\", \"bar\"]\n")])])])])]),e._v(" "),v("ol",{attrs:{start:"3"}},[v("li",[v("p",[v("strong",[e._v("观察子节点")])]),e._v(" "),v("p",[v("code",[e._v("MutationObserver")]),e._v("可以观察目标节点子节点的添加和移除。要观察子节点，需要在"),v("code",[e._v("MutationObserverInit")]),e._v("对象中将"),v("code",[e._v("childList")]),e._v("属性设置为"),v("code",[e._v("true")]),e._v("。")]),e._v(" "),v("p",[e._v("下面的例子演示了添加子节点：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("// 清空主体\ndocument.body.innerHTML = '';\n\nlet observer = new MutationObserver(\n    (mutationRecords) => console.log(mutationRecords));\n\nobserver.observe(document.body, { childList: true });\n\ndocument.body.appendChild(document.createElement('div'));\n\n// [\n//   {\n//     addedNodes: NodeList[div],\n//     attributeName: null,\n//     attributeNamespace: null,\n//     oldValue: null,\n//     nextSibling: null,\n//     previousSibling: null,\n//     removedNodes: NodeList[],\n//     target: body,\n//     type: \"childList\",\n//   }\n// ]\n")])])]),v("p",[e._v("下面的例子演示了移除子节点：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("// 清空主体\ndocument.body.innerHTML = '';\n\nlet observer = new MutationObserver(\n    (mutationRecords) => console.log(mutationRecords));\n\nobserver.observe(document.body, { childList: true });\n\ndocument.body.appendChild(document.createElement('div'));\n\n// [\n//   {\n//     addedNodes: NodeList[],\n//     attributeName: null,\n//     attributeNamespace: null,\n//     oldValue: null,\n//     nextSibling: null,\n//     previousSibling: null,\n//     removedNodes: NodeList[div],\n//     target: body,\n//     type: \"childList\",\n//   }\n// ]\n")])])]),v("p",[e._v("对子节点"),v("strong",[e._v("重新排序")]),e._v("（尽管调用一个方法即可实现）会报告两次变化事件，因为从技术上会涉及先移除和再添加：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("// 清空主体\ndocument.body.innerHTML = '';\n\nlet observer = new MutationObserver(\n    (mutationRecords) => console.log(mutationRecords));\n\n// 创建两个初始子节点\ndocument.body.appendChild(document.createElement('div'));\ndocument.body.appendChild(document.createElement('span'));\n\nobserver.observe(document.body, { childList: true });\n\n// 交换子节点顺序\ndocument.body.insertBefore(document.body.lastChild, document.body.firstChild);\n\n// 发生了两次变化：第一次是节点被移除，第二次是节点被添加\n// [\n//   {\n//     addedNodes: NodeList[],\n//     attributeName: null,\n//     attributeNamespace: null,\n//     oldValue: null,\n//     nextSibling: null,\n//     previousSibling: div,\n//     removedNodes: NodeList[span],\n//     target: body,\n//       type: childList,\n//   },\n//   {\n//     addedNodes: NodeList[span],\n//     attributeName: null,\n//     attributeNamespace: null,\n//     oldValue: null,\n//     nextSibling: div,\n//     previousSibling: null,\n//     removedNodes: NodeList[],\n//     target: body,\n//     type: \"childList\",\n//   }\n// ]\n")])])])])]),e._v(" "),v("ol",{attrs:{start:"4"}},[v("li",[v("p",[v("strong",[e._v("观察子树")])]),e._v(" "),v("p",[e._v("默认情况下，"),v("code",[e._v("MutationObserver")]),e._v("将观察的范围限定为一个元素及其子节点的变化。可以把观察的范围扩展到这个元素的子树（所有后代节点），这需要在"),v("code",[e._v("MutationObserverInit")]),e._v("对象中将"),v("code",[e._v("subtree")]),e._v("属性设置为"),v("code",[e._v("true")]),e._v("。")]),e._v(" "),v("p",[e._v("下面的代码展示了观察元素及其后代节点属性的变化：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("// 清空主体\ndocument.body.innerHTML = '';\n\nlet observer = new MutationObserver(\n    (mutationRecords) => console.log(mutationRecords));\n\n// 创建一个后代\ndocument.body.appendChild(document.createElement('div'));\n\n// 观察<body>元素及其子树\nobserver.observe(document.body, { attributes: true, subtree: true });\n\n// 修改<body>元素的子树\ndocument.body.firstChild.setAttribute('foo', 'bar');\n\n// 记录了子树变化的事件\n// [\n//   {\n//     addedNodes: NodeList[],\n//     attributeName: \"foo\",\n//     attributeNamespace: null,\n//     oldValue: null,\n//     nextSibling: null,\n//     previousSibling: null,\n//     removedNodes: NodeList[],\n//     target: div,\n//     type: \"attributes\",\n//   }\n// ]\n")])])]),v("p",[e._v("有意思的是，被观察子树中的节点被移出子树之后仍然能够触发变化事件。这意味着在子树中的节点离开该子树后，即使严格来讲该节点已经脱离了原来的子树，但它仍然会触发变化事件。")]),e._v(" "),v("p",[e._v("下面的代码演示了这种情况：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("// 清空主体\ndocument.body.innerHTML = '';\n\nlet observer = new MutationObserver(\n    (mutationRecords) => console.log(mutationRecords));\n\nlet subtreeRoot = document.createElement('div'),\n    subtreeLeaf = document.createElement('span');\n\n// 创建包含两层的子树\ndocument.body.appendChild(subtreeRoot);\nsubtreeRoot.appendChild(subtreeLeaf);\n\n// 观察子树\nobserver.observe(subtreeRoot, { attributes: true, subtree: true });\n\n// 把节点转移到其他子树\ndocument.body.insertBefore(subtreeLeaf, subtreeRoot);\n\nsubtreeLeaf.setAttribute('foo', 'bar');\n\n// 移出的节点仍然触发变化事件\n// [MutationRecord]\n")])])])])]),e._v(" "),v("h3",{attrs:{id:"_14-3-3-异步回调与记录队列"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_14-3-3-异步回调与记录队列"}},[e._v("#")]),e._v(" 14.3.3 　异步回调与记录队列")]),e._v(" "),v("p",[v("code",[e._v("MutationObserver")]),e._v("接口是出于性能考虑而设计的，其核心是异步回调与记录队列模型。为了在大量变化事件发生时不影响性能，每次变化的信息（由观察者实例决定）会保存在"),v("code",[e._v("MutationRecord")]),e._v("实例中，然后添加到"),v("strong",[e._v("记录队列")]),e._v("。这个队列对每个"),v("code",[e._v("MutationObserver")]),e._v("实例都是唯一的，是所有 DOM 变化事件的有序列表。")]),e._v(" "),v("ol",[v("li",[v("p",[v("strong",[e._v("记录队列")])]),e._v(" "),v("p",[e._v("每次"),v("code",[e._v("MutationRecord")]),e._v("被添加到"),v("code",[e._v("MutationObserver")]),e._v("的记录队列时，仅当之前没有已排期的微任务回调时（队列中微任务长度为 0），才会将观察者注册的回调（在初始化"),v("code",[e._v("MutationObserver")]),e._v("时传入）作为微任务调度到任务队列上。这样可以保证记录队列的内容不会被回调处理两次。")]),e._v(" "),v("p",[e._v("不过在回调的微任务异步执行期间，有可能又会发生更多变化事件。因此被调用的回调会接收到一个"),v("code",[e._v("MutationRecord")]),e._v("实例的数组，顺序为它们进入记录队列的顺序。回调要负责处理这个数组的每一个实例，因为函数退出之后这些实现就不存在了。回调执行后，这些"),v("code",[e._v("MutationRecord")]),e._v("就用不着了，因此记录队列会被清空，其内容会被丢弃。")])])]),e._v(" "),v("ol",{attrs:{start:"2"}},[v("li",[v("p",[v("strong",[e._v("takeRecords()方法")])]),e._v(" "),v("p",[e._v("调用"),v("code",[e._v("MutationObserver")]),e._v("实例的"),v("code",[e._v("takeRecords()")]),e._v("方法可以清空记录队列，取出并返回其中的所有"),v("code",[e._v("MutationRecord")]),e._v("实例。看这个例子：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("let observer = new MutationObserver(\n    (mutationRecords) => console.log(mutationRecords));\n\nobserver.observe(document.body, { attributes: true });\n\ndocument.body.className = 'foo';\ndocument.body.className = 'bar';\ndocument.body.className = 'baz';\n\nconsole.log(observer.takeRecords());\nconsole.log(observer.takeRecords());\n\n// [MutationRecord, MutationRecord, MutationRecord]\n// []\n")])])]),v("p",[e._v("这在希望断开与观察目标的联系，但又希望处理由于调用"),v("code",[e._v("disconnect()")]),e._v("而被抛弃的记录队列中的"),v("code",[e._v("MutationRecord")]),e._v("实例时比较有用。")])])]),e._v(" "),v("h3",{attrs:{id:"_14-3-4-性能、内存与垃圾回收"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_14-3-4-性能、内存与垃圾回收"}},[e._v("#")]),e._v(" 14.3.4 　性能、内存与垃圾回收")]),e._v(" "),v("p",[e._v("DOM Level 2 规范中描述的"),v("code",[e._v("MutationEvent")]),e._v("定义了一组会在各种 DOM 变化时触发的事件。由于浏览器事件的实现机制，这个接口出现了严重的性能问题。因此，DOM Level 3 规定废弃了这些事件。"),v("code",[e._v("MutationObserver")]),e._v("接口就是为替代这些事件而设计的更实用、性能更好的方案。")]),e._v(" "),v("p",[e._v("将变化回调委托给微任务来执行可以保证事件同步触发，同时避免随之而来的混乱。为"),v("code",[e._v("MutationObserver")]),e._v("而实现的记录队列，可以保证即使变化事件被爆发式地触发，也不会显著地拖慢浏览器。")]),e._v(" "),v("p",[e._v("无论如何，使用"),v("code",[e._v("MutationObservder")]),e._v("仍然"),v("strong",[e._v("不是没有代价")]),e._v("的。因此理解什么时候避免出现这种情况就很重要了。")]),e._v(" "),v("ol",[v("li",[v("p",[v("strong",[e._v("MutationObserver 的引用")])]),e._v(" "),v("p",[v("code",[e._v("MutationObserver")]),e._v("实例与目标节点之间的引用关系是非对称的。"),v("code",[e._v("MutationObserver")]),e._v("拥有对要观察的目标节点的弱引用。因为是弱引用，所以不会妨碍垃圾回收程序回收目标节点。")]),e._v(" "),v("p",[e._v("然而，目标节点却拥有对"),v("code",[e._v("MutationObserver")]),e._v("的强引用。如果目标节点从 DOM 中被移除，随后被垃圾回收，则关联的"),v("code",[e._v("MutationObserver")]),e._v("也会被垃圾回收。")])])]),e._v(" "),v("ol",{attrs:{start:"2"}},[v("li",[v("p",[v("strong",[e._v("MutationRecord 的引用")])]),e._v(" "),v("p",[e._v("记录队列中的每个"),v("code",[e._v("MutationRecord")]),e._v("实例至少包含对已有 DOM 节点的一个引用。如果变化是"),v("code",[e._v("childList")]),e._v("类型，则会包含多个节点的引用。记录队列和回调处理的默认行为是耗尽这个队列，处理每个"),v("code",[e._v("MutationRecord")]),e._v("，然后让它们超出作用域并被垃圾回收。")]),e._v(" "),v("p",[e._v("有时候可能需要保存某个观察者的完整变化记录。保存这些"),v("code",[e._v("MutationRecord")]),e._v("实例，也就会保存它们引用的节点，因而会妨碍这些节点被回收。如果需要尽快地释放内存，建议从每个"),v("code",[e._v("MutationRecord")]),e._v("中抽取出最有用的信息，然后保存到一个新对象中，最后抛弃"),v("code",[e._v("MutationRecord")]),e._v("。")])])]),e._v(" "),v("h2",{attrs:{id:"_14-4-小结"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_14-4-小结"}},[e._v("#")]),e._v(" 14.4 　小结")]),e._v(" "),v("p",[e._v("文档对象模型（DOM，Document Object Model）是语言中立的 HTML 和 XML 文档的 API。DOM Level 1 将 HTML 和 XML 文档定义为一个节点的多层级结构，并暴露出 JavaScript 接口以操作文档的底层结构和外观。")]),e._v(" "),v("p",[e._v("DOM 由一系列节点类型构成，主要包括以下几种。")]),e._v(" "),v("ul",[v("li",[v("code",[e._v("Node")]),e._v("是基准节点类型，是文档一个部分的抽象表示，所有其他类型都继承"),v("code",[e._v("Node")]),e._v("。")]),e._v(" "),v("li",[v("code",[e._v("Document")]),e._v("类型表示整个文档，对应树形结构的根节点。在 JavaScript 中，"),v("code",[e._v("document")]),e._v("对象是"),v("code",[e._v("Document")]),e._v("的实例，拥有查询和获取节点的很多方法。")]),e._v(" "),v("li",[v("code",[e._v("Element")]),e._v("节点表示文档中所有 HTML 或 XML 元素，可以用来操作它们的内容和属性。")]),e._v(" "),v("li",[e._v("其他节点类型分别表示文本内容、注释、文档类型、CDATA 区块和文档片段。")])]),e._v(" "),v("p",[e._v("DOM 编程在多数情况下没什么问题，在涉及"),v("code",[e._v("<script>")]),e._v("和"),v("code",[e._v("<style>")]),e._v("元素时会有一点兼容性问题。因为这些元素分别包含脚本和样式信息，所以浏览器会将它们与其他元素区别对待。")]),e._v(" "),v("p",[e._v("要理解 DOM，最关键的一点是知道影响其性能的问题所在。DOM 操作在 JavaScript 代码中是代价比较高的，"),v("code",[e._v("NodeList")]),e._v("对象尤其需要注意。"),v("code",[e._v("NodeList")]),e._v("对象是“实时更新”的，这意味着每次访问它都会执行一次新的查询。考虑到这些问题，实践中要尽量减少 DOM 操作的数量。")]),e._v(" "),v("p",[v("code",[e._v("MutationObserver")]),e._v("是为代替性能不好的"),v("code",[e._v("MutationEvent")]),e._v("而问世的。使用它可以有效精准地监控 DOM 变化，而且 API 也相对简单。")])])},a=[]},471:function(e,t,v){"use strict";v.r(t);var _=v(470),a=v(321);for(var l in a)["default"].indexOf(l)<0&&function(e){v.d(t,e,(function(){return a[e]}))}(l);var d=v(27),o=Object(d.a)(a.default,_.a,_.b,!1,null,null,null);t.default=o.exports}}]);