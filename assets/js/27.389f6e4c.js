(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{416:function(a,t,n){a.exports=n.p+"assets/img/canvas_sun.bf19be78.png"},491:function(a,t,n){"use strict";n.r(t);var e=n(27),s=Object(e.a)({},(function(){var a=this,t=a.$createElement,e=a._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h1",{attrs:{id:"canvas基础二"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#canvas基础二"}},[a._v("#")]),a._v(" Canvas基础二")]),a._v(" "),e("h2",{attrs:{id:"动画"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#动画"}},[a._v("#")]),a._v(" 动画")]),a._v(" "),e("p",[a._v("canvas动画最大的限制是图像一旦绘制,就一直保持原样,如果要移动它,必须对所有东西重绘")]),a._v(" "),e("h3",{attrs:{id:"动画的基本步骤"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#动画的基本步骤"}},[a._v("#")]),a._v(" 动画的基本步骤")]),a._v(" "),e("ol",[e("li",[a._v("清空canvas clearRect()")]),a._v(" "),e("li",[a._v("保存canvas状态")]),a._v(" "),e("li",[a._v("绘制动画图形")]),a._v(" "),e("li",[a._v("恢复canvas状态")])]),a._v(" "),e("h3",{attrs:{id:"操控动画"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#操控动画"}},[a._v("#")]),a._v(" 操控动画")]),a._v(" "),e("p",[a._v("在canvas中绘制内容是用canvas提供的方法,通常,我们仅仅在脚本执行结束后才能看到结果.因此,为了实现动画,我们需要定时执行重绘")]),a._v(" "),e("h4",{attrs:{id:"有安排的更新画布"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#有安排的更新画布"}},[a._v("#")]),a._v(" 有安排的更新画布")]),a._v(" "),e("ul",[e("li",[a._v("setInterval(function, delay) 多次定期执行")]),a._v(" "),e("li",[a._v("setTimeout(function, delay) 执行一次")]),a._v(" "),e("li",[a._v("requestAnimationFrame(callback) 告诉浏览器希望执行动画,在重绘前,请求浏览器执行一个特定的函数来更新动画")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("var sun = new Image();\nvar moon = new Image();\nvar earth = new Image();\nfunction init(){\n  sun.src = 'https://mdn.mozillademos.org/files/1456/Canvas_sun.png';\n  moon.src = 'https://mdn.mozillademos.org/files/1443/Canvas_moon.png';\n  earth.src = 'https://mdn.mozillademos.org/files/1429/Canvas_earth.png';\n  window.requestAnimationFrame(draw);\n}\n\nfunction draw() {\n  var ctx = document.getElementById('canvas').getContext('2d');\n\n  ctx.globalCompositeOperation = 'destination-over';\n  ctx.clearRect(0,0,300,300); // clear canvas\n\n  ctx.fillStyle = 'rgba(0,0,0,0.4)';\n  ctx.strokeStyle = 'rgba(0,153,255,0.4)';\n  ctx.save();\n  ctx.translate(150,150);\n\n  // Earth\n  var time = new Date();\n  ctx.rotate( ((2*Math.PI)/60)*time.getSeconds() + ((2*Math.PI)/60000)*time.getMilliseconds() );\n  ctx.translate(105,0);\n  ctx.fillRect(0,-12,50,24); // Shadow\n  ctx.drawImage(earth,-12,-12);\n\n  // Moon\n  ctx.save();\n  ctx.rotate( ((2*Math.PI)/6)*time.getSeconds() + ((2*Math.PI)/6000)*time.getMilliseconds() );\n  ctx.translate(0,28.5);\n  ctx.drawImage(moon,-3.5,-3.5);\n  ctx.restore();\n\n  ctx.restore();\n  \n  ctx.beginPath();\n  ctx.arc(150,150,105,0,Math.PI*2,false); // Earth orbit\n  ctx.stroke();\n \n  ctx.drawImage(sun,0,0,300,300);\n\n  window.requestAnimationFrame(draw);\n}\n\ninit();\n")])])]),e("p",[e("img",{attrs:{src:n(416),alt:"canvas animation"}})]),a._v(" "),e("p",[a._v("小球动画并通过鼠标控制")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("var canvas = document.getElementById('canvas');\nvar ctx = canvas.getContext('2d');\nvar raf;\nvar running = false;\n\nvar ball = {\n  x: 100,\n  y: 100,\n  vx: 5,\n  vy: 1,\n  radius: 25,\n  color: 'blue',\n  draw: function() {\n    ctx.beginPath();\n    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2, true);\n    ctx.closePath();\n    ctx.fillStyle = this.color;\n    ctx.fill();\n  }\n};\n\nfunction clear() {\n  ctx.fillStyle = 'rgba(255,255,255,0.3)';\n  ctx.fillRect(0,0,canvas.width,canvas.height);\n}\n\nfunction draw() {\n  clear();\n  ball.draw();\n  ball.x += ball.vx;\n  ball.y += ball.vy;\n\n  if (ball.y + ball.vy > canvas.height || ball.y + ball.vy < 0) {\n    ball.vy = -ball.vy;\n  }\n  if (ball.x + ball.vx > canvas.width || ball.x + ball.vx < 0) {\n    ball.vx = -ball.vx;\n  }\n\n  raf = window.requestAnimationFrame(draw);\n}\n\ncanvas.addEventListener('mousemove', function(e){\n  if (!running) {\n    clear();\n    ball.x = e.clientX;\n    ball.y = e.clientY;\n    ball.draw();\n  }\n});\n\ncanvas.addEventListener('click',function(e){\n  if (!running) {\n    raf = window.requestAnimationFrame(draw);\n    running = true;\n  }\n});\n\ncanvas.addEventListener('mouseout', function(e){\n  window.cancelAnimationFrame(raf);\n  running = false;\n});\n\nball.draw();\n")])])]),e("h2",{attrs:{id:"像素操作"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#像素操作"}},[a._v("#")]),a._v(" 像素操作")]),a._v(" "),e("h3",{attrs:{id:"imagedata对象"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#imagedata对象"}},[a._v("#")]),a._v(" ImageData对象")]),a._v(" "),e("p",[a._v("ImageData对象中存储着canvas对象真实的像素数据,包含几个只读属性:")]),a._v(" "),e("ul",[e("li",[a._v("width 图片宽度,单位为像素")]),a._v(" "),e("li",[a._v("height 图片高度")]),a._v(" "),e("li",[a._v("data 一维数组,包含RGBA格式的整型数据,包含所有像素数据,每个像素使用四个值(RGBA)代表")])]),a._v(" "),e("h3",{attrs:{id:"创建一个imagedata对象"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#创建一个imagedata对象"}},[a._v("#")]),a._v(" 创建一个ImageData对象")]),a._v(" "),e("ol",[e("li",[e("p",[a._v("var myImageData = ctx.createImageData(width, height);")]),a._v(" "),e("p",[a._v("创建一个width和height固定的ImageData对象,所有像素被预设为透明黑")])]),a._v(" "),e("li",[e("p",[a._v("var myImageData = ctx.createImageData(anotherImageData);")]),a._v(" "),e("p",[a._v("创建一个和anotherImageData宽高相同的ImageData对象,所有像素被预设为透明黑")])])]),a._v(" "),e("h3",{attrs:{id:"获取场景像素数据"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#获取场景像素数据"}},[a._v("#")]),a._v(" 获取场景像素数据")]),a._v(" "),e("ul",[e("li",[e("p",[a._v("var myImageData = ctx.getImageData(left, top, width, height);")]),a._v(" "),e("p",[a._v("getImageData方法会返回一个ImageData对象,代表了画布区域的对象数据")])])]),a._v(" "),e("h3",{attrs:{id:"在场景中写入像素数据"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#在场景中写入像素数据"}},[a._v("#")]),a._v(" 在场景中写入像素数据")]),a._v(" "),e("ul",[e("li",[a._v("ctx.putImageData(myImageData, dx, dy); dx,dy参数表示希望场景内左上角绘制的像素数据的坐标")])]),a._v(" "),e("h3",{attrs:{id:"反锯齿"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#反锯齿"}},[a._v("#")]),a._v(" 反锯齿")]),a._v(" "),e("ul",[e("li",[a._v("imageSmoothingEnabled  boolean类型,默认为true,开启反锯齿")])]),a._v(" "),e("h3",{attrs:{id:"保存图片"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#保存图片"}},[a._v("#")]),a._v(" 保存图片")]),a._v(" "),e("ul",[e("li",[a._v("canvas.toDataURL('image/png') 默认设置,将canvas导出为png图片")]),a._v(" "),e("li",[a._v("canvas.toDataURL('image/jpeg', quality) 创建一个jpg图片,quality为0-1的值,1表示图片品质最好,0表示不被辨析但文件体积较小")]),a._v(" "),e("li",[a._v("canvas.toBlob(callback, type, encoderOptions) 创建一个图片的Blob对象,callback回调函数可获取生成的Blob对象,type指定图片格式,默认image/png,encoderOptions为Number类型,值在0-1之间,请求格式为image/jpeg,image/webp时用来指定图片质量")])]),a._v(" "),e("h2",{attrs:{id:"性能优化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#性能优化"}},[a._v("#")]),a._v(" 性能优化")]),a._v(" "),e("ul",[e("li",[a._v("在离屏canvas上预渲染相似的图形或重复的对象")]),a._v(" "),e("li",[a._v("避免浮点数的坐标点,用整数取而代之")]),a._v(" "),e("li",[a._v("在离屏canvas中缓存图片的不同尺寸,而不要用drawImage去缩放它们")]),a._v(" "),e("li",[a._v("使用多层画布去画一个复杂的场景")]),a._v(" "),e("li",[a._v("用css设置大的背景图")]),a._v(" "),e("li",[a._v("用css transforms特性缩放画布")]),a._v(" "),e("li",[a._v("关闭透明度canvas.getContext('2d', { alpha: false })")]),a._v(" "),e("li",[a._v("将画布的函数调用集中在一起")]),a._v(" "),e("li",[a._v("避免不必要的画布状态改变")]),a._v(" "),e("li",[a._v("渲染画布中的不同点,而非整个新状态")]),a._v(" "),e("li",[a._v("尽可能避免shadowBlur(模糊程度)特性")]),a._v(" "),e("li",[a._v("尽可能避免text rendering(文本渲染)")]),a._v(" "),e("li",[a._v("使用不同的办法去清除画布(clearRect, fillRect, 调整canvas大小)")]),a._v(" "),e("li",[a._v("有动画时,使用requestAnimationFrame而非setInterval")]),a._v(" "),e("li",[a._v("谨慎使用大型物理库")])])])}),[],!1,null,null,null);t.default=s.exports}}]);