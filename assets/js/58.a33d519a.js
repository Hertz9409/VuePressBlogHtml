(window.webpackJsonp=window.webpackJsonp||[]).push([[58],{518:function(e,t,r){"use strict";r.r(t);var o=r(27),n=Object(o.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h2",{attrs:{id:"第-9-章-代理与反射"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#第-9-章-代理与反射"}},[e._v("#")]),e._v(" 第 9 章　代理与反射")]),e._v(" "),r("blockquote",[r("p",[r("strong",[e._v("本章内容")])]),e._v(" "),r("ul",[r("li",[e._v("代理基础")]),e._v(" "),r("li",[e._v("代码捕获器与反射方法")]),e._v(" "),r("li",[e._v("代理模式")])])]),e._v(" "),r("p",[e._v("ECMAScript 6 新增的代理和反射为开发者提供了拦截并向基本操作嵌入额外行为的能力。具体地说，可以给目标对象定义一个关联的代理对象，而这个代理对象可以作为抽象的目标对象来使用。在对目标对象的各种操作影响目标对象之前，可以在代理对象中对这些操作加以控制。")]),e._v(" "),r("p",[e._v("对刚刚接触这个主题的开发者而言，代理是一个比较模糊的概念，而且还夹杂着很多新术语。其实只要看几个例子，就很容易理解了。")]),e._v(" "),r("blockquote",[r("p",[r("strong",[e._v("注意")]),e._v("　在 ES6 之前，ECMAScript 中并没有类似代理的特性。由于代理是一种新的基础性语言能力，很多转译程序都不能把代理行为转换为之前的 ECMAScript 代码，因为代理的行为实际上是无可替代的。为此，代理和反射只在百分之百支持它们的平台上有用。可以检测代理是否存在，不存在则提供后备代码。不过这会导致代码冗余，因此并不推荐。")])]),e._v(" "),r("h2",{attrs:{id:"_9-1-代理基础"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_9-1-代理基础"}},[e._v("#")]),e._v(" 9.1 　代理基础")]),e._v(" "),r("p",[e._v("正如本章开头所介绍的，代理是目标对象的抽象。从很多方面看，代理类似 C++指针，因为它可以用作目标对象的替身，但又完全独立于目标对象。目标对象既可以直接被操作，也可以通过代理来操作。但直接操作会绕过代理施予的行为。")]),e._v(" "),r("blockquote",[r("p",[r("strong",[e._v("注意")]),e._v("　 ECMAScript 代理与 C++指针有重大区别，后面会再讨论。不过作为一种有助于理解的类比，指针在概念上还是比较合适的结构。")])]),e._v(" "),r("h3",{attrs:{id:"_9-1-1-创建空代理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_9-1-1-创建空代理"}},[e._v("#")]),e._v(" 9.1.1 　创建空代理")]),e._v(" "),r("p",[e._v("最简单的代理是空代理，即除了作为一个抽象的目标对象，什么也不做。默认情况下，在代理对象上执行的所有操作都会无障碍地传播到目标对象。因此，在任何可以使用目标对象的地方，都可以通过同样的方式来使用与之关联的代理对象。")]),e._v(" "),r("p",[e._v("代理是使用"),r("code",[e._v("Proxy")]),e._v("构造函数创建的。这个构造函数接收两个参数：目标对象和处理程序对象。缺少其中任何一个参数都会抛出"),r("code",[e._v("TypeError")]),e._v("。要创建空代理，可以传一个简单的对象字面量作为处理程序对象，从而让所有操作畅通无阻地抵达目标对象。")]),e._v(" "),r("p",[e._v("如下面的代码所示，在代理对象上执行的任何操作实际上都会应用到目标对象。唯一可感知的不同就是代码中操作的是代理对象。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("const target = {\n  id: 'target'\n};\n\nconst handler = {};\n\nconst proxy = new Proxy(target, handler);\n\n// id属性会访问同一个值\nconsole.log(target.id);  // target\nconsole.log(proxy.id);   // target\n\n// 给目标属性赋值会反映在两个对象上\n// 因为两个对象访问的是同一个值\ntarget.id = 'foo';\nconsole.log(target.id); // foo\nconsole.log(proxy.id);  // foo\n\n// 给代理属性赋值会反映在两个对象上\n// 因为这个赋值会转移到目标对象\nproxy.id = 'bar';\nconsole.log(target.id); // bar\nconsole.log(proxy.id);  // bar\n\n// hasOwnProperty()方法在两个地方\n// 都会应用到目标对象\nconsole.log(target.hasOwnProperty('id')); // true\nconsole.log(proxy.hasOwnProperty('id'));  // true\n\n// Proxy.prototype是undefined\n// 因此不能使用instanceof操作符\nconsole.log(target instanceof Proxy); // TypeError: Function has non-object prototype 'undefined' in instanceof check\nconsole.log(proxy instanceof Proxy);  // TypeError: Function has non-object prototype 'undefined' in instanceof check\n\n// 严格相等可以用来区分代理和目标\nconsole.log(target === proxy); // false\n")])])]),r("h3",{attrs:{id:"_9-1-2-定义捕获器"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_9-1-2-定义捕获器"}},[e._v("#")]),e._v(" 9.1.2 　定义捕获器")]),e._v(" "),r("p",[e._v("使用代理的主要目的是可以定义"),r("strong",[e._v("捕获器")]),e._v("（trap）。捕获器就是在处理程序对象中定义的“基本操作的拦截器”。每个处理程序对象可以包含零个或多个捕获器，每个捕获器都对应一种基本操作，可以直接或间接在代理对象上调用。每次在代理对象上调用这些基本操作时，代理可以在这些操作传播到目标对象之前先调用捕获器函数，从而拦截并修改相应的行为。")]),e._v(" "),r("blockquote",[r("p",[r("strong",[e._v("注意")]),e._v("　捕获器（trap）是从操作系统中借用的概念。在操作系统中，捕获器是程序流中的一个同步中断，可以暂停程序流，转而执行一段子例程，之后再返回原始程序流。")])]),e._v(" "),r("p",[e._v("例如，可以定义一个"),r("code",[e._v("get()")]),e._v("捕获器，在 ECMAScript 操作以某种形式调用"),r("code",[e._v("get()")]),e._v("时触发。下面的例子定义了一个"),r("code",[e._v("get()")]),e._v("捕获器：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("const target = {\n  foo: 'bar'\n};\n\nconst handler = {\n  // 捕获器在处理程序对象中以方法名为键\n  get() {\n    return 'handler override';\n  }\n};\n\nconst proxy = new Proxy(target, handler);\n")])])]),r("p",[e._v("这样，当通过代理对象执行"),r("code",[e._v("get()")]),e._v("操作时，就会触发定义的"),r("code",[e._v("get()")]),e._v("捕获器。当然，"),r("code",[e._v("get()")]),e._v("不是 ECMAScript 对象可以调用的方法。这个操作在 JavaScript 代码中可以通过多种形式触发并被"),r("code",[e._v("get()")]),e._v("捕获器拦截到。"),r("code",[e._v("proxy[property]")]),e._v("、"),r("code",[e._v("proxy.property")]),e._v("或"),r("code",[e._v("Object.create(proxy)[property]")]),e._v("等操作都会触发基本的"),r("code",[e._v("get()")]),e._v("操作以获取属性。因此所有这些操作只要发生在代理对象上，就会触发"),r("code",[e._v("get()")]),e._v("捕获器。注意，只有在代理对象上执行这些操作才会触发捕获器。在目标对象上执行这些操作仍然会产生正常的行为。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("const target = {\n  foo: 'bar'\n};\n\nconst handler = {\n  // 捕获器在处理程序对象中以方法名为键\n  get() {\n    return 'handler override';\n  }\n};\n\nconst proxy = new Proxy(target, handler);\n\nconsole.log(target.foo);                    // bar\nconsole.log(proxy.foo);                     // handler override\n\nconsole.log(target['foo']);                 // bar\nconsole.log(proxy['foo']);                  // handler override\n\nconsole.log(Object.create(target)['foo']);  // bar\nconsole.log(Object.create(proxy)['foo']);   // handler override\n")])])]),r("h3",{attrs:{id:"_9-1-3-捕获器参数和反射-api"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_9-1-3-捕获器参数和反射-api"}},[e._v("#")]),e._v(" 9.1.3 　捕获器参数和反射 API")]),e._v(" "),r("p",[e._v("所有捕获器都可以访问相应的参数，基于这些参数可以重建被捕获方法的原始行为。比如，"),r("code",[e._v("get()")]),e._v("捕获器会接收到目标对象、要查询的属性和代理对象三个参数。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("const target = {\n  foo: 'bar'\n};\n\nconst handler = {\n  get(trapTarget, property, receiver) {\n    console.log(trapTarget === target);\n    console.log(property);\n    console.log(receiver === proxy);\n  }\n};\n\nconst proxy = new Proxy(target, handler);\n\nproxy.foo;\n// true\n// foo\n// true\n")])])]),r("p",[e._v("有了这些参数，就可以重建被捕获方法的原始行为：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("const target = {\n  foo: 'bar'\n};\n\nconst handler = {\n  get(trapTarget, property, receiver) {\n    return trapTarget[property];\n  }\n};\n\nconst proxy = new Proxy(target, handler);\n\nconsole.log(proxy.foo);  // bar\nconsole.log(target.foo); // bar\n")])])]),r("p",[e._v("所有捕获器都可以基于自己的参数重建原始操作，但并非所有捕获器行为都像"),r("code",[e._v("get()")]),e._v("那么简单。因此，通过手动写码如法炮制的想法是不现实的。实际上，开发者并不需要手动重建原始行为，而是可以通过调用全局"),r("code",[e._v("Reflect")]),e._v("对象上（封装了原始行为）的同名方法来轻松重建。")]),e._v(" "),r("p",[e._v("处理程序对象中所有可以捕获的方法都有对应的反射（Reflect）API 方法。这些方法与捕获器拦截的方法具有相同的名称和函数签名，而且也具有与被拦截方法相同的行为。因此，使用反射 API 也可以像下面这样定义出空代理对象：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("const target = {\n  foo: 'bar'\n};\n\nconst handler = {\n  get() {\n    return Reflect.get(...arguments);\n  }\n};\n\nconst proxy = new Proxy(target, handler);\n\nconsole.log(proxy.foo);   // bar\nconsole.log(target.foo);  // bar\n")])])]),r("p",[e._v("甚至还可以写得更简洁一些：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("const target = {\n  foo: 'bar'\n};\n\nconst handler = {\n  get: Reflect.get\n};\n\nconst proxy = new Proxy(target, handler);\n\nconsole.log(proxy.foo);  // bar\nconsole.log(target.foo); // bar\n")])])]),r("p",[e._v("事实上，如果真想创建一个可以捕获所有方法，然后将每个方法转发给对应反射 API 的空代理，那么甚至不需要定义处理程序对象：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("const target = {\n  foo: 'bar'\n};\n\nconst proxy = new Proxy(target, Reflect);\n\nconsole.log(proxy.foo);   // bar\nconsole.log(target.foo);  // bar\n")])])]),r("p",[e._v("反射 API 为开发者准备好了样板代码，在此基础上开发者可以用最少的代码修改捕获的方法。比如，下面的代码在某个属性被访问时，会对返回的值进行一番修饰：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("const target = {\n  foo: 'bar',\n  baz: 'qux'\n};\n\nconst handler = {\n  get(trapTarget, property, receiver) {\n    let decoration = '';\n    if (property === 'foo') {\n      decoration = '!!!';\n    }\n\n    return Reflect.get(...arguments) + decoration;\n  }\n};\n\nconst proxy = new Proxy(target, handler);\n\nconsole.log(proxy.foo);   // bar!!!\nconsole.log(target.foo);  // bar\n\nconsole.log(proxy.baz);   // qux\nconsole.log(target.baz);  // qux\n")])])]),r("h3",{attrs:{id:"_9-1-4-捕获器不变式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_9-1-4-捕获器不变式"}},[e._v("#")]),e._v(" 9.1.4 　捕获器不变式")]),e._v(" "),r("p",[e._v("使用捕获器几乎可以改变所有基本方法的行为，但也不是没有限制。根据 ECMAScript 规范，每个捕获的方法都知道目标对象上下文、捕获函数签名，而捕获处理程序的行为必须遵循“捕获器不变式”（trap invariant）。捕获器不变式因方法不同而异，但通常都会防止捕获器定义出现过于反常的行为。")]),e._v(" "),r("p",[e._v("比如，如果目标对象有一个不可配置且不可写的数据属性，那么在捕获器返回一个与该属性不同的值时，会抛出"),r("code",[e._v("TypeError")]),e._v("：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("const target = {};\nObject.defineProperty(target, 'foo', {\n  configurable: false,\n  writable: false,\n  value: 'bar'\n});\n\nconst handler = {\n  get() {\n    return 'qux';\n  }\n};\n\nconst proxy = new Proxy(target, handler);\n\nconsole.log(proxy.foo);\n// TypeError\n")])])]),r("h3",{attrs:{id:"_9-1-5-可撤销代理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_9-1-5-可撤销代理"}},[e._v("#")]),e._v(" 9.1.5 　可撤销代理")]),e._v(" "),r("p",[e._v("有时候可能需要中断代理对象与目标对象之间的联系。对于使用"),r("code",[e._v("new Proxy()")]),e._v("创建的普通代理来说，这种联系会在代理对象的生命周期内一直持续存在。")]),e._v(" "),r("p",[r("code",[e._v("Proxy")]),e._v("也暴露了"),r("code",[e._v("revocable()")]),e._v("方法，这个方法支持撤销代理对象与目标对象的关联。撤销代理的操作是不可逆的。而且，撤销函数（"),r("code",[e._v("revoke()")]),e._v("）是幂等的，调用多少次的结果都一样。撤销代理之后再调用代理会抛出"),r("code",[e._v("TypeError")]),e._v("。")]),e._v(" "),r("p",[e._v("撤销函数和代理对象是在实例化时同时生成的：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("const target = {\n  foo: 'bar'\n};\n\nconst handler = {\n  get() {\n    return 'intercepted';\n  }\n};\n\nconst { proxy, revoke } = Proxy.revocable(target, handler);\n\nconsole.log(proxy.foo);   // intercepted\nconsole.log(target.foo);  // bar\n\nrevoke();\n\nconsole.log(proxy.foo);   // TypeError\n")])])]),r("h3",{attrs:{id:"_9-1-6-实用反射-api"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_9-1-6-实用反射-api"}},[e._v("#")]),e._v(" 9.1.6 　实用反射 API")]),e._v(" "),r("p",[e._v("某些情况下应该优先使用反射 API，这是有一些理由的。")]),e._v(" "),r("ol",[r("li",[r("p",[r("strong",[e._v("反射 API 与对象 API")])]),e._v(" "),r("p",[e._v("在使用反射 API 时，要记住：")]),e._v(" "),r("p",[e._v("(1) 反射 API 并不限于捕获处理程序；")]),e._v(" "),r("p",[e._v("(2) 大多数反射 API 方法在"),r("code",[e._v("Object")]),e._v("类型上有对应的方法。")]),e._v(" "),r("p",[e._v("通常，"),r("code",[e._v("Object")]),e._v("上的方法适用于通用程序，而反射方法适用于细粒度的对象控制与操作。")])])]),e._v(" "),r("ol",{attrs:{start:"2"}},[r("li",[r("p",[r("strong",[e._v("状态标记")])]),e._v(" "),r("p",[e._v("很多反射方法返回称作“状态标记”的布尔值，表示意图执行的操作是否成功。有时候，状态标记比那些返回修改后的对象或者抛出错误（取决于方法）的反射 API 方法更有用。例如，可以使用反射 API 对下面的代码进行重构：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("// 初始代码\n\nconst o = {};\n\ntry {\n  Object.defineProperty(o, 'foo', 'bar');\n  console.log('success');\n} catch(e) {\n  console.log('failure');\n}\n")])])]),r("p",[e._v("在定义新属性时如果发生问题，"),r("code",[e._v("Reflect.defineProperty()")]),e._v("会返回"),r("code",[e._v("false")]),e._v("，而不是抛出错误。因此使用这个反射方法可以这样重构上面的代码：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("// 重构后的代码\n\nconst o = {};\n\nif(Reflect.defineProperty(o, 'foo', {value: 'bar'})) {\n  console.log('success');\n} else {\n  console.log('failure');\n}\n")])])]),r("p",[e._v("以下反射方法都会提供状态标记：")]),e._v(" "),r("ul",[r("li",[r("code",[e._v("Reflect.defineProperty()")])]),e._v(" "),r("li",[r("code",[e._v("Reflect.preventExtensions()")])]),e._v(" "),r("li",[r("code",[e._v("Reflect.setPrototypeOf()")])]),e._v(" "),r("li",[r("code",[e._v("Reflect.set()")])]),e._v(" "),r("li",[r("code",[e._v("Reflect.deleteProperty()")])])])])]),e._v(" "),r("ol",{attrs:{start:"3"}},[r("li",[r("p",[r("strong",[e._v("用一等函数替代操作符")])]),e._v(" "),r("p",[e._v("以下反射方法提供只有通过操作符才能完成的操作。")]),e._v(" "),r("ul",[r("li",[r("code",[e._v("Reflect.get()")]),e._v("：可以替代对象属性访问操作符。")]),e._v(" "),r("li",[r("code",[e._v("Reflect.set()")]),e._v("：可以替代"),r("code",[e._v("=")]),e._v("赋值操作符。")]),e._v(" "),r("li",[r("code",[e._v("Reflect.has()")]),e._v("：可以替代"),r("code",[e._v("in")]),e._v("操作符或"),r("code",[e._v("with()")]),e._v("。")]),e._v(" "),r("li",[r("code",[e._v("Reflect.deleteProperty()")]),e._v("：可以替代"),r("code",[e._v("delete")]),e._v("操作符。")]),e._v(" "),r("li",[r("code",[e._v("Reflect.construct()")]),e._v("：可以替代"),r("code",[e._v("new")]),e._v("操作符。")])])])]),e._v(" "),r("ol",{attrs:{start:"4"}},[r("li",[r("p",[r("strong",[e._v("安全地应用函数")])]),e._v(" "),r("p",[e._v("在通过"),r("code",[e._v("apply")]),e._v("方法调用函数时，被调用的函数可能也定义了自己的"),r("code",[e._v("apply")]),e._v("属性（虽然可能性极小）。为绕过这个问题，可以使用定义在"),r("code",[e._v("Function")]),e._v("原型上的"),r("code",[e._v("apply")]),e._v("方法，比如：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("Function.prototype.apply.call(myFunc, thisVal, argumentList);\n")])])]),r("p",[e._v("这种可怕的代码完全可以使用"),r("code",[e._v("Reflect.apply")]),e._v("来避免：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("Reflect.apply(myFunc, thisVal, argumentsList);\n")])])])])]),e._v(" "),r("h3",{attrs:{id:"_9-1-7-代理另一个代理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_9-1-7-代理另一个代理"}},[e._v("#")]),e._v(" 9.1.7 　代理另一个代理")]),e._v(" "),r("p",[e._v("代理可以拦截反射 API 的操作，而这意味着完全可以创建一个代理，通过它去代理另一个代理。这样就可以在一个目标对象之上构建多层拦截网：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("const target = {\n  foo: 'bar'\n};\n\nconst firstProxy = new Proxy(target, {\n  get() {\n    console.log('first proxy');\n    return Reflect.get(...arguments);\n  }\n});\n\nconst secondProxy = new Proxy(firstProxy, {\n  get() {\n    console.log('second proxy');\n    return Reflect.get(...arguments);\n  }\n});\n\nconsole.log(secondProxy.foo);\n// second proxy\n// first proxy\n// bar\n")])])]),r("h3",{attrs:{id:"_9-1-8-代理的问题与不足"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_9-1-8-代理的问题与不足"}},[e._v("#")]),e._v(" 9.1.8 　代理的问题与不足")]),e._v(" "),r("p",[e._v("代理是在 ECMAScript 现有基础之上构建起来的一套新 API，因此其实现已经尽力做到最好了。很大程度上，代理作为对象的虚拟层可以正常使用。但在某些情况下，代理也不能与现在的 ECMAScript 机制很好地协同。")]),e._v(" "),r("ol",[r("li",[r("p",[r("strong",[e._v("代理中的 this")])]),e._v(" "),r("p",[e._v("代理潜在的一个问题来源是"),r("code",[e._v("this")]),e._v("值。我们知道，方法中的"),r("code",[e._v("this")]),e._v("通常指向调用这个方法的对象：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("const target = {\n  thisValEqualsProxy() {\n    return this === proxy;\n  }\n}\n\nconst proxy = new Proxy(target, {});\n\nconsole.log(target.thisValEqualsProxy());  // false\nconsole.log(proxy.thisValEqualsProxy());   // true\n")])])]),r("p",[e._v("从直觉上讲，这样完全没有问题：调用代理上的任何方法，比如"),r("code",[e._v("proxy.outerMethod()")]),e._v("，而这个方法进而又会调用另一个方法，如"),r("code",[e._v("this.innerMethod()")]),e._v("，实际上都会调用"),r("code",[e._v("proxy.innerMethod()")]),e._v("。多数情况下，这是符合预期的行为。可是，如果目标对象依赖于对象标识，那就可能碰到意料之外的问题。")]),e._v(" "),r("p",[e._v("还记得第 6 章中通过"),r("code",[e._v("WeakMap")]),e._v("保存私有变量的例子吧，以下是它的简化版：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("const wm = new WeakMap();\n\nclass User {\n  constructor(userId) {\n    wm.set(this, userId);\n  }\n\n  set id(userId) {\n    wm.set(this, userId);\n  }\n\n  get id() {\n    return wm.get(this);\n  }\n}\n")])])]),r("p",[e._v("由于这个实现依赖"),r("code",[e._v("User")]),e._v("实例的对象标识，在这个实例被代理的情况下就会出问题：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("const user = new User(123);\nconsole.log(user.id); // 123\n\nconst userInstanceProxy = new Proxy(user, {});\nconsole.log(userInstanceProxy.id); // undefined\n")])])]),r("p",[e._v("这是因为"),r("code",[e._v("User")]),e._v("实例一开始使用目标对象作为"),r("code",[e._v("WeakMap")]),e._v("的键，代理对象却尝试从"),r("strong",[e._v("自身")]),e._v("取得这个实例。要解决这个问题，就需要重新配置代理，把代理"),r("code",[e._v("User")]),e._v("实例改为代理"),r("code",[e._v("User")]),e._v("类本身。之后再创建代理的实例就会以代理实例作为"),r("code",[e._v("WeakMap")]),e._v("的键了：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("const UserClassProxy = new Proxy(User, {});\nconst proxyUser = new UserClassProxy(456);\nconsole.log(proxyUser.id);\n")])])])])]),e._v(" "),r("ol",{attrs:{start:"2"}},[r("li",[r("p",[r("strong",[e._v("代理与内部槽位")])]),e._v(" "),r("p",[e._v("代理与内置引用类型（比如"),r("code",[e._v("Array")]),e._v("）的实例通常可以很好地协同，但有些 ECMAScript 内置类型可能会依赖代理无法控制的机制，结果导致在代理上调用某些方法会出错。")]),e._v(" "),r("p",[e._v("一个典型的例子就是"),r("code",[e._v("Date")]),e._v("类型。根据 ECMAScript 规范，"),r("code",[e._v("Date")]),e._v("类型方法的执行依赖"),r("code",[e._v("this")]),e._v("值上的内部槽位"),r("code",[e._v("[[NumberDate]]")]),e._v("。代理对象上不存在这个内部槽位，而且这个内部槽位的值也不能通过普通的"),r("code",[e._v("get()")]),e._v("和"),r("code",[e._v("set()")]),e._v("操作访问到，于是代理拦截后本应转发给目标对象的方法会抛出"),r("code",[e._v("TypeError")]),e._v("：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("const target = new Date();\nconst proxy = new Proxy(target, {});\n\nconsole.log(proxy instanceof Date);  // true\n\nproxy.getDate();  // TypeError: 'this' is not a Date object\n")])])])])]),e._v(" "),r("h2",{attrs:{id:"_9-2-代理捕获器与反射方法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_9-2-代理捕获器与反射方法"}},[e._v("#")]),e._v(" 9.2 　代理捕获器与反射方法")]),e._v(" "),r("p",[e._v("代理可以捕获 13 种不同的基本操作。这些操作有各自不同的反射 API 方法、参数、关联 ECMAScript 操作和不变式。")]),e._v(" "),r("p",[e._v("正如前面示例所展示的，有几种不同的 JavaScript 操作会调用同一个捕获器处理程序。不过，对于在代理对象上执行的任何一种操作，只会有一个捕获处理程序被调用。不会存在重复捕获的情况。")]),e._v(" "),r("p",[e._v("只要在代理上调用，所有捕获器都会拦截它们对应的反射 API 操作。")]),e._v(" "),r("h3",{attrs:{id:"_9-2-1-get"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_9-2-1-get"}},[e._v("#")]),e._v(" 9.2.1 　"),r("code",[e._v("get()")])]),e._v(" "),r("p",[r("code",[e._v("get()")]),e._v("捕获器会在获取属性值的操作中被调用。对应的反射 API 方法为"),r("code",[e._v("Reflect.get()")]),e._v("。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("const myTarget = {};\n\nconst proxy = new Proxy(myTarget, {\n  get(target, property, receiver) {\n    console.log('get()');\n    return Reflect.get(...arguments)\n  }\n});\n\nproxy.foo;\n// get()\n")])])]),r("ol",[r("li",[r("p",[r("strong",[e._v("返回值")])]),e._v(" "),r("p",[e._v("返回值无限制。")])])]),e._v(" "),r("ol",{attrs:{start:"2"}},[r("li",[r("p",[r("strong",[e._v("拦截的操作")])]),e._v(" "),r("ul",[r("li",[r("code",[e._v("proxy.property")])]),e._v(" "),r("li",[r("code",[e._v("proxy[property]")])]),e._v(" "),r("li",[r("code",[e._v("Object.create(proxy)[property]")])]),e._v(" "),r("li",[r("code",[e._v("Reflect.get(proxy, property, receiver)")])])])])]),e._v(" "),r("ol",{attrs:{start:"3"}},[r("li",[r("p",[r("strong",[e._v("捕获器处理程序参数")])]),e._v(" "),r("ul",[r("li",[r("code",[e._v("target")]),e._v("：目标对象。")]),e._v(" "),r("li",[r("code",[e._v("property")]),e._v("：引用的目标对象上的字符串键属性。")]),e._v(" "),r("li",[r("code",[e._v("receiver")]),e._v("：代理对象或继承代理对象的对象。")])])])]),e._v(" "),r("ol",{attrs:{start:"4"}},[r("li",[r("p",[r("strong",[e._v("捕获器不变式")])]),e._v(" "),r("p",[e._v("如果"),r("code",[e._v("target.property")]),e._v("不可写且不可配置，则处理程序返回的值必须与"),r("code",[e._v("target.property")]),e._v("匹配。")]),e._v(" "),r("p",[e._v("如果"),r("code",[e._v("target.property")]),e._v("不可配置且"),r("code",[e._v("[[Get]]")]),e._v("特性为"),r("code",[e._v("undefined")]),e._v("，处理程序的返回值也必须是"),r("code",[e._v("undefined")]),e._v("。")])])]),e._v(" "),r("h3",{attrs:{id:"_9-2-2-set"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_9-2-2-set"}},[e._v("#")]),e._v(" 9.2.2 　"),r("code",[e._v("set()")])]),e._v(" "),r("p",[r("code",[e._v("set()")]),e._v("捕获器会在设置属性值的操作中被调用。对应的反射 API 方法为"),r("code",[e._v("Reflect.set()")]),e._v("。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("const myTarget = {};\n\nconst proxy = new Proxy(myTarget, {\n  set(target, property, value, receiver) {\n    console.log('set()');\n    return Reflect.set(...arguments)\n  }\n});\n\nproxy.foo = 'bar';\n// set()\n")])])]),r("ol",[r("li",[r("p",[r("strong",[e._v("返回值")])]),e._v(" "),r("p",[e._v("返回"),r("code",[e._v("true")]),e._v("表示成功；返回"),r("code",[e._v("false")]),e._v("表示失败，严格模式下会抛出"),r("code",[e._v("TypeError")]),e._v("。")])])]),e._v(" "),r("ol",{attrs:{start:"2"}},[r("li",[r("p",[r("strong",[e._v("拦截的操作")])]),e._v(" "),r("ul",[r("li",[r("code",[e._v("proxy.property = value")])]),e._v(" "),r("li",[r("code",[e._v("proxy[property] = value")])]),e._v(" "),r("li",[r("code",[e._v("Object.create(proxy)[property] = value")])]),e._v(" "),r("li",[r("code",[e._v("Reflect.set(proxy, property, value, receiver)")])])])])]),e._v(" "),r("ol",{attrs:{start:"3"}},[r("li",[r("p",[r("strong",[e._v("捕获器处理程序参数")])]),e._v(" "),r("ul",[r("li",[r("code",[e._v("target")]),e._v("：目标对象。")]),e._v(" "),r("li",[r("code",[e._v("property")]),e._v("：引用的目标对象上的字符串键属性。")]),e._v(" "),r("li",[r("code",[e._v("value")]),e._v("：要赋给属性的值。")]),e._v(" "),r("li",[r("code",[e._v("receiver")]),e._v("：接收最初赋值的对象。")])])])]),e._v(" "),r("ol",{attrs:{start:"4"}},[r("li",[r("p",[r("strong",[e._v("捕获器不变式")])]),e._v(" "),r("p",[e._v("如果"),r("code",[e._v("target.property")]),e._v("不可写且不可配置，则不能修改目标属性的值。")]),e._v(" "),r("p",[e._v("如果"),r("code",[e._v("target.property")]),e._v("不可配置且"),r("code",[e._v("[[Set]]")]),e._v("特性为"),r("code",[e._v("undefined")]),e._v("，则不能修改目标属性的值。")]),e._v(" "),r("p",[e._v("在严格模式下，处理程序中返回"),r("code",[e._v("false")]),e._v("会抛出"),r("code",[e._v("TypeError")]),e._v("。")])])]),e._v(" "),r("h3",{attrs:{id:"_9-2-3-has"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_9-2-3-has"}},[e._v("#")]),e._v(" 9.2.3 　"),r("code",[e._v("has()")])]),e._v(" "),r("p",[r("code",[e._v("has()")]),e._v("捕获器会在"),r("code",[e._v("in")]),e._v("操作符中被调用。对应的反射 API 方法为"),r("code",[e._v("Reflect.has()")]),e._v("。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("const myTarget = {};\n\nconst proxy = new Proxy(myTarget, {\n  has(target, property) {\n    console.log('has()');\n    return Reflect.has(...arguments)\n  }\n});\n\n'foo' in proxy;\n// has()\n")])])]),r("ol",[r("li",[r("p",[r("strong",[e._v("返回值")])]),e._v(" "),r("p",[r("code",[e._v("has()")]),e._v("必须返回布尔值，表示属性是否存在。返回非布尔值会被转型为布尔值。")])])]),e._v(" "),r("ol",{attrs:{start:"2"}},[r("li",[r("p",[r("strong",[e._v("拦截的操作")])]),e._v(" "),r("ul",[r("li",[r("code",[e._v("property in proxy")])]),e._v(" "),r("li",[r("code",[e._v("property in Object.create(proxy)")])]),e._v(" "),r("li",[r("code",[e._v("with(proxy) {(property);}")])]),e._v(" "),r("li",[r("code",[e._v("Reflect.has(proxy, property)")])])])])]),e._v(" "),r("ol",{attrs:{start:"3"}},[r("li",[r("p",[r("strong",[e._v("捕获器处理程序参数")])]),e._v(" "),r("ul",[r("li",[r("code",[e._v("target")]),e._v("：目标对象。")]),e._v(" "),r("li",[r("code",[e._v("property")]),e._v("：引用的目标对象上的字符串键属性。")])])])]),e._v(" "),r("ol",{attrs:{start:"4"}},[r("li",[r("p",[r("strong",[e._v("捕获器不变式")])]),e._v(" "),r("p",[e._v("如果"),r("code",[e._v("target.property")]),e._v("存在且不可配置，则处理程序必须返回"),r("code",[e._v("true")]),e._v("。")]),e._v(" "),r("p",[e._v("如果"),r("code",[e._v("target.property")]),e._v("存在且目标对象不可扩展，则处理程序必须返回"),r("code",[e._v("true")]),e._v("。")])])]),e._v(" "),r("h3",{attrs:{id:"_9-2-4-defineproperty"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_9-2-4-defineproperty"}},[e._v("#")]),e._v(" 9.2.4 　"),r("code",[e._v("defineProperty()")])]),e._v(" "),r("p",[r("code",[e._v("defineProperty()")]),e._v("捕获器会在"),r("code",[e._v("Object.defineProperty()")]),e._v("中被调用。对应的反射 API 方法为"),r("code",[e._v("Reflect.defineProperty()")]),e._v("。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("const myTarget = {};\n\nconst proxy = new Proxy(myTarget, {\n  defineProperty(target, property, descriptor) {\n    console.log('defineProperty()');\n    return Reflect.defineProperty(...arguments)\n  }\n});\n\nObject.defineProperty(proxy, 'foo', { value: 'bar' });\n// defineProperty()\n")])])]),r("ol",[r("li",[r("p",[r("strong",[e._v("返回值")])]),e._v(" "),r("p",[r("code",[e._v("defineProperty()")]),e._v("必须返回布尔值，表示属性是否成功定义。返回非布尔值会被转型为布尔值。")])])]),e._v(" "),r("ol",{attrs:{start:"2"}},[r("li",[r("p",[r("strong",[e._v("拦截的操作")])]),e._v(" "),r("ul",[r("li",[r("code",[e._v("Object.defineProperty(proxy, property, descriptor)")])]),e._v(" "),r("li",[r("code",[e._v("Reflect.defineProperty(proxy, property, descriptor)")])])])])]),e._v(" "),r("ol",{attrs:{start:"3"}},[r("li",[r("p",[r("strong",[e._v("捕获器处理程序参数")])]),e._v(" "),r("ul",[r("li",[r("code",[e._v("target")]),e._v("：目标对象。")]),e._v(" "),r("li",[r("code",[e._v("property")]),e._v("：引用的目标对象上的字符串键属性。")]),e._v(" "),r("li",[r("code",[e._v("descriptor")]),e._v("：包含可选的"),r("code",[e._v("enumerable")]),e._v("、"),r("code",[e._v("configurable")]),e._v("、"),r("code",[e._v("writable")]),e._v("、"),r("code",[e._v("value")]),e._v("、"),r("code",[e._v("get")]),e._v("和"),r("code",[e._v("set")]),e._v("定义的对象。")])])])]),e._v(" "),r("ol",{attrs:{start:"4"}},[r("li",[r("p",[r("strong",[e._v("捕获器不变式")])]),e._v(" "),r("p",[e._v("如果目标对象不可扩展，则无法定义属性。")]),e._v(" "),r("p",[e._v("如果目标对象有一个可配置的属性，则不能添加同名的不可配置属性。")]),e._v(" "),r("p",[e._v("如果目标对象有一个不可配置的属性，则不能添加同名的可配置属性。")])])]),e._v(" "),r("h3",{attrs:{id:"_9-2-5-getownpropertydescriptor"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_9-2-5-getownpropertydescriptor"}},[e._v("#")]),e._v(" 9.2.5 　"),r("code",[e._v("getOwnPropertyDescriptor()")])]),e._v(" "),r("p",[r("code",[e._v("getOwnPropertyDescriptor()")]),e._v("捕获器会在"),r("code",[e._v("Object.getOwnPropertyDescriptor()")]),e._v("中被调用。对应的反射 API 方法为"),r("code",[e._v("Reflect.getOwnPropertyDescriptor()")]),e._v("。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("const myTarget = {};\n\nconst proxy = new Proxy(myTarget, {\n  getOwnPropertyDescriptor(target, property) {\n    console.log('getOwnPropertyDescriptor()');\n    return Reflect.getOwnPropertyDescriptor(...arguments)\n  }\n});\n\nObject.getOwnPropertyDescriptor(proxy, 'foo');\n// getOwnPropertyDescriptor()\n")])])]),r("ol",[r("li",[r("p",[r("strong",[e._v("返回值")])]),e._v(" "),r("p",[r("code",[e._v("getOwnPropertyDescriptor()")]),e._v("必须返回对象，或者在属性不存在时返回"),r("code",[e._v("undefined")]),e._v("。")])])]),e._v(" "),r("ol",{attrs:{start:"2"}},[r("li",[r("p",[r("strong",[e._v("拦截的操作")])]),e._v(" "),r("ul",[r("li",[r("code",[e._v("Object.getOwnPropertyDescriptor(proxy, property)")])]),e._v(" "),r("li",[r("code",[e._v("Reflect.getOwnPropertyDescriptor(proxy, property)")])])])])]),e._v(" "),r("ol",{attrs:{start:"3"}},[r("li",[r("p",[r("strong",[e._v("捕获器处理程序参数")])]),e._v(" "),r("ul",[r("li",[r("code",[e._v("target")]),e._v("：目标对象。")]),e._v(" "),r("li",[r("code",[e._v("property")]),e._v("：引用的目标对象上的字符串键属性。")])])])]),e._v(" "),r("ol",{attrs:{start:"4"}},[r("li",[r("p",[r("strong",[e._v("捕获器不变式")])]),e._v(" "),r("p",[e._v("如果自有的"),r("code",[e._v("target.property")]),e._v("存在且不可配置，则处理程序必须返回一个表示该属性存在的对象。")]),e._v(" "),r("p",[e._v("如果自有的"),r("code",[e._v("target.property")]),e._v("存在且可配置，则处理程序必须返回表示该属性可配置的对象。")]),e._v(" "),r("p",[e._v("如果自有的"),r("code",[e._v("target.property")]),e._v("存在且"),r("code",[e._v("target")]),e._v("不可扩展，则处理程序必须返回一个表示该属性存在的对象。")]),e._v(" "),r("p",[e._v("如果"),r("code",[e._v("target.property")]),e._v("不存在且"),r("code",[e._v("target")]),e._v("不可扩展，则处理程序必须返回"),r("code",[e._v("undefined")]),e._v("表示该属性不存在。")]),e._v(" "),r("p",[e._v("如果"),r("code",[e._v("target.property")]),e._v("不存在，则处理程序不能返回表示该属性可配置的对象。")])])]),e._v(" "),r("h3",{attrs:{id:"_9-2-6-deleteproperty"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_9-2-6-deleteproperty"}},[e._v("#")]),e._v(" 9.2.6 　"),r("code",[e._v("deleteProperty()")])]),e._v(" "),r("p",[r("code",[e._v("deleteProperty()")]),e._v("捕获器会在"),r("code",[e._v("delete")]),e._v("操作符中被调用。对应的反射 API 方法为"),r("code",[e._v("Reflect.deleteProperty()")]),e._v("。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("const myTarget = {};\n\nconst proxy = new Proxy(myTarget, {\n  deleteProperty(target, property) {\n    console.log('deleteProperty()');\n    return Reflect.deleteProperty(...arguments)\n  }\n});\n\ndelete proxy.foo\n// deleteProperty()\n")])])]),r("ol",[r("li",[r("p",[r("strong",[e._v("返回值")])]),e._v(" "),r("p",[r("code",[e._v("deleteProperty()")]),e._v("必须返回布尔值，表示删除属性是否成功。返回非布尔值会被转型为布尔值。")])])]),e._v(" "),r("ol",{attrs:{start:"2"}},[r("li",[r("p",[r("strong",[e._v("拦截的操作")])]),e._v(" "),r("ul",[r("li",[r("code",[e._v("delete proxy.property")])]),e._v(" "),r("li",[r("code",[e._v("delete proxy[property]")])]),e._v(" "),r("li",[r("code",[e._v("Reflect.deleteProperty(proxy, property)")])])])])]),e._v(" "),r("ol",{attrs:{start:"3"}},[r("li",[r("p",[r("strong",[e._v("捕获器处理程序参数")])]),e._v(" "),r("ul",[r("li",[r("code",[e._v("target")]),e._v("：目标对象。")]),e._v(" "),r("li",[r("code",[e._v("property")]),e._v("：引用的目标对象上的字符串键属性。")])])])]),e._v(" "),r("ol",{attrs:{start:"4"}},[r("li",[r("p",[r("strong",[e._v("捕获器不变式")])]),e._v(" "),r("p",[e._v("如果自有的"),r("code",[e._v("target.property")]),e._v("存在且不可配置，则处理程序不能删除这个属性。")])])]),e._v(" "),r("h3",{attrs:{id:"_9-2-7-ownkeys"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_9-2-7-ownkeys"}},[e._v("#")]),e._v(" 9.2.7 　"),r("code",[e._v("ownKeys()")])]),e._v(" "),r("p",[r("code",[e._v("ownKeys()")]),e._v("捕获器会在"),r("code",[e._v("Object.keys()")]),e._v("及类似方法中被调用。对应的反射 API 方法为"),r("code",[e._v("Reflect.ownKeys()")]),e._v("。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("const myTarget = {};\n\nconst proxy = new Proxy(myTarget, {\n  ownKeys(target) {\n    console.log('ownKeys()');\n    return Reflect.ownKeys(...arguments)\n  }\n});\n\nObject.keys(proxy);\n// ownKeys()\n")])])]),r("ol",[r("li",[r("p",[r("strong",[e._v("返回值")])]),e._v(" "),r("p",[r("code",[e._v("ownKeys()")]),e._v("必须返回包含字符串或符号的可枚举对象。")])])]),e._v(" "),r("ol",{attrs:{start:"2"}},[r("li",[r("p",[r("strong",[e._v("拦截的操作")])]),e._v(" "),r("ul",[r("li",[r("code",[e._v("Object.getOwnPropertyNames(proxy)")])]),e._v(" "),r("li",[r("code",[e._v("Object.getOwnPropertySymbols(proxy)")])]),e._v(" "),r("li",[r("code",[e._v("Object.keys(proxy)")])]),e._v(" "),r("li",[r("code",[e._v("Reflect.ownKeys(proxy)")])])])])]),e._v(" "),r("ol",{attrs:{start:"3"}},[r("li",[r("p",[r("strong",[e._v("捕获器处理程序参数")])]),e._v(" "),r("ul",[r("li",[r("code",[e._v("target")]),e._v("：目标对象。")])])])]),e._v(" "),r("ol",{attrs:{start:"4"}},[r("li",[r("p",[r("strong",[e._v("捕获器不变式")])]),e._v(" "),r("p",[e._v("返回的可枚举对象必须包含"),r("code",[e._v("target")]),e._v("的所有不可配置的自有属性。")]),e._v(" "),r("p",[e._v("如果"),r("code",[e._v("target")]),e._v("不可扩展，则返回可枚举对象必须准确地包含自有属性键。")])])]),e._v(" "),r("h3",{attrs:{id:"_9-2-8-getprototypeof"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_9-2-8-getprototypeof"}},[e._v("#")]),e._v(" 9.2.8 　"),r("code",[e._v("getPrototypeOf()")])]),e._v(" "),r("p",[r("code",[e._v("getPrototypeOf()")]),e._v("捕获器会在"),r("code",[e._v("Object.getPrototypeOf()")]),e._v("中被调用。对应的反射 API 方法为"),r("code",[e._v("Reflect.getPrototypeOf()")]),e._v("。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("const myTarget = {};\n\nconst proxy = new Proxy(myTarget, {\n  getPrototypeOf(target) {\n    console.log('getPrototypeOf()');\n    return Reflect.getPrototypeOf(...arguments)\n  }\n});\n\nObject.getPrototypeOf(proxy);\n// getPrototypeOf()\n")])])]),r("ol",[r("li",[r("p",[r("strong",[e._v("返回值")])]),e._v(" "),r("p",[r("code",[e._v("getPrototypeOf()")]),e._v("必须返回对象或"),r("code",[e._v("null")]),e._v("。")])])]),e._v(" "),r("ol",{attrs:{start:"2"}},[r("li",[r("p",[r("strong",[e._v("拦截的操作")])]),e._v(" "),r("ul",[r("li",[r("code",[e._v("Object.getPrototypeOf(proxy)")])]),e._v(" "),r("li",[r("code",[e._v("Reflect.getPrototypeOf(proxy)")])]),e._v(" "),r("li",[r("code",[e._v("proxy.__proto__")])]),e._v(" "),r("li",[r("code",[e._v("Object.prototype.isPrototypeOf(proxy)")])]),e._v(" "),r("li",[r("code",[e._v("proxy instanceof Object")])])])])]),e._v(" "),r("ol",{attrs:{start:"3"}},[r("li",[r("p",[r("strong",[e._v("捕获器处理程序参数")])]),e._v(" "),r("ul",[r("li",[r("code",[e._v("target")]),e._v("：目标对象。")])])])]),e._v(" "),r("ol",{attrs:{start:"4"}},[r("li",[r("p",[r("strong",[e._v("捕获器不变式")])]),e._v(" "),r("p",[e._v("如果"),r("code",[e._v("target")]),e._v("不可扩展，则"),r("code",[e._v("Object.getPrototypeOf(proxy)")]),e._v("唯一有效的返回值就是"),r("code",[e._v("Object.getPrototypeOf(target)")]),e._v("的返回值。")])])]),e._v(" "),r("h3",{attrs:{id:"_9-2-9-setprototypeof"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_9-2-9-setprototypeof"}},[e._v("#")]),e._v(" 9.2.9 　"),r("code",[e._v("setPrototypeOf()")])]),e._v(" "),r("p",[r("code",[e._v("setPrototypeOf()")]),e._v("捕获器会在"),r("code",[e._v("Object.setPrototypeOf()")]),e._v("中被调用。对应的反射 API 方法为"),r("code",[e._v("Reflect.setPrototypeOf()")]),e._v("。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("const myTarget = {};\n\nconst proxy = new Proxy(myTarget, {\n  setPrototypeOf(target, prototype) {\n    console.log('setPrototypeOf()');\n    return Reflect.setPrototypeOf(...arguments)\n  }\n});\n\nObject.setPrototypeOf(proxy, Object);\n// setPrototypeOf()\n")])])]),r("ol",[r("li",[r("p",[r("strong",[e._v("返回值")])]),e._v(" "),r("p",[r("code",[e._v("setPrototypeOf()")]),e._v("必须返回布尔值，表示原型赋值是否成功。返回非布尔值会被转型为布尔值。")])])]),e._v(" "),r("ol",{attrs:{start:"2"}},[r("li",[r("p",[r("strong",[e._v("拦截的操作")])]),e._v(" "),r("ul",[r("li",[r("code",[e._v("Object.setPrototypeOf(proxy)")])]),e._v(" "),r("li",[r("code",[e._v("Reflect.setPrototypeOf(proxy)")])])])])]),e._v(" "),r("ol",{attrs:{start:"3"}},[r("li",[r("p",[r("strong",[e._v("捕获器处理程序参数")])]),e._v(" "),r("ul",[r("li",[r("code",[e._v("target")]),e._v("：目标对象。")]),e._v(" "),r("li",[r("code",[e._v("prototype")]),e._v("："),r("code",[e._v("target")]),e._v("的替代原型，如果是顶级原型则为"),r("code",[e._v("null")]),e._v("。")])])])]),e._v(" "),r("ol",{attrs:{start:"4"}},[r("li",[r("p",[r("strong",[e._v("捕获器不变式")])]),e._v(" "),r("p",[e._v("如果"),r("code",[e._v("target")]),e._v("不可扩展，则唯一有效的"),r("code",[e._v("prototype")]),e._v("参数就是"),r("code",[e._v("Object.getPrototypeOf(target)")]),e._v("的返回值。")])])]),e._v(" "),r("h3",{attrs:{id:"_9-2-10-isextensible"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_9-2-10-isextensible"}},[e._v("#")]),e._v(" 9.2.10 　"),r("code",[e._v("isExtensible()")])]),e._v(" "),r("p",[r("code",[e._v("isExtensible()")]),e._v("捕获器会在"),r("code",[e._v("Object.isExtensible()")]),e._v("中被调用。对应的反射 API 方法为"),r("code",[e._v("Reflect.isExtensible()")]),e._v("。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("const myTarget = {};\n\nconst proxy = new Proxy(myTarget, {\n  isExtensible(target) {\n    console.log('isExtensible()');\n    return Reflect.isExtensible(...arguments)\n  }\n});\n\nObject.isExtensible(proxy);\n// isExtensible()\n")])])]),r("ol",[r("li",[r("p",[r("strong",[e._v("返回值")])]),e._v(" "),r("p",[r("code",[e._v("isExtensible()")]),e._v("必须返回布尔值，表示"),r("code",[e._v("target")]),e._v("是否可扩展。返回非布尔值会被转型为布尔值。")])])]),e._v(" "),r("ol",{attrs:{start:"2"}},[r("li",[r("p",[r("strong",[e._v("拦截的操作")])]),e._v(" "),r("ul",[r("li",[r("code",[e._v("Object.isExtensible(proxy)")])]),e._v(" "),r("li",[r("code",[e._v("Reflect.isExtensible(proxy)")])])])])]),e._v(" "),r("ol",{attrs:{start:"3"}},[r("li",[r("p",[r("strong",[e._v("捕获器处理程序参数")])]),e._v(" "),r("ul",[r("li",[r("code",[e._v("target")]),e._v("：目标对象。")])])])]),e._v(" "),r("ol",{attrs:{start:"4"}},[r("li",[r("p",[r("strong",[e._v("捕获器不变式")])]),e._v(" "),r("p",[e._v("如果"),r("code",[e._v("target")]),e._v("可扩展，则处理程序必须返回"),r("code",[e._v("true")]),e._v("。")]),e._v(" "),r("p",[e._v("如果"),r("code",[e._v("target")]),e._v("不可扩展，则处理程序必须返回"),r("code",[e._v("false")]),e._v("。")])])]),e._v(" "),r("h3",{attrs:{id:"_9-2-11-preventextensions"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_9-2-11-preventextensions"}},[e._v("#")]),e._v(" 9.2.11 　"),r("code",[e._v("preventExtensions()")])]),e._v(" "),r("p",[r("code",[e._v("preventExtensions()")]),e._v("捕获器会在"),r("code",[e._v("Object.preventExtensions()")]),e._v("中被调用。对应的反射 API 方法为"),r("code",[e._v("Reflect.preventExtensions()")]),e._v("。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("const myTarget = {};\n\nconst proxy = new Proxy(myTarget, {\n  preventExtensions(target) {\n    console.log('preventExtensions()');\n    return Reflect.preventExtensions(...arguments)\n  }\n});\n\nObject.preventExtensions(proxy);\n// preventExtensions()\n")])])]),r("ol",[r("li",[r("p",[r("strong",[e._v("返回值")])]),e._v(" "),r("p",[r("code",[e._v("preventExtensions()")]),e._v("必须返回布尔值，表示"),r("code",[e._v("target")]),e._v("是否已经不可扩展。返回非布尔值会被转型为布尔值。")])])]),e._v(" "),r("ol",{attrs:{start:"2"}},[r("li",[r("p",[r("strong",[e._v("拦截的操作")])]),e._v(" "),r("ul",[r("li",[r("code",[e._v("Object.preventExtensions(proxy)")])]),e._v(" "),r("li",[r("code",[e._v("Reflect.preventExtensions(proxy)")])])])])]),e._v(" "),r("ol",{attrs:{start:"3"}},[r("li",[r("p",[r("strong",[e._v("捕获器处理程序参数")])]),e._v(" "),r("ul",[r("li",[r("code",[e._v("target")]),e._v("：目标对象。")])])])]),e._v(" "),r("ol",{attrs:{start:"4"}},[r("li",[r("p",[r("strong",[e._v("捕获器不变式")])]),e._v(" "),r("p",[e._v("如果"),r("code",[e._v("Object.isExtensible(proxy)")]),e._v("是"),r("code",[e._v("false")]),e._v("，则处理程序必须返回"),r("code",[e._v("true")]),e._v("。")])])]),e._v(" "),r("h3",{attrs:{id:"_9-2-12-apply"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_9-2-12-apply"}},[e._v("#")]),e._v(" 9.2.12 　"),r("code",[e._v("apply()")])]),e._v(" "),r("p",[r("code",[e._v("apply()")]),e._v("捕获器会在调用函数时中被调用。对应的反射 API 方法为"),r("code",[e._v("Reflect.apply()")]),e._v("。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("const myTarget = () => {};\n\nconst proxy = new Proxy(myTarget, {\n  apply(target, thisArg, ...argumentsList) {\n    console.log('apply()');\n    return Reflect.apply(...arguments)\n  }\n});\n\nproxy();\n// apply()\n")])])]),r("ol",[r("li",[r("p",[r("strong",[e._v("返回值")])]),e._v(" "),r("p",[e._v("返回值无限制。")])])]),e._v(" "),r("ol",{attrs:{start:"2"}},[r("li",[r("p",[r("strong",[e._v("拦截的操作")])]),e._v(" "),r("ul",[r("li",[r("code",[e._v("proxy(...argumentsList)")])]),e._v(" "),r("li",[r("code",[e._v("Function.prototype.apply(thisArg, argumentsList)")])]),e._v(" "),r("li",[r("code",[e._v("Function.prototype.call(thisArg, ...argumentsList)")])]),e._v(" "),r("li",[r("code",[e._v("Reflect.apply(target, thisArgument, argumentsList)")])])])])]),e._v(" "),r("ol",{attrs:{start:"3"}},[r("li",[r("p",[r("strong",[e._v("捕获器处理程序参数")])]),e._v(" "),r("ul",[r("li",[r("code",[e._v("target")]),e._v("：目标对象。")]),e._v(" "),r("li",[r("code",[e._v("thisArg")]),e._v("：调用函数时的"),r("code",[e._v("this")]),e._v("参数。")]),e._v(" "),r("li",[r("code",[e._v("argumentsList")]),e._v("：调用函数时的参数列表")])])])]),e._v(" "),r("ol",{attrs:{start:"4"}},[r("li",[r("p",[r("strong",[e._v("捕获器不变式")])]),e._v(" "),r("p",[r("code",[e._v("target")]),e._v("必须是一个函数对象。")])])]),e._v(" "),r("h3",{attrs:{id:"_9-2-13-construct"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_9-2-13-construct"}},[e._v("#")]),e._v(" 9.2.13 　"),r("code",[e._v("construct()")])]),e._v(" "),r("p",[r("code",[e._v("construct()")]),e._v("捕获器会在"),r("code",[e._v("new")]),e._v("操作符中被调用。对应的反射 API 方法为"),r("code",[e._v("Reflect.construct()")]),e._v("。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("const myTarget = function() {};\n\nconst proxy = new Proxy(myTarget, {\n  construct(target, argumentsList, newTarget) {\n    console.log('construct()');\n    return Reflect.construct(...arguments)\n  }\n});\n\nnew proxy;\n// construct()\n")])])]),r("ol",[r("li",[r("p",[r("strong",[e._v("返回值")])]),e._v(" "),r("p",[r("code",[e._v("construct()")]),e._v("必须返回一个对象。")])])]),e._v(" "),r("ol",{attrs:{start:"2"}},[r("li",[r("p",[r("strong",[e._v("拦截的操作")])]),e._v(" "),r("ul",[r("li",[r("code",[e._v("new proxy(...argumentsList)")])]),e._v(" "),r("li",[r("code",[e._v("Reflect.construct(target, argumentsList, newTarget)")])])])])]),e._v(" "),r("ol",{attrs:{start:"3"}},[r("li",[r("p",[r("strong",[e._v("捕获器处理程序参数")])]),e._v(" "),r("ul",[r("li",[r("code",[e._v("target")]),e._v("：目标构造函数。")]),e._v(" "),r("li",[r("code",[e._v("argumentsList")]),e._v("：传给目标构造函数的参数列表。")]),e._v(" "),r("li",[r("code",[e._v("newTarget")]),e._v("：最初被调用的构造函数。")])])])]),e._v(" "),r("ol",{attrs:{start:"4"}},[r("li",[r("p",[r("strong",[e._v("捕获器不变式")])]),e._v(" "),r("p",[r("code",[e._v("target")]),e._v("必须可以用作构造函数。")])])]),e._v(" "),r("h2",{attrs:{id:"_9-3-代理模式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_9-3-代理模式"}},[e._v("#")]),e._v(" 9.3 　代理模式")]),e._v(" "),r("p",[e._v("使用代理可以在代码中实现一些有用的编程模式。")]),e._v(" "),r("h3",{attrs:{id:"_9-3-1-跟踪属性访问"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_9-3-1-跟踪属性访问"}},[e._v("#")]),e._v(" 9.3.1 　跟踪属性访问")]),e._v(" "),r("p",[e._v("通过捕获"),r("code",[e._v("get")]),e._v("、"),r("code",[e._v("set")]),e._v("和"),r("code",[e._v("has")]),e._v("等操作，可以知道对象属性什么时候被访问、被查询。把实现相应捕获器的某个对象代理放到应用中，可以监控这个对象何时在何处被访问过：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("const user = {\n  name: 'Jake'\n};\n\nconst proxy = new Proxy(user, {\n  get(target, property, receiver) {\n    console.log('Getting ${property}');\n\n    return Reflect.get(...arguments);\n  },\n  set(target, property, value, receiver) {\n    console.log('Setting ${property}=${value}');\n\n    return Reflect.set(...arguments);\n  }\n});\n\nproxy.name;     // Getting name\nproxy.age = 27; // Setting age=27\n")])])]),r("h3",{attrs:{id:"_9-3-2-隐藏属性"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_9-3-2-隐藏属性"}},[e._v("#")]),e._v(" 9.3.2 　隐藏属性")]),e._v(" "),r("p",[e._v("代理的内部实现对外部代码是不可见的，因此要隐藏目标对象上的属性也轻而易举。比如：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("const hiddenProperties = ['foo', 'bar'];\nconst targetObject = {\n  foo: 1,\n  bar: 2,\n  baz: 3\n};\nconst proxy = new Proxy(targetObject, {\n  get(target, property) {\n    if (hiddenProperties.includes(property)) {\n      return undefined;\n    } else {\n      return Reflect.get(...arguments);\n    }\n  },\n  has(target, property) {\n    if (hiddenProperties.includes(property)) {\n      return false;\n    } else {\n      return Reflect.has(...arguments);\n    }\n  }\n});\n\n// get()\nconsole.log(proxy.foo);  // undefined\nconsole.log(proxy.bar);  // undefined\nconsole.log(proxy.baz);  // 3\n\n// has()\nconsole.log('foo' in proxy);  // false\nconsole.log('bar' in proxy);  // false\nconsole.log('baz' in proxy);  // true\n")])])]),r("h3",{attrs:{id:"_9-3-3-属性验证"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_9-3-3-属性验证"}},[e._v("#")]),e._v(" 9.3.3 　属性验证")]),e._v(" "),r("p",[e._v("因为所有赋值操作都会触发"),r("code",[e._v("set()")]),e._v("捕获器，所以可以根据所赋的值决定是允许还是拒绝赋值：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("const target = {\n  onlyNumbersGoHere: 0\n};\n\nconst proxy = new Proxy(target, {\n  set(target, property, value) {\n    if (typeof value !== 'Number') {\n      return false;\n    } else {\n      return Reflect.set(...arguments);\n    }\n  }\n});\n\nproxy.onlyNumbersGoHere = 1;\nconsole.log(proxy.onlyNumbersGoHere);  // 1\nproxy.onlyNumbersGoHere = '2';\nconsole.log(proxy.onlyNumbersGoHere);  // 1\n")])])]),r("h3",{attrs:{id:"_9-3-4-函数与构造函数参数验证"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_9-3-4-函数与构造函数参数验证"}},[e._v("#")]),e._v(" 9.3.4 　函数与构造函数参数验证")]),e._v(" "),r("p",[e._v("跟保护和验证对象属性类似，也可对函数和构造函数参数进行审查。比如，可以让函数只接收某种类型的值：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("function median(...nums) {\n  return nums.sort()[Math.floor(nums.length / 2)];\n}\n\nconst proxy = new Proxy(median, {\n  apply(target, thisArg, ...argumentsList) {\n    for (const arg of argumentsList) {\n      if (typeof arg !== 'number') {\n        throw 'Non-number argument provided';\n      }\n    }\n    return Reflect.apply(...arguments);\n  }\n});\n\nconsole.log(proxy(4, 7, 1));  // 4\nconsole.log(proxy(4, '7', 1));\n// Error: Non-number argument provided\n")])])]),r("p",[e._v("类似地，可以要求实例化时必须给构造函数传参：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("class User {\n  constructor(id) {\n    this.id_ = id;\n  }\n}\n\nconst proxy = new Proxy(User, {\n  construct(target, argumentsList, newTarget) {\n    if (argumentsList[0] === undefined) {\n      throw 'User cannot be instantiated without id';\n    } else {\n      return Reflect.construct(...arguments);\n    }\n  }\n});\n\nnew proxy(1);\n\nnew proxy();\n// Error: User cannot be instantiated without id\n")])])]),r("h3",{attrs:{id:"_9-3-5-数据绑定与可观察对象"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_9-3-5-数据绑定与可观察对象"}},[e._v("#")]),e._v(" 9.3.5 　数据绑定与可观察对象")]),e._v(" "),r("p",[e._v("通过代理可以把运行时中原本不相关的部分联系到一起。这样就可以实现各种模式，从而让不同的代码互操作。")]),e._v(" "),r("p",[e._v("比如，可以将被代理的类绑定到一个全局实例集合，让所有创建的实例都被添加到这个集合中：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("const userList = [];\n\nclass User {\n  constructor(name) {\n    this.name_ = name;\n  }\n}\n\nconst proxy = new Proxy(User, {\n  construct() {\n    const newUser = Reflect.construct(...arguments);\n    userList.push(newUser);\n    return newUser;\n  }\n});\n\nnew proxy('John');\nnew proxy('Jacob');\nnew proxy('Jingleheimerschmidt');\n\nconsole.log(userList); // [User {}, User {}, User{}]\n")])])]),r("p",[e._v("另外，还可以把集合绑定到一个事件分派程序，每次插入新实例时都会发送消息：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("const userList = [];\n\nfunction emit(newValue) {\n  console.log(newValue);\n}\n\nconst proxy = new Proxy(userList, {\n  set(target, property, value, receiver) {\n    const result = Reflect.set(...arguments);\n    if (result) {\n      emit(Reflect.get(target, property, receiver));\n    }\n    return result;\n  }\n});\n\nproxy.push('John');\n// John\nproxy.push('Jacob');\n// Jacob\n")])])]),r("h2",{attrs:{id:"_9-4-小结"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_9-4-小结"}},[e._v("#")]),e._v(" 9.4 　小结")]),e._v(" "),r("p",[e._v("代理是 ECMAScript 6 新增的令人兴奋和动态十足的新特性。尽管不支持向后兼容，但它开辟出了一片前所未有的 JavaScript 元编程及抽象的新天地。")]),e._v(" "),r("p",[e._v("从宏观上看，代理是真实 JavaScript 对象的透明抽象层。代理可以定义包含"),r("strong",[e._v("捕获器")]),e._v("的处理程序对象，而这些捕获器可以拦截绝大部分 JavaScript 的基本操作和方法。在这个捕获器处理程序中，可以修改任何基本操作的行为，当然前提是遵从"),r("strong",[e._v("捕获器不变式")]),e._v("。")]),e._v(" "),r("p",[e._v("与代理如影随形的反射 API，则封装了一整套与捕获器拦截的操作相对应的方法。可以把反射 API 看作一套基本操作，这些操作是绝大部分 JavaScript 对象 API 的基础。")]),e._v(" "),r("p",[e._v("代理的应用场景是不可限量的。开发者使用它可以创建出各种编码模式，比如（但远远不限于）跟踪属性访问、隐藏属性、阻止修改或删除属性、函数参数验证、构造函数参数验证、数据绑定，以及可观察对象。")])])}),[],!1,null,null,null);t.default=n.exports}}]);